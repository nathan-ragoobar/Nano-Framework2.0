\doxysection{btree.\+h}
\hypertarget{tensor_2build_2__deps_2absl-src_2absl_2container_2internal_2btree_8h_source}{}\label{tensor_2build_2__deps_2absl-src_2absl_2container_2internal_2btree_8h_source}\index{tensor/build/\_deps/absl-\/src/absl/container/internal/btree.h@{tensor/build/\_deps/absl-\/src/absl/container/internal/btree.h}}
\mbox{\hyperlink{tensor_2build_2__deps_2absl-src_2absl_2container_2internal_2btree_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{comment}{//\ Copyright\ 2018\ The\ Abseil\ Authors.}}
\DoxyCodeLine{00002\ \textcolor{comment}{//}}
\DoxyCodeLine{00003\ \textcolor{comment}{//\ Licensed\ under\ the\ Apache\ License,\ Version\ 2.0\ (the\ "{}License"{});}}
\DoxyCodeLine{00004\ \textcolor{comment}{//\ you\ may\ not\ use\ this\ file\ except\ in\ compliance\ with\ the\ License.}}
\DoxyCodeLine{00005\ \textcolor{comment}{//\ You\ may\ obtain\ a\ copy\ of\ the\ License\ at}}
\DoxyCodeLine{00006\ \textcolor{comment}{//}}
\DoxyCodeLine{00007\ \textcolor{comment}{//\ \ \ \ \ \ https://www.apache.org/licenses/LICENSE-\/2.0}}
\DoxyCodeLine{00008\ \textcolor{comment}{//}}
\DoxyCodeLine{00009\ \textcolor{comment}{//\ Unless\ required\ by\ applicable\ law\ or\ agreed\ to\ in\ writing,\ software}}
\DoxyCodeLine{00010\ \textcolor{comment}{//\ distributed\ under\ the\ License\ is\ distributed\ on\ an\ "{}AS\ IS"{}\ BASIS,}}
\DoxyCodeLine{00011\ \textcolor{comment}{//\ WITHOUT\ WARRANTIES\ OR\ CONDITIONS\ OF\ ANY\ KIND,\ either\ express\ or\ implied.}}
\DoxyCodeLine{00012\ \textcolor{comment}{//\ See\ the\ License\ for\ the\ specific\ language\ governing\ permissions\ and}}
\DoxyCodeLine{00013\ \textcolor{comment}{//\ limitations\ under\ the\ License.}}
\DoxyCodeLine{00014\ }
\DoxyCodeLine{00015\ \textcolor{comment}{//\ A\ btree\ implementation\ of\ the\ STL\ set\ and\ map\ interfaces.\ A\ btree\ is\ smaller}}
\DoxyCodeLine{00016\ \textcolor{comment}{//\ and\ generally\ also\ faster\ than\ STL\ set/map\ (refer\ to\ the\ benchmarks\ below).}}
\DoxyCodeLine{00017\ \textcolor{comment}{//\ The\ red-\/black\ tree\ implementation\ of\ STL\ set/map\ has\ an\ overhead\ of\ 3}}
\DoxyCodeLine{00018\ \textcolor{comment}{//\ pointers\ (left,\ right\ and\ parent)\ plus\ the\ node\ color\ information\ for\ each}}
\DoxyCodeLine{00019\ \textcolor{comment}{//\ stored\ value.\ So\ a\ set<int32\_t>\ consumes\ 40\ bytes\ for\ each\ value\ stored\ in}}
\DoxyCodeLine{00020\ \textcolor{comment}{//\ 64-\/bit\ mode.\ This\ btree\ implementation\ stores\ multiple\ values\ on\ fixed}}
\DoxyCodeLine{00021\ \textcolor{comment}{//\ size\ nodes\ (usually\ 256\ bytes)\ and\ doesn't\ store\ child\ pointers\ for\ leaf}}
\DoxyCodeLine{00022\ \textcolor{comment}{//\ nodes.\ The\ result\ is\ that\ a\ btree\_set<int32\_t>\ may\ use\ much\ less\ memory\ per}}
\DoxyCodeLine{00023\ \textcolor{comment}{//\ stored\ value.\ For\ the\ random\ insertion\ benchmark\ in\ btree\_bench.cc,\ a}}
\DoxyCodeLine{00024\ \textcolor{comment}{//\ btree\_set<int32\_t>\ with\ node-\/size\ of\ 256\ uses\ 5.1\ bytes\ per\ stored\ value.}}
\DoxyCodeLine{00025\ \textcolor{comment}{//}}
\DoxyCodeLine{00026\ \textcolor{comment}{//\ The\ packing\ of\ multiple\ values\ on\ to\ each\ node\ of\ a\ btree\ has\ another\ effect}}
\DoxyCodeLine{00027\ \textcolor{comment}{//\ besides\ better\ space\ utilization:\ better\ cache\ locality\ due\ to\ fewer\ cache}}
\DoxyCodeLine{00028\ \textcolor{comment}{//\ lines\ being\ accessed.\ Better\ cache\ locality\ translates\ into\ faster}}
\DoxyCodeLine{00029\ \textcolor{comment}{//\ operations.}}
\DoxyCodeLine{00030\ \textcolor{comment}{//}}
\DoxyCodeLine{00031\ \textcolor{comment}{//\ CAVEATS}}
\DoxyCodeLine{00032\ \textcolor{comment}{//}}
\DoxyCodeLine{00033\ \textcolor{comment}{//\ Insertions\ and\ deletions\ on\ a\ btree\ can\ cause\ splitting,\ merging\ or}}
\DoxyCodeLine{00034\ \textcolor{comment}{//\ rebalancing\ of\ btree\ nodes.\ And\ even\ without\ these\ operations,\ insertions}}
\DoxyCodeLine{00035\ \textcolor{comment}{//\ and\ deletions\ on\ a\ btree\ will\ move\ values\ around\ within\ a\ node.\ In\ both}}
\DoxyCodeLine{00036\ \textcolor{comment}{//\ cases,\ the\ result\ is\ that\ insertions\ and\ deletions\ can\ invalidate\ iterators}}
\DoxyCodeLine{00037\ \textcolor{comment}{//\ pointing\ to\ values\ other\ than\ the\ one\ being\ inserted/deleted.\ Therefore,\ this}}
\DoxyCodeLine{00038\ \textcolor{comment}{//\ container\ does\ not\ provide\ pointer\ stability.\ This\ is\ notably\ different\ from}}
\DoxyCodeLine{00039\ \textcolor{comment}{//\ STL\ set/map\ which\ takes\ care\ to\ not\ invalidate\ iterators\ on\ insert/erase}}
\DoxyCodeLine{00040\ \textcolor{comment}{//\ except,\ of\ course,\ for\ iterators\ pointing\ to\ the\ value\ being\ erased.\ \ A}}
\DoxyCodeLine{00041\ \textcolor{comment}{//\ partial\ workaround\ when\ erasing\ is\ available:\ erase()\ returns\ an\ iterator}}
\DoxyCodeLine{00042\ \textcolor{comment}{//\ pointing\ to\ the\ item\ just\ after\ the\ one\ that\ was\ erased\ (or\ end()\ if\ none}}
\DoxyCodeLine{00043\ \textcolor{comment}{//\ exists).}}
\DoxyCodeLine{00044\ }
\DoxyCodeLine{00045\ \textcolor{preprocessor}{\#ifndef\ ABSL\_CONTAINER\_INTERNAL\_BTREE\_H\_}}
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\#define\ ABSL\_CONTAINER\_INTERNAL\_BTREE\_H\_}}
\DoxyCodeLine{00047\ }
\DoxyCodeLine{00048\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00049\ \textcolor{preprocessor}{\#include\ <cassert>}}
\DoxyCodeLine{00050\ \textcolor{preprocessor}{\#include\ <cstddef>}}
\DoxyCodeLine{00051\ \textcolor{preprocessor}{\#include\ <cstdint>}}
\DoxyCodeLine{00052\ \textcolor{preprocessor}{\#include\ <cstring>}}
\DoxyCodeLine{00053\ \textcolor{preprocessor}{\#include\ <functional>}}
\DoxyCodeLine{00054\ \textcolor{preprocessor}{\#include\ <iterator>}}
\DoxyCodeLine{00055\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00056\ \textcolor{preprocessor}{\#include\ <string>}}
\DoxyCodeLine{00057\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00058\ \textcolor{preprocessor}{\#include\ <utility>}}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \textcolor{preprocessor}{\#include\ "{}absl/base/config.h"{}}}
\DoxyCodeLine{00061\ \textcolor{preprocessor}{\#include\ "{}absl/base/internal/raw\_logging.h"{}}}
\DoxyCodeLine{00062\ \textcolor{preprocessor}{\#include\ "{}absl/base/macros.h"{}}}
\DoxyCodeLine{00063\ \textcolor{preprocessor}{\#include\ "{}absl/container/internal/common.h"{}}}
\DoxyCodeLine{00064\ \textcolor{preprocessor}{\#include\ "{}absl/container/internal/common\_policy\_traits.h"{}}}
\DoxyCodeLine{00065\ \textcolor{preprocessor}{\#include\ "{}absl/container/internal/compressed\_tuple.h"{}}}
\DoxyCodeLine{00066\ \textcolor{preprocessor}{\#include\ "{}absl/container/internal/container\_memory.h"{}}}
\DoxyCodeLine{00067\ \textcolor{preprocessor}{\#include\ "{}absl/container/internal/layout.h"{}}}
\DoxyCodeLine{00068\ \textcolor{preprocessor}{\#include\ "{}absl/memory/memory.h"{}}}
\DoxyCodeLine{00069\ \textcolor{preprocessor}{\#include\ "{}absl/meta/type\_traits.h"{}}}
\DoxyCodeLine{00070\ \textcolor{preprocessor}{\#include\ "{}absl/strings/cord.h"{}}}
\DoxyCodeLine{00071\ \textcolor{preprocessor}{\#include\ "{}absl/strings/string\_view.h"{}}}
\DoxyCodeLine{00072\ \textcolor{preprocessor}{\#include\ "{}absl/types/compare.h"{}}}
\DoxyCodeLine{00073\ }
\DoxyCodeLine{00074\ \textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceabsl}{absl}}\ \{}
\DoxyCodeLine{00075\ \mbox{\hyperlink{abseil-cpp_2absl_2base_2config_8h_a1426209ed359f780778edc8975b23f07}{ABSL\_NAMESPACE\_BEGIN}}}
\DoxyCodeLine{00076\ \textcolor{keyword}{namespace\ }container\_internal\ \{}
\DoxyCodeLine{00077\ }
\DoxyCodeLine{00078\ \textcolor{preprocessor}{\#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{00079\ \textcolor{preprocessor}{\#error\ ABSL\_BTREE\_ENABLE\_GENERATIONS\ cannot\ be\ directly\ set}}
\DoxyCodeLine{00080\ \textcolor{preprocessor}{\#elif\ (defined(ABSL\_HAVE\_ADDRESS\_SANITIZER)\ ||\ \ \ \(\backslash\)}}
\DoxyCodeLine{00081\ \textcolor{preprocessor}{\ \ \ \ \ \ \ defined(ABSL\_HAVE\_HWADDRESS\_SANITIZER)\ ||\ \(\backslash\)}}
\DoxyCodeLine{00082\ \textcolor{preprocessor}{\ \ \ \ \ \ \ defined(ABSL\_HAVE\_MEMORY\_SANITIZER))\ \&\&\ \ \ \(\backslash\)}}
\DoxyCodeLine{00083\ \textcolor{preprocessor}{\ \ \ \ !defined(NDEBUG\_SANITIZER)\ \ }\textcolor{comment}{//\ If\ defined,\ performance\ is\ important.}}
\DoxyCodeLine{00084\ \textcolor{comment}{//\ When\ compiled\ in\ sanitizer\ mode,\ we\ add\ generation\ integers\ to\ the\ nodes\ and}}
\DoxyCodeLine{00085\ \textcolor{comment}{//\ iterators.\ When\ iterators\ are\ used,\ we\ validate\ that\ the\ container\ has\ not}}
\DoxyCodeLine{00086\ \textcolor{comment}{//\ been\ mutated\ since\ the\ iterator\ was\ constructed.}}
\DoxyCodeLine{00087\ \textcolor{preprocessor}{\#define\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{00088\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00089\ }
\DoxyCodeLine{00090\ \textcolor{preprocessor}{\#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{00091\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_ad6510b4d175ad3f08dc41b1bcd47f6e9}{BtreeGenerationsEnabled}}()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};\ \}}
\DoxyCodeLine{00092\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00093\ \textcolor{keyword}{constexpr}\ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_ad6510b4d175ad3f08dc41b1bcd47f6e9}{BtreeGenerationsEnabled}}()\ \{\ \textcolor{keywordflow}{return}\ \textcolor{keyword}{false};\ \}}
\DoxyCodeLine{00094\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00095\ }
\DoxyCodeLine{00096\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Compare,\ \textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U>}
\DoxyCodeLine{00097\ \textcolor{keyword}{using\ }\mbox{\hyperlink{namespaceabsl_1_1container__internal_ab358311ab76d018380c49e05d7d954de}{compare\_result\_t}}\ =\ \mbox{\hyperlink{namespaceabsl_ae68357235a46d10a2fa83f9eaeea080c}{absl::result\_of\_t}}<\textcolor{keyword}{const}\ Compare(\textcolor{keyword}{const}\ T\ \&,\ \textcolor{keyword}{const}\ U\ \&)>;}
\DoxyCodeLine{00098\ }
\DoxyCodeLine{00099\ \textcolor{comment}{//\ A\ helper\ class\ that\ indicates\ if\ the\ Compare\ parameter\ is\ a\ key-\/compare-\/to}}
\DoxyCodeLine{00100\ \textcolor{comment}{//\ comparator.}}
\DoxyCodeLine{00101\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Compare,\ \textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00102\ \textcolor{keyword}{using\ }\mbox{\hyperlink{namespaceabsl_1_1container__internal_a62b4dab47211e8ca57b72079f2668409}{btree\_is\_key\_compare\_to}}\ =}
\DoxyCodeLine{00103\ \ \ \ \ std::is\_convertible<compare\_result\_t<Compare,\ T,\ T>,\ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}>;}
\DoxyCodeLine{00104\ }
\DoxyCodeLine{00105\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess}{StringBtreeDefaultLess}}\ \{}
\DoxyCodeLine{00106\ \ \ \textcolor{keyword}{using\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a1c151406f0eb05ebf01ceedd873c1f5c}{is\_transparent}}\ =\ void;}
\DoxyCodeLine{00107\ }
\DoxyCodeLine{00108\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a58a4e176dda17f66cce24e3c30a3fb67}{StringBtreeDefaultLess}}()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00109\ }
\DoxyCodeLine{00110\ \ \ \textcolor{comment}{//\ Compatibility\ constructor.}}
\DoxyCodeLine{00111\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a5261735ce35ae50de8034075088cf407}{StringBtreeDefaultLess}}(std::less<std::string>)\ \{\}\ \ \ \ \ \ \ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00112\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a34904a408b028a178c2469850f12b5c4}{StringBtreeDefaultLess}}(std::less<absl::string\_view>)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00113\ }
\DoxyCodeLine{00114\ \ \ \textcolor{comment}{//\ Allow\ converting\ to\ std::less\ for\ use\ in\ key\_comp()/value\_comp().}}
\DoxyCodeLine{00115\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::less<std::string>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00116\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::less<absl::string\_view>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00117\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::less<absl::Cord>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00118\ }
\DoxyCodeLine{00119\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a4ec55d10d838f23ca050618aeb4c4541}{operator()}}(\mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ lhs,}
\DoxyCodeLine{00120\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00121\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(lhs.\mbox{\hyperlink{classabsl_1_1string__view_afdca90e80a4ea2e2d63133074fe4229e}{compare}}(rhs));}
\DoxyCodeLine{00122\ \ \ \}}
\DoxyCodeLine{00123\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a8bb6af879940fa761fa34b6665cd762c}{StringBtreeDefaultLess}}(std::less<absl::Cord>)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00124\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a2f39528be4d68fc163e8133dc6bf0662}{operator()}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&lhs,}
\DoxyCodeLine{00125\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00126\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(lhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(rhs));}
\DoxyCodeLine{00127\ \ \ \}}
\DoxyCodeLine{00128\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a05012294e4d2041151b2634197cdbb3d}{operator()}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&lhs,}
\DoxyCodeLine{00129\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00130\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(lhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(rhs));}
\DoxyCodeLine{00131\ \ \ \}}
\DoxyCodeLine{00132\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultLess_a825ee59e2e36b12ca5333ecf997f77ae}{operator()}}(\mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ lhs,}
\DoxyCodeLine{00133\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00134\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(-\/rhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(lhs));}
\DoxyCodeLine{00135\ \ \ \}}
\DoxyCodeLine{00136\ \};}
\DoxyCodeLine{00137\ }
\DoxyCodeLine{00138\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater}{StringBtreeDefaultGreater}}\ \{}
\DoxyCodeLine{00139\ \ \ \textcolor{keyword}{using\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_a457e43b9b0504572f259311351e80487}{is\_transparent}}\ =\ void;}
\DoxyCodeLine{00140\ }
\DoxyCodeLine{00141\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_a203e48d49598f1c6b7197c66fbbba422}{StringBtreeDefaultGreater}}()\ =\ \textcolor{keywordflow}{default};}
\DoxyCodeLine{00142\ }
\DoxyCodeLine{00143\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_a282010671103d613245764424d23f9c0}{StringBtreeDefaultGreater}}(std::greater<std::string>)\ \{\}\ \ \ \ \ \ \ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00144\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_a084fd6e71b16f03048928525847751b7}{StringBtreeDefaultGreater}}(std::greater<absl::string\_view>)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00145\ }
\DoxyCodeLine{00146\ \ \ \textcolor{comment}{//\ Allow\ converting\ to\ std::greater\ for\ use\ in\ key\_comp()/value\_comp().}}
\DoxyCodeLine{00147\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::greater<std::string>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00148\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::greater<absl::string\_view>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00149\ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ std::greater<absl::Cord>()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \{\};\ \}}
\DoxyCodeLine{00150\ }
\DoxyCodeLine{00151\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_abbb9e493da91367e2f43c8d14edcb47b}{operator()}}(\mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ lhs,}
\DoxyCodeLine{00152\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00153\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(rhs.\mbox{\hyperlink{classabsl_1_1string__view_afdca90e80a4ea2e2d63133074fe4229e}{compare}}(lhs));}
\DoxyCodeLine{00154\ \ \ \}}
\DoxyCodeLine{00155\ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_aba96a4cedf9b21e7322f489eb64cd9ba}{StringBtreeDefaultGreater}}(std::greater<absl::Cord>)\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00156\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_a53aaa856bc754e43594e5f21d2ed7525}{operator()}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&lhs,}
\DoxyCodeLine{00157\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00158\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(rhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(lhs));}
\DoxyCodeLine{00159\ \ \ \}}
\DoxyCodeLine{00160\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_ab433e38ac862e40a7670a74a7de41b0b}{operator()}}(\textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&lhs,}
\DoxyCodeLine{00161\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00162\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(-\/lhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(rhs));}
\DoxyCodeLine{00163\ \ \ \}}
\DoxyCodeLine{00164\ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1StringBtreeDefaultGreater_ab3a056b507c8e44f0e02fd85a1d26d9f}{operator()}}(\mbox{\hyperlink{classabsl_1_1string__view}{absl::string\_view}}\ lhs,}
\DoxyCodeLine{00165\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1Cord}{absl::Cord}}\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00166\ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl_1_1compare__internal_aee1e4e00fec9f4fe853f74c0fa251b41}{compare\_internal::compare\_result\_as\_ordering}}(rhs.\mbox{\hyperlink{classabsl_1_1Cord_a51c340abb52e9c9aff0a434752fc085c}{Compare}}(lhs));}
\DoxyCodeLine{00167\ \ \ \}}
\DoxyCodeLine{00168\ \};}
\DoxyCodeLine{00169\ }
\DoxyCodeLine{00170\ \textcolor{comment}{//\ See\ below\ comments\ for\ checked\_compare.}}
\DoxyCodeLine{00171\ template\ <typename\ Compare,\ bool\ is\_class\ =\ std::is\_class<Compare>::value>}
\DoxyCodeLine{00172\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base}{checked\_compare\_base}}\ :\ Compare\ \{}
\DoxyCodeLine{00173\ \ \ \textcolor{keyword}{using\ }Compare::Compare;}
\DoxyCodeLine{00174\ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a9eabdf8e1cf5b681c332a5b0c86857a4}{checked\_compare\_base}}(Compare\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}})\ :\ Compare(\mbox{\hyperlink{namespacestd}{std}}::move(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}}))\ \{\}}
\DoxyCodeLine{00175\ \ \ \textcolor{keyword}{const}\ Compare\ \&\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ *\textcolor{keyword}{this};\ \}}
\DoxyCodeLine{00176\ \};}
\DoxyCodeLine{00177\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Compare>}
\DoxyCodeLine{00178\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base}{checked\_compare\_base}}<Compare,\ false>\ \{}
\DoxyCodeLine{00179\ \ \ \textcolor{keyword}{explicit}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_3_01Compare_00_01false_01_4_a15b8cb22c39bc02c124f3fa7ff746690}{checked\_compare\_base}}(Compare\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}})\ :\ compare(\mbox{\hyperlink{namespacestd}{std}}::move(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}}))\ \{\}}
\DoxyCodeLine{00180\ \ \ \textcolor{keyword}{const}\ Compare\ \&\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_3_01Compare_00_01false_01_4_a434cf1efa3ca89e99d4f57c210ee1b68}{comp}}()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ compare;\ \}}
\DoxyCodeLine{00181\ \ \ Compare\ compare;}
\DoxyCodeLine{00182\ \};}
\DoxyCodeLine{00183\ }
\DoxyCodeLine{00184\ \textcolor{comment}{//\ A\ mechanism\ for\ opting\ out\ of\ checked\_compare\ for\ use\ only\ in\ btree\_test.cc.}}
\DoxyCodeLine{00185\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1BtreeTestOnlyCheckedCompareOptOutBase}{BtreeTestOnlyCheckedCompareOptOutBase}}\ \{\};}
\DoxyCodeLine{00186\ }
\DoxyCodeLine{00187\ \textcolor{comment}{//\ A\ helper\ class\ to\ adapt\ the\ specified\ comparator\ for\ two\ use\ cases:}}
\DoxyCodeLine{00188\ \textcolor{comment}{//\ (1)\ When\ using\ common\ Abseil\ string\ types\ with\ common\ comparison\ functors,}}
\DoxyCodeLine{00189\ \textcolor{comment}{//\ convert\ a\ boolean\ comparison\ into\ a\ three-\/way\ comparison\ that\ returns\ an}}
\DoxyCodeLine{00190\ \textcolor{comment}{//\ \`{}absl::weak\_ordering`.\ This\ helper\ class\ is\ specialized\ for}}
\DoxyCodeLine{00191\ \textcolor{comment}{//\ less<std::string>,\ greater<std::string>,\ less<string\_view>,}}
\DoxyCodeLine{00192\ \textcolor{comment}{//\ greater<string\_view>,\ less<absl::Cord>,\ and\ greater<absl::Cord>.}}
\DoxyCodeLine{00193\ \textcolor{comment}{//\ (2)\ Adapt\ the\ comparator\ to\ diagnose\ cases\ of\ non-\/strict-\/weak-\/ordering\ (see}}
\DoxyCodeLine{00194\ \textcolor{comment}{//\ https://en.cppreference.com/w/cpp/named\_req/Compare)\ in\ debug\ mode.\ Whenever}}
\DoxyCodeLine{00195\ \textcolor{comment}{//\ a\ comparison\ is\ made,\ we\ will\ make\ assertions\ to\ verify\ that\ the\ comparator}}
\DoxyCodeLine{00196\ \textcolor{comment}{//\ is\ valid.}}
\DoxyCodeLine{00197\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ Compare,\ \textcolor{keyword}{typename}\ Key>}
\DoxyCodeLine{00198\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter}{key\_compare\_adapter}}\ \{}
\DoxyCodeLine{00199\ \ \ \textcolor{comment}{//\ Inherit\ from\ checked\_compare\_base\ to\ support\ function\ pointers\ and\ also}}
\DoxyCodeLine{00200\ \ \ \textcolor{comment}{//\ keep\ empty-\/base-\/optimization\ (EBO)\ support\ for\ classes.}}
\DoxyCodeLine{00201\ \ \ \textcolor{comment}{//\ Note:\ we\ can't\ use\ CompressedTuple\ here\ because\ that\ would\ interfere}}
\DoxyCodeLine{00202\ \ \ \textcolor{comment}{//\ with\ the\ EBO\ for\ \`{}btree::rightmost\_`.\ \`{}btree::rightmost\_`\ is\ itself\ a}}
\DoxyCodeLine{00203\ \ \ \textcolor{comment}{//\ CompressedTuple\ and\ nested\ \`{}CompressedTuple`s\ don't\ support\ EBO.}}
\DoxyCodeLine{00204\ \ \ \textcolor{comment}{//\ TODO(b/214288561):\ use\ CompressedTuple\ instead\ once\ it\ supports\ EBO\ for}}
\DoxyCodeLine{00205\ \ \ \textcolor{comment}{//\ nested\ \`{}CompressedTuple`s.}}
\DoxyCodeLine{00206\ \ \ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare}{checked\_compare}}\ :\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base}{checked\_compare\_base}}<Compare>\ \{}
\DoxyCodeLine{00207\ \ \ \ \textcolor{keyword}{private}:}
\DoxyCodeLine{00208\ \ \ \ \ \textcolor{keyword}{using\ }Base\ =\ \textcolor{keyword}{typename}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a9eabdf8e1cf5b681c332a5b0c86857a4}{checked\_compare::checked\_compare\_base}};}
\DoxyCodeLine{00209\ \ \ \ \ \textcolor{keyword}{using\ }Base::comp;}
\DoxyCodeLine{00210\ }
\DoxyCodeLine{00211\ \ \ \ \ \textcolor{comment}{//\ If\ possible,\ returns\ whether\ \`{}t`\ is\ equivalent\ to\ itself.\ We\ can\ only\ do}}
\DoxyCodeLine{00212\ \ \ \ \ \textcolor{comment}{//\ this\ for\ \`{}Key`s\ because\ we\ can't\ be\ sure\ that\ it's\ safe\ to\ call}}
\DoxyCodeLine{00213\ \ \ \ \ \textcolor{comment}{//\ \`{}comp()(k,\ k)`\ otherwise.\ Even\ if\ SFINAE\ allows\ it,\ there\ could\ be\ a}}
\DoxyCodeLine{00214\ \ \ \ \ \textcolor{comment}{//\ compilation\ failure\ inside\ the\ implementation\ of\ the\ comparison\ operator.}}
\DoxyCodeLine{00215\ \ \ \ \ \textcolor{keywordtype}{bool}\ is\_self\_equivalent(\textcolor{keyword}{const}\ Key\ \&k)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00216\ \ \ \ \ \ \ \textcolor{comment}{//\ Note:\ this\ works\ for\ both\ boolean\ and\ three-\/way\ comparators.}}
\DoxyCodeLine{00217\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()(k,\ k)\ ==\ 0;}
\DoxyCodeLine{00218\ \ \ \ \ \}}
\DoxyCodeLine{00219\ \ \ \ \ \textcolor{comment}{//\ If\ we\ can't\ compare\ \`{}t`\ with\ itself,\ returns\ true\ unconditionally.}}
\DoxyCodeLine{00220\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T>}
\DoxyCodeLine{00221\ \ \ \ \ \textcolor{keywordtype}{bool}\ is\_self\_equivalent(\textcolor{keyword}{const}\ T\ \&)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00222\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{true};}
\DoxyCodeLine{00223\ \ \ \ \ \}}
\DoxyCodeLine{00224\ }
\DoxyCodeLine{00225\ \ \ \ \textcolor{keyword}{public}:}
\DoxyCodeLine{00226\ \ \ \ \ \textcolor{keyword}{using\ }Base::Base;}
\DoxyCodeLine{00227\ \ \ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_a856a8a5cd32c909425e9979e08888137}{checked\_compare}}(Compare\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}})\ :\ Base(\mbox{\hyperlink{namespacestd}{std}}::move(\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}))\ \{\}\ \ \textcolor{comment}{//\ NOLINT}}
\DoxyCodeLine{00228\ }
\DoxyCodeLine{00229\ \ \ \ \ \textcolor{comment}{//\ Allow\ converting\ to\ Compare\ for\ use\ in\ key\_comp()/value\_comp().}}
\DoxyCodeLine{00230\ \ \ \ \ \textcolor{keyword}{explicit}\ \textcolor{keyword}{operator}\ Compare()\textcolor{keyword}{\ const\ }\{\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}();\ \}}
\DoxyCodeLine{00231\ }
\DoxyCodeLine{00232\ \ \ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U,}
\DoxyCodeLine{00233\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceabsl_a059ea7c8c3122cd36d4e270733757ff9}{absl::enable\_if\_t}}<}
\DoxyCodeLine{00234\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<bool,\ compare\_result\_t<Compare,\ T,\ U>>\mbox{\hyperlink{abseil-cpp_2absl_2container_2flat__hash__map__test_8cc_a54c2bae0f8aeed048a397b0618037252}{::value}},}
\DoxyCodeLine{00235\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}>\ =\ 0>}
\DoxyCodeLine{00236\ \ \ \ \ \textcolor{keywordtype}{bool}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_a4866980272aeb23431d874ef76e59318}{operator()}}(\textcolor{keyword}{const}\ T\ \&lhs,\ \textcolor{keyword}{const}\ U\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00237\ \ \ \ \ \ \ \textcolor{comment}{//\ NOTE:\ if\ any\ of\ these\ assertions\ fail,\ then\ the\ comparator\ does\ not}}
\DoxyCodeLine{00238\ \ \ \ \ \ \ \textcolor{comment}{//\ establish\ a\ strict-\/weak-\/ordering\ (see}}
\DoxyCodeLine{00239\ \ \ \ \ \ \ \textcolor{comment}{//\ https://en.cppreference.com/w/cpp/named\_req/Compare).}}
\DoxyCodeLine{00240\ \ \ \ \ \ \ assert(is\_self\_equivalent(lhs));}
\DoxyCodeLine{00241\ \ \ \ \ \ \ assert(is\_self\_equivalent(rhs));}
\DoxyCodeLine{00242\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{bool}\ lhs\_comp\_rhs\ =\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()(lhs,\ rhs);}
\DoxyCodeLine{00243\ \ \ \ \ \ \ assert(!lhs\_comp\_rhs\ ||\ !\mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()(rhs,\ lhs));}
\DoxyCodeLine{00244\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ lhs\_comp\_rhs;}
\DoxyCodeLine{00245\ \ \ \ \ \}}
\DoxyCodeLine{00246\ }
\DoxyCodeLine{00247\ \ \ \ \ \textcolor{keyword}{template}\ <}
\DoxyCodeLine{00248\ \ \ \ \ \ \ \ \ \textcolor{keyword}{typename}\ T,\ \textcolor{keyword}{typename}\ U,}
\DoxyCodeLine{00249\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceabsl_a059ea7c8c3122cd36d4e270733757ff9}{absl::enable\_if\_t<std::is\_convertible<compare\_result\_t<Compare,\ T,\ U>}},}
\DoxyCodeLine{00250\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}>\mbox{\hyperlink{abseil-cpp_2absl_2container_2flat__hash__map__test_8cc_a54c2bae0f8aeed048a397b0618037252}{::value}},}
\DoxyCodeLine{00251\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordtype}{int}>\ =\ 0>}
\DoxyCodeLine{00252\ \ \ \ \ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter_1_1checked__compare_a8cc2fad7a99a268788711694c885d36c}{operator()}}(\textcolor{keyword}{const}\ T\ \&lhs,\ \textcolor{keyword}{const}\ U\ \&rhs)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00253\ \ \ \ \ \ \ \textcolor{comment}{//\ NOTE:\ if\ any\ of\ these\ assertions\ fail,\ then\ the\ comparator\ does\ not}}
\DoxyCodeLine{00254\ \ \ \ \ \ \ \textcolor{comment}{//\ establish\ a\ strict-\/weak-\/ordering\ (see}}
\DoxyCodeLine{00255\ \ \ \ \ \ \ \textcolor{comment}{//\ https://en.cppreference.com/w/cpp/named\_req/Compare).}}
\DoxyCodeLine{00256\ \ \ \ \ \ \ assert(is\_self\_equivalent(lhs));}
\DoxyCodeLine{00257\ \ \ \ \ \ \ assert(is\_self\_equivalent(rhs));}
\DoxyCodeLine{00258\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ lhs\_comp\_rhs\ =\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()(lhs,\ rhs);}
\DoxyCodeLine{00259\ \textcolor{preprocessor}{\#ifndef\ NDEBUG}}
\DoxyCodeLine{00260\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \mbox{\hyperlink{classabsl_1_1weak__ordering}{absl::weak\_ordering}}\ rhs\_comp\_lhs\ =\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}()(rhs,\ lhs);}
\DoxyCodeLine{00261\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (lhs\_comp\_rhs\ >\ 0)\ \{}
\DoxyCodeLine{00262\ \ \ \ \ \ \ \ \ assert(rhs\_comp\_lhs\ <\ 0\ \&\&\ "{}lhs\_comp\_rhs\ >\ 0\ -\/>\ rhs\_comp\_lhs\ <\ 0\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{00263\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ else\ if\ (lhs\_comp\_rhs\ ==\ 0)\ \{}}
\DoxyCodeLine{00264\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ assert(rhs\_comp\_lhs\ ==\ 0\ \&\&\ "{}}lhs\_comp\_rhs\ ==\ 0\ -\/>\ rhs\_comp\_lhs\ ==\ 0\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{00265\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{00266\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ assert(rhs\_comp\_lhs\ >\ 0\ \&\&\ "{}}lhs\_comp\_rhs\ <\ 0\ -\/>\ rhs\_comp\_lhs\ >\ 0\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{00267\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00268\ \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{00269\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ lhs\_comp\_rhs;}}
\DoxyCodeLine{00270\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00271\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{00272\ \textcolor{stringliteral}{\ \ using\ type\ =\ absl::conditional\_t<}}
\DoxyCodeLine{00273\ \textcolor{stringliteral}{\ \ \ \ \ \ std::is\_base\_of<BtreeTestOnlyCheckedCompareOptOutBase,\ Compare>::value,}}
\DoxyCodeLine{00274\ \textcolor{stringliteral}{\ \ \ \ \ \ Compare,\ checked\_compare>;}}
\DoxyCodeLine{00275\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00276\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00277\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00278\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::less<std::string>,\ std::string>\ \{}}
\DoxyCodeLine{00279\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultLess;}}
\DoxyCodeLine{00280\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00281\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00282\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00283\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::greater<std::string>,\ std::string>\ \{}}
\DoxyCodeLine{00284\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultGreater;}}
\DoxyCodeLine{00285\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00286\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00287\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00288\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::less<absl::string\_view>,\ absl::string\_view>\ \{}}
\DoxyCodeLine{00289\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultLess;}}
\DoxyCodeLine{00290\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00291\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00292\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00293\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::greater<absl::string\_view>,\ absl::string\_view>\ \{}}
\DoxyCodeLine{00294\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultGreater;}}
\DoxyCodeLine{00295\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00296\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00297\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00298\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::less<absl::Cord>,\ absl::Cord>\ \{}}
\DoxyCodeLine{00299\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultLess;}}
\DoxyCodeLine{00300\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00301\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00302\ \textcolor{stringliteral}{template\ <>}}
\DoxyCodeLine{00303\ \textcolor{stringliteral}{struct\ key\_compare\_adapter<std::greater<absl::Cord>,\ absl::Cord>\ \{}}
\DoxyCodeLine{00304\ \textcolor{stringliteral}{\ \ using\ type\ =\ StringBtreeDefaultGreater;}}
\DoxyCodeLine{00305\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00306\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00307\ \textcolor{stringliteral}{//\ Detects\ an\ 'absl\_btree\_prefer\_linear\_node\_search'\ member.\ This\ is}}
\DoxyCodeLine{00308\ \textcolor{stringliteral}{//\ a\ protocol\ used\ as\ an\ opt-\/in\ or\ opt-\/out\ of\ linear\ search.}}
\DoxyCodeLine{00309\ \textcolor{stringliteral}{//}}
\DoxyCodeLine{00310\ \textcolor{stringliteral}{//\ \ For\ example,\ this\ would\ be\ useful\ for\ key\ types\ that\ wrap\ an\ integer}}
\DoxyCodeLine{00311\ \textcolor{stringliteral}{//\ \ and\ define\ their\ own\ cheap\ operator<().\ For\ example:}}
\DoxyCodeLine{00312\ \textcolor{stringliteral}{//}}
\DoxyCodeLine{00313\ \textcolor{stringliteral}{//\ \ \ class\ K\ \{}}
\DoxyCodeLine{00314\ \textcolor{stringliteral}{//\ \ \ \ public:}}
\DoxyCodeLine{00315\ \textcolor{stringliteral}{//\ \ \ \ \ using\ absl\_btree\_prefer\_linear\_node\_search\ =\ std::true\_type;}}
\DoxyCodeLine{00316\ \textcolor{stringliteral}{//\ \ \ \ \ ...}}
\DoxyCodeLine{00317\ \textcolor{stringliteral}{//\ \ \ \ private:}}
\DoxyCodeLine{00318\ \textcolor{stringliteral}{//\ \ \ \ \ friend\ bool\ operator<(K\ a,\ K\ b)\ \{\ return\ a.k\_\ <\ b.k\_;\ \}}}
\DoxyCodeLine{00319\ \textcolor{stringliteral}{//\ \ \ \ \ int\ k\_;}}
\DoxyCodeLine{00320\ \textcolor{stringliteral}{//\ \ \ \};}}
\DoxyCodeLine{00321\ \textcolor{stringliteral}{//}}
\DoxyCodeLine{00322\ \textcolor{stringliteral}{//\ \ \ btree\_map<K,\ V>\ m;\ \ //\ Uses\ linear\ search}}
\DoxyCodeLine{00323\ \textcolor{stringliteral}{//}}
\DoxyCodeLine{00324\ \textcolor{stringliteral}{//\ If\ T\ has\ the\ preference\ tag,\ then\ it\ has\ a\ preference.}}
\DoxyCodeLine{00325\ \textcolor{stringliteral}{//\ Btree\ will\ use\ the\ tag's\ truth\ value.}}
\DoxyCodeLine{00326\ \textcolor{stringliteral}{template\ <typename\ T,\ typename\ =\ void>}}
\DoxyCodeLine{00327\ \textcolor{stringliteral}{struct\ has\_linear\_node\_search\_preference\ :\ std::false\_type\ \{\};}}
\DoxyCodeLine{00328\ \textcolor{stringliteral}{template\ <typename\ T,\ typename\ =\ void>}}
\DoxyCodeLine{00329\ \textcolor{stringliteral}{struct\ prefers\_linear\_node\_search\ :\ std::false\_type\ \{\};}}
\DoxyCodeLine{00330\ \textcolor{stringliteral}{template\ <typename\ T>}}
\DoxyCodeLine{00331\ \textcolor{stringliteral}{struct\ has\_linear\_node\_search\_preference<}}
\DoxyCodeLine{00332\ \textcolor{stringliteral}{\ \ \ \ T,\ absl::void\_t<typename\ T::absl\_btree\_prefer\_linear\_node\_search>>}}
\DoxyCodeLine{00333\ \textcolor{stringliteral}{\ \ \ \ :\ std::true\_type\ \{\};}}
\DoxyCodeLine{00334\ \textcolor{stringliteral}{template\ <typename\ T>}}
\DoxyCodeLine{00335\ \textcolor{stringliteral}{struct\ prefers\_linear\_node\_search<}}
\DoxyCodeLine{00336\ \textcolor{stringliteral}{\ \ \ \ T,\ absl::void\_t<typename\ T::absl\_btree\_prefer\_linear\_node\_search>>}}
\DoxyCodeLine{00337\ \textcolor{stringliteral}{\ \ \ \ :\ T::absl\_btree\_prefer\_linear\_node\_search\ \{\};}}
\DoxyCodeLine{00338\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00339\ \textcolor{stringliteral}{template\ <typename\ Compare,\ typename\ Key>}}
\DoxyCodeLine{00340\ \textcolor{stringliteral}{constexpr\ bool\ compare\_has\_valid\_result\_type()\ \{}}
\DoxyCodeLine{00341\ \textcolor{stringliteral}{\ \ using\ compare\_result\_type\ =\ compare\_result\_t<Compare,\ Key,\ Key>;}}
\DoxyCodeLine{00342\ \textcolor{stringliteral}{\ \ return\ std::is\_same<compare\_result\_type,\ bool>::value\ ||}}
\DoxyCodeLine{00343\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ std::is\_convertible<compare\_result\_type,\ absl::weak\_ordering>::value;}}
\DoxyCodeLine{00344\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{00345\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00346\ \textcolor{stringliteral}{template\ <typename\ original\_key\_compare,\ typename\ value\_type>}}
\DoxyCodeLine{00347\ \textcolor{stringliteral}{class\ map\_value\_compare\ \{}}
\DoxyCodeLine{00348\ \textcolor{stringliteral}{\ \ template\ <typename\ Params>}}
\DoxyCodeLine{00349\ \textcolor{stringliteral}{\ \ friend\ class\ btree;}}
\DoxyCodeLine{00350\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00351\ \textcolor{stringliteral}{\ \ //\ Note:\ this\ \`{}protected`\ is\ part\ of\ the\ API\ of\ std::map::value\_compare.\ See}}
\DoxyCodeLine{00352\ \textcolor{stringliteral}{\ \ //\ https://en.cppreference.com/w/cpp/container/map/value\_compare.}}
\DoxyCodeLine{00353\ \textcolor{stringliteral}{\ protected:}}
\DoxyCodeLine{00354\ \textcolor{stringliteral}{\ \ explicit\ map\_value\_compare(original\_key\_compare\ c)\ :\ comp(std::move(c))\ \{\}}}
\DoxyCodeLine{00355\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00356\ \textcolor{stringliteral}{\ \ original\_key\_compare\ comp;\ \ //\ NOLINT}}
\DoxyCodeLine{00357\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00358\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{00359\ \textcolor{stringliteral}{\ \ auto\ operator()(const\ value\_type\ \&lhs,\ const\ value\_type\ \&rhs)\ const}}
\DoxyCodeLine{00360\ \textcolor{stringliteral}{\ \ \ \ \ \ -\/>\ decltype(comp(lhs.first,\ rhs.first))\ \{}}
\DoxyCodeLine{00361\ \textcolor{stringliteral}{\ \ \ \ return\ comp(lhs.first,\ rhs.first);}}
\DoxyCodeLine{00362\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00363\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00364\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00365\ \textcolor{stringliteral}{template\ <typename\ Key,\ typename\ Compare,\ typename\ Alloc,\ int\ TargetNodeSize,}}
\DoxyCodeLine{00366\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ bool\ IsMulti,\ bool\ IsMap,\ typename\ SlotPolicy>}}
\DoxyCodeLine{00367\ \textcolor{stringliteral}{struct\ common\_params\ :\ common\_policy\_traits<SlotPolicy>\ \{}}
\DoxyCodeLine{00368\ \textcolor{stringliteral}{\ \ using\ original\_key\_compare\ =\ Compare;}}
\DoxyCodeLine{00369\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00370\ \textcolor{stringliteral}{\ \ //\ If\ Compare\ is\ a\ common\ comparator\ for\ a\ string-\/like\ type,\ then\ we\ adapt\ it}}
\DoxyCodeLine{00371\ \textcolor{stringliteral}{\ \ //\ to\ use\ heterogeneous\ lookup\ and\ to\ be\ a\ key-\/compare-\/to\ comparator.}}
\DoxyCodeLine{00372\ \textcolor{stringliteral}{\ \ //\ We\ also\ adapt\ the\ comparator\ to\ diagnose\ invalid\ comparators\ in\ debug\ mode.}}
\DoxyCodeLine{00373\ \textcolor{stringliteral}{\ \ //\ We\ disable\ this\ when\ \`{}Compare`\ is\ invalid\ in\ a\ way\ that\ will\ cause}}
\DoxyCodeLine{00374\ \textcolor{stringliteral}{\ \ //\ adaptation\ to\ fail\ (having\ invalid\ return\ type)\ so\ that\ we\ can\ give\ a}}
\DoxyCodeLine{00375\ \textcolor{stringliteral}{\ \ //\ better\ compilation\ failure\ in\ static\_assert\_validation.\ If\ we\ don't\ do}}
\DoxyCodeLine{00376\ \textcolor{stringliteral}{\ \ //\ this,\ then\ there\ will\ be\ cascading\ compilation\ failures\ that\ are\ confusing}}
\DoxyCodeLine{00377\ \textcolor{stringliteral}{\ \ //\ for\ users.}}
\DoxyCodeLine{00378\ \textcolor{stringliteral}{\ \ using\ key\_compare\ =}}
\DoxyCodeLine{00379\ \textcolor{stringliteral}{\ \ \ \ \ \ absl::conditional\_t<!compare\_has\_valid\_result\_type<Compare,\ Key>(),}}
\DoxyCodeLine{00380\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Compare,}}
\DoxyCodeLine{00381\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ typename\ key\_compare\_adapter<Compare,\ Key>::type>;}}
\DoxyCodeLine{00382\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00383\ \textcolor{stringliteral}{\ \ static\ constexpr\ bool\ kIsKeyCompareStringAdapted\ =}}
\DoxyCodeLine{00384\ \textcolor{stringliteral}{\ \ \ \ \ \ std::is\_same<key\_compare,\ StringBtreeDefaultLess>::value\ ||}}
\DoxyCodeLine{00385\ \textcolor{stringliteral}{\ \ \ \ \ \ std::is\_same<key\_compare,\ StringBtreeDefaultGreater>::value;}}
\DoxyCodeLine{00386\ \textcolor{stringliteral}{\ \ static\ constexpr\ bool\ kIsKeyCompareTransparent\ =}}
\DoxyCodeLine{00387\ \textcolor{stringliteral}{\ \ \ \ \ \ IsTransparent<original\_key\_compare>::value\ ||\ kIsKeyCompareStringAdapted;}}
\DoxyCodeLine{00388\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00389\ \textcolor{stringliteral}{\ \ //\ A\ type\ which\ indicates\ if\ we\ have\ a\ key-\/compare-\/to\ functor\ or\ a\ plain\ old}}
\DoxyCodeLine{00390\ \textcolor{stringliteral}{\ \ //\ key-\/compare\ functor.}}
\DoxyCodeLine{00391\ \textcolor{stringliteral}{\ \ using\ is\_key\_compare\_to\ =\ btree\_is\_key\_compare\_to<key\_compare,\ Key>;}}
\DoxyCodeLine{00392\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00393\ \textcolor{stringliteral}{\ \ using\ allocator\_type\ =\ Alloc;}}
\DoxyCodeLine{00394\ \textcolor{stringliteral}{\ \ using\ key\_type\ =\ Key;}}
\DoxyCodeLine{00395\ \textcolor{stringliteral}{\ \ using\ size\_type\ =\ size\_t;}}
\DoxyCodeLine{00396\ \textcolor{stringliteral}{\ \ using\ difference\_type\ =\ ptrdiff\_t;}}
\DoxyCodeLine{00397\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00398\ \textcolor{stringliteral}{\ \ using\ slot\_policy\ =\ SlotPolicy;}}
\DoxyCodeLine{00399\ \textcolor{stringliteral}{\ \ using\ slot\_type\ =\ typename\ slot\_policy::slot\_type;}}
\DoxyCodeLine{00400\ \textcolor{stringliteral}{\ \ using\ value\_type\ =\ typename\ slot\_policy::value\_type;}}
\DoxyCodeLine{00401\ \textcolor{stringliteral}{\ \ using\ init\_type\ =\ typename\ slot\_policy::mutable\_value\_type;}}
\DoxyCodeLine{00402\ \textcolor{stringliteral}{\ \ using\ pointer\ =\ value\_type\ *;}}
\DoxyCodeLine{00403\ \textcolor{stringliteral}{\ \ using\ const\_pointer\ =\ const\ value\_type\ *;}}
\DoxyCodeLine{00404\ \textcolor{stringliteral}{\ \ using\ reference\ =\ value\_type\ \&;}}
\DoxyCodeLine{00405\ \textcolor{stringliteral}{\ \ using\ const\_reference\ =\ const\ value\_type\ \&;}}
\DoxyCodeLine{00406\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00407\ \textcolor{stringliteral}{\ \ using\ value\_compare\ =}}
\DoxyCodeLine{00408\ \textcolor{stringliteral}{\ \ \ \ \ \ absl::conditional\_t<IsMap,}}
\DoxyCodeLine{00409\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ map\_value\_compare<original\_key\_compare,\ value\_type>,}}
\DoxyCodeLine{00410\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ original\_key\_compare>;}}
\DoxyCodeLine{00411\ \textcolor{stringliteral}{\ \ using\ is\_map\_container\ =\ std::integral\_constant<bool,\ IsMap>;}}
\DoxyCodeLine{00412\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00413\ \textcolor{stringliteral}{\ \ //\ For\ the\ given\ lookup\ key\ type,\ returns\ whether\ we\ can\ have\ multiple}}
\DoxyCodeLine{00414\ \textcolor{stringliteral}{\ \ //\ equivalent\ keys\ in\ the\ btree.\ If\ this\ is\ a\ multi-\/container,\ then\ we\ can.}}
\DoxyCodeLine{00415\ \textcolor{stringliteral}{\ \ //\ Otherwise,\ we\ can\ have\ multiple\ equivalent\ keys\ only\ if\ all\ of\ the}}
\DoxyCodeLine{00416\ \textcolor{stringliteral}{\ \ //\ following\ conditions\ are\ met:}}
\DoxyCodeLine{00417\ \textcolor{stringliteral}{\ \ //\ -\/\ The\ comparator\ is\ transparent.}}
\DoxyCodeLine{00418\ \textcolor{stringliteral}{\ \ //\ -\/\ The\ lookup\ key\ type\ is\ not\ the\ same\ as\ key\_type.}}
\DoxyCodeLine{00419\ \textcolor{stringliteral}{\ \ //\ -\/\ The\ comparator\ is\ not\ a\ StringBtreeDefault\{Less,Greater\}\ comparator}}
\DoxyCodeLine{00420\ \textcolor{stringliteral}{\ \ //\ \ \ that\ we\ know\ has\ the\ same\ equivalence\ classes\ for\ all\ lookup\ types.}}
\DoxyCodeLine{00421\ \textcolor{stringliteral}{\ \ template\ <typename\ LookupKey>}}
\DoxyCodeLine{00422\ \textcolor{stringliteral}{\ \ constexpr\ static\ bool\ can\_have\_multiple\_equivalent\_keys()\ \{}}
\DoxyCodeLine{00423\ \textcolor{stringliteral}{\ \ \ \ return\ IsMulti\ ||\ (IsTransparent<key\_compare>::value\ \&\&}}
\DoxyCodeLine{00424\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !std::is\_same<LookupKey,\ Key>::value\ \&\&}}
\DoxyCodeLine{00425\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ !kIsKeyCompareStringAdapted);}}
\DoxyCodeLine{00426\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00427\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00428\ \textcolor{stringliteral}{\ \ enum\ \{}}
\DoxyCodeLine{00429\ \textcolor{stringliteral}{\ \ \ \ kTargetNodeSize\ =\ TargetNodeSize,}}
\DoxyCodeLine{00430\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00431\ \textcolor{stringliteral}{\ \ \ \ //\ Upper\ bound\ for\ the\ available\ space\ for\ slots.\ This\ is\ largest\ for\ leaf}}
\DoxyCodeLine{00432\ \textcolor{stringliteral}{\ \ \ \ //\ nodes,\ which\ have\ overhead\ of\ at\ least\ a\ pointer\ +\ 4\ bytes\ (for\ storing}}
\DoxyCodeLine{00433\ \textcolor{stringliteral}{\ \ \ \ //\ 3\ field\_types\ and\ an\ enum).}}
\DoxyCodeLine{00434\ \textcolor{stringliteral}{\ \ \ \ kNodeSlotSpace\ =\ TargetNodeSize\ -\/\ /*minimum\ overhead=*/(sizeof(void\ *)\ +\ 4),}}
\DoxyCodeLine{00435\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{00436\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00437\ \textcolor{stringliteral}{\ \ //\ This\ is\ an\ integral\ type\ large\ enough\ to\ hold\ as\ many\ slots\ as\ will\ fit\ a}}
\DoxyCodeLine{00438\ \textcolor{stringliteral}{\ \ //\ node\ of\ TargetNodeSize\ bytes.}}
\DoxyCodeLine{00439\ \textcolor{stringliteral}{\ \ using\ node\_count\_type\ =}}
\DoxyCodeLine{00440\ \textcolor{stringliteral}{\ \ \ \ \ \ absl::conditional\_t<(kNodeSlotSpace\ /\ sizeof(slot\_type)\ >}}
\DoxyCodeLine{00441\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (std::numeric\_limits<uint8\_t>::max)()),}}
\DoxyCodeLine{00442\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ uint16\_t,\ uint8\_t>;\ \ //\ NOLINT}}
\DoxyCodeLine{00443\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00444\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00445\ \textcolor{stringliteral}{//\ An\ adapter\ class\ that\ converts\ a\ lower-\/bound\ compare\ into\ an\ upper-\/bound}}
\DoxyCodeLine{00446\ \textcolor{stringliteral}{//\ compare.\ Note:\ there\ is\ no\ need\ to\ make\ a\ version\ of\ this\ adapter\ specialized}}
\DoxyCodeLine{00447\ \textcolor{stringliteral}{//\ for\ key-\/compare-\/to\ functors\ because\ the\ upper-\/bound\ (the\ first\ value\ greater}}
\DoxyCodeLine{00448\ \textcolor{stringliteral}{//\ than\ the\ input)\ is\ never\ an\ exact\ match.}}
\DoxyCodeLine{00449\ \textcolor{stringliteral}{template\ <typename\ Compare>}}
\DoxyCodeLine{00450\ \textcolor{stringliteral}{struct\ upper\_bound\_adapter\ \{}}
\DoxyCodeLine{00451\ \textcolor{stringliteral}{\ \ explicit\ upper\_bound\_adapter(const\ Compare\ \&c)\ :\ comp(c)\ \{\}}}
\DoxyCodeLine{00452\ \textcolor{stringliteral}{\ \ template\ <typename\ K1,\ typename\ K2>}}
\DoxyCodeLine{00453\ \textcolor{stringliteral}{\ \ bool\ operator()(const\ K1\ \&a,\ const\ K2\ \&b)\ const\ \{}}
\DoxyCodeLine{00454\ \textcolor{stringliteral}{\ \ \ \ //\ Returns\ true\ when\ a\ is\ not\ greater\ than\ b.}}
\DoxyCodeLine{00455\ \textcolor{stringliteral}{\ \ \ \ return\ !compare\_internal::compare\_result\_as\_less\_than(comp(b,\ a));}}
\DoxyCodeLine{00456\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00457\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00458\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{00459\ \textcolor{stringliteral}{\ \ Compare\ comp;}}
\DoxyCodeLine{00460\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00461\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00462\ \textcolor{stringliteral}{enum\ class\ MatchKind\ :\ uint8\_t\ \{\ kEq,\ kNe\ \};}}
\DoxyCodeLine{00463\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00464\ \textcolor{stringliteral}{template\ <typename\ V,\ bool\ IsCompareTo>}}
\DoxyCodeLine{00465\ \textcolor{stringliteral}{struct\ SearchResult\ \{}}
\DoxyCodeLine{00466\ \textcolor{stringliteral}{\ \ V\ value;}}
\DoxyCodeLine{00467\ \textcolor{stringliteral}{\ \ MatchKind\ match;}}
\DoxyCodeLine{00468\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00469\ \textcolor{stringliteral}{\ \ static\ constexpr\ bool\ HasMatch()\ \{\ return\ true;\ \}}}
\DoxyCodeLine{00470\ \textcolor{stringliteral}{\ \ bool\ IsEq()\ const\ \{\ return\ match\ ==\ MatchKind::kEq;\ \}}}
\DoxyCodeLine{00471\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00472\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00473\ \textcolor{stringliteral}{//\ When\ we\ don't\ use\ CompareTo,\ \`{}match`\ is\ not\ present.}}
\DoxyCodeLine{00474\ \textcolor{stringliteral}{//\ This\ ensures\ that\ callers\ can't\ use\ it\ accidentally\ when\ it\ provides\ no}}
\DoxyCodeLine{00475\ \textcolor{stringliteral}{//\ useful\ information.}}
\DoxyCodeLine{00476\ \textcolor{stringliteral}{template\ <typename\ V>}}
\DoxyCodeLine{00477\ \textcolor{stringliteral}{struct\ SearchResult<V,\ false>\ \{}}
\DoxyCodeLine{00478\ \textcolor{stringliteral}{\ \ SearchResult()\ =\ default;}}
\DoxyCodeLine{00479\ \textcolor{stringliteral}{\ \ explicit\ SearchResult(V\ v)\ :\ value(v)\ \{\}}}
\DoxyCodeLine{00480\ \textcolor{stringliteral}{\ \ SearchResult(V\ v,\ MatchKind\ /*match*/)\ :\ value(v)\ \{\}}}
\DoxyCodeLine{00481\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00482\ \textcolor{stringliteral}{\ \ V\ value;}}
\DoxyCodeLine{00483\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00484\ \textcolor{stringliteral}{\ \ static\ constexpr\ bool\ HasMatch()\ \{\ return\ false;\ \}}}
\DoxyCodeLine{00485\ \textcolor{stringliteral}{\ \ static\ constexpr\ bool\ IsEq()\ \{\ return\ false;\ \}}}
\DoxyCodeLine{00486\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{00487\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00488\ \textcolor{stringliteral}{//\ A\ node\ in\ the\ btree\ holding.\ The\ same\ node\ type\ is\ used\ for\ both\ internal}}
\DoxyCodeLine{00489\ \textcolor{stringliteral}{//\ and\ leaf\ nodes\ in\ the\ btree,\ though\ the\ nodes\ are\ allocated\ in\ such\ a\ way}}
\DoxyCodeLine{00490\ \textcolor{stringliteral}{//\ that\ the\ children\ array\ is\ only\ valid\ in\ internal\ nodes.}}
\DoxyCodeLine{00491\ \textcolor{stringliteral}{template\ <typename\ Params>}}
\DoxyCodeLine{00492\ \textcolor{stringliteral}{class\ btree\_node\ \{}}
\DoxyCodeLine{00493\ \textcolor{stringliteral}{\ \ using\ is\_key\_compare\_to\ =\ typename\ Params::is\_key\_compare\_to;}}
\DoxyCodeLine{00494\ \textcolor{stringliteral}{\ \ using\ field\_type\ =\ typename\ Params::node\_count\_type;}}
\DoxyCodeLine{00495\ \textcolor{stringliteral}{\ \ using\ allocator\_type\ =\ typename\ Params::allocator\_type;}}
\DoxyCodeLine{00496\ \textcolor{stringliteral}{\ \ using\ slot\_type\ =\ typename\ Params::slot\_type;}}
\DoxyCodeLine{00497\ \textcolor{stringliteral}{\ \ using\ original\_key\_compare\ =\ typename\ Params::original\_key\_compare;}}
\DoxyCodeLine{00498\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00499\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{00500\ \textcolor{stringliteral}{\ \ using\ params\_type\ =\ Params;}}
\DoxyCodeLine{00501\ \textcolor{stringliteral}{\ \ using\ key\_type\ =\ typename\ Params::key\_type;}}
\DoxyCodeLine{00502\ \textcolor{stringliteral}{\ \ using\ value\_type\ =\ typename\ Params::value\_type;}}
\DoxyCodeLine{00503\ \textcolor{stringliteral}{\ \ using\ pointer\ =\ typename\ Params::pointer;}}
\DoxyCodeLine{00504\ \textcolor{stringliteral}{\ \ using\ const\_pointer\ =\ typename\ Params::const\_pointer;}}
\DoxyCodeLine{00505\ \textcolor{stringliteral}{\ \ using\ reference\ =\ typename\ Params::reference;}}
\DoxyCodeLine{00506\ \textcolor{stringliteral}{\ \ using\ const\_reference\ =\ typename\ Params::const\_reference;}}
\DoxyCodeLine{00507\ \textcolor{stringliteral}{\ \ using\ key\_compare\ =\ typename\ Params::key\_compare;}}
\DoxyCodeLine{00508\ \textcolor{stringliteral}{\ \ using\ size\_type\ =\ typename\ Params::size\_type;}}
\DoxyCodeLine{00509\ \textcolor{stringliteral}{\ \ using\ difference\_type\ =\ typename\ Params::difference\_type;}}
\DoxyCodeLine{00510\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00511\ \textcolor{stringliteral}{\ \ //\ Btree\ decides\ whether\ to\ use\ linear\ node\ search\ as\ follows:}}
\DoxyCodeLine{00512\ \textcolor{stringliteral}{\ \ //\ \ \ -\/\ If\ the\ comparator\ expresses\ a\ preference,\ use\ that.}}
\DoxyCodeLine{00513\ \textcolor{stringliteral}{\ \ //\ \ \ -\/\ If\ the\ key\ expresses\ a\ preference,\ use\ that.}}
\DoxyCodeLine{00514\ \textcolor{stringliteral}{\ \ //\ \ \ -\/\ If\ the\ key\ is\ arithmetic\ and\ the\ comparator\ is\ std::less\ or}}
\DoxyCodeLine{00515\ \textcolor{stringliteral}{\ \ //\ \ \ \ \ std::greater,\ choose\ linear.}}
\DoxyCodeLine{00516\ \textcolor{stringliteral}{\ \ //\ \ \ -\/\ Otherwise,\ choose\ binary.}}
\DoxyCodeLine{00517\ \textcolor{stringliteral}{\ \ //\ TODO(ezb):\ Might\ make\ sense\ to\ add\ condition(s)\ based\ on\ node-\/size.}}
\DoxyCodeLine{00518\ \textcolor{stringliteral}{\ \ using\ use\_linear\_search\ =\ std::integral\_constant<}}
\DoxyCodeLine{00519\ \textcolor{stringliteral}{\ \ \ \ \ \ bool,\ has\_linear\_node\_search\_preference<original\_key\_compare>::value}}
\DoxyCodeLine{00520\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ prefers\_linear\_node\_search<original\_key\_compare>::value}}
\DoxyCodeLine{00521\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ :\ has\_linear\_node\_search\_preference<key\_type>::value}}
\DoxyCodeLine{00522\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ prefers\_linear\_node\_search<key\_type>::value}}
\DoxyCodeLine{00523\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ std::is\_arithmetic<key\_type>::value\ \&\&}}
\DoxyCodeLine{00524\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (std::is\_same<std::less<key\_type>,}}
\DoxyCodeLine{00525\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ original\_key\_compare>::value\ ||}}
\DoxyCodeLine{00526\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<std::greater<key\_type>,}}
\DoxyCodeLine{00527\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ original\_key\_compare>::value)>;}}
\DoxyCodeLine{00528\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00529\ \textcolor{stringliteral}{\ \ //\ This\ class\ is\ organized\ by\ absl::container\_internal::Layout\ as\ if\ it\ had}}
\DoxyCodeLine{00530\ \textcolor{stringliteral}{\ \ //\ the\ following\ structure:}}
\DoxyCodeLine{00531\ \textcolor{stringliteral}{\ \ //\ \ \ //\ A\ pointer\ to\ the\ node's\ parent.}}
\DoxyCodeLine{00532\ \textcolor{stringliteral}{\ \ //\ \ \ btree\_node\ *parent;}}
\DoxyCodeLine{00533\ \textcolor{stringliteral}{\ \ //}}
\DoxyCodeLine{00534\ \textcolor{stringliteral}{\ \ //\ \ \ //\ When\ ABSL\_BTREE\_ENABLE\_GENERATIONS\ is\ defined,\ we\ also\ have\ a}}
\DoxyCodeLine{00535\ \textcolor{stringliteral}{\ \ //\ \ \ //\ generation\ integer\ in\ order\ to\ check\ that\ when\ iterators\ are}}
\DoxyCodeLine{00536\ \textcolor{stringliteral}{\ \ //\ \ \ //\ used,\ they\ haven't\ been\ invalidated\ already.\ Only\ the\ generation\ on}}
\DoxyCodeLine{00537\ \textcolor{stringliteral}{\ \ //\ \ \ //\ the\ root\ is\ used,\ but\ we\ have\ one\ on\ each\ node\ because\ whether\ a\ node}}
\DoxyCodeLine{00538\ \textcolor{stringliteral}{\ \ //\ \ \ //\ is\ root\ or\ not\ can\ change.}}
\DoxyCodeLine{00539\ \textcolor{stringliteral}{\ \ //\ \ \ uint32\_t\ generation;}}
\DoxyCodeLine{00540\ \textcolor{stringliteral}{\ \ //}}
\DoxyCodeLine{00541\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ position\ of\ the\ node\ in\ the\ node's\ parent.}}
\DoxyCodeLine{00542\ \textcolor{stringliteral}{\ \ //\ \ \ field\_type\ position;}}
\DoxyCodeLine{00543\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ index\ of\ the\ first\ populated\ value\ in\ \`{}values`.}}
\DoxyCodeLine{00544\ \textcolor{stringliteral}{\ \ //\ \ \ //\ TODO(ezb):\ right\ now,\ \`{}start`\ is\ always\ 0.\ Update\ insertion/merge}}
\DoxyCodeLine{00545\ \textcolor{stringliteral}{\ \ //\ \ \ //\ logic\ to\ allow\ for\ floating\ storage\ within\ nodes.}}
\DoxyCodeLine{00546\ \textcolor{stringliteral}{\ \ //\ \ \ field\_type\ start;}}
\DoxyCodeLine{00547\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ index\ after\ the\ last\ populated\ value\ in\ \`{}values`.\ Currently,\ this}}
\DoxyCodeLine{00548\ \textcolor{stringliteral}{\ \ //\ \ \ //\ is\ the\ same\ as\ the\ count\ of\ values.}}
\DoxyCodeLine{00549\ \textcolor{stringliteral}{\ \ //\ \ \ field\_type\ finish;}}
\DoxyCodeLine{00550\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ maximum\ number\ of\ values\ the\ node\ can\ hold.\ This\ is\ an\ integer\ in}}
\DoxyCodeLine{00551\ \textcolor{stringliteral}{\ \ //\ \ \ //\ [1,\ kNodeSlots]\ for\ root\ leaf\ nodes,\ kNodeSlots\ for\ non-\/root\ leaf}}
\DoxyCodeLine{00552\ \textcolor{stringliteral}{\ \ //\ \ \ //\ nodes,\ and\ kInternalNodeMaxCount\ (as\ a\ sentinel\ value)\ for\ internal}}
\DoxyCodeLine{00553\ \textcolor{stringliteral}{\ \ //\ \ \ //\ nodes\ (even\ though\ there\ are\ still\ kNodeSlots\ values\ in\ the\ node).}}
\DoxyCodeLine{00554\ \textcolor{stringliteral}{\ \ //\ \ \ //\ TODO(ezb):\ make\ max\_count\ use\ only\ 4\ bits\ and\ record\ log2(capacity)}}
\DoxyCodeLine{00555\ \textcolor{stringliteral}{\ \ //\ \ \ //\ to\ free\ extra\ bits\ for\ is\_root,\ etc.}}
\DoxyCodeLine{00556\ \textcolor{stringliteral}{\ \ //\ \ \ field\_type\ max\_count;}}
\DoxyCodeLine{00557\ \textcolor{stringliteral}{\ \ //}}
\DoxyCodeLine{00558\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ array\ of\ values.\ The\ capacity\ is\ \`{}max\_count`\ for\ leaf\ nodes\ and}}
\DoxyCodeLine{00559\ \textcolor{stringliteral}{\ \ //\ \ \ //\ kNodeSlots\ for\ internal\ nodes.\ Only\ the\ values\ in}}
\DoxyCodeLine{00560\ \textcolor{stringliteral}{\ \ //\ \ \ //\ [start,\ finish)\ have\ been\ initialized\ and\ are\ valid.}}
\DoxyCodeLine{00561\ \textcolor{stringliteral}{\ \ //\ \ \ slot\_type\ values[max\_count];}}
\DoxyCodeLine{00562\ \textcolor{stringliteral}{\ \ //}}
\DoxyCodeLine{00563\ \textcolor{stringliteral}{\ \ //\ \ \ //\ The\ array\ of\ child\ pointers.\ The\ keys\ in\ children[i]\ are\ all\ less}}
\DoxyCodeLine{00564\ \textcolor{stringliteral}{\ \ //\ \ \ //\ than\ key(i).\ The\ keys\ in\ children[i\ +\ 1]\ are\ all\ greater\ than\ key(i).}}
\DoxyCodeLine{00565\ \textcolor{stringliteral}{\ \ //\ \ \ //\ There\ are\ 0\ children\ for\ leaf\ nodes\ and\ kNodeSlots\ +\ 1\ children\ for}}
\DoxyCodeLine{00566\ \textcolor{stringliteral}{\ \ //\ \ \ //\ internal\ nodes.}}
\DoxyCodeLine{00567\ \textcolor{stringliteral}{\ \ //\ \ \ btree\_node\ *children[kNodeSlots\ +\ 1];}}
\DoxyCodeLine{00568\ \textcolor{stringliteral}{\ \ //}}
\DoxyCodeLine{00569\ \textcolor{stringliteral}{\ \ //\ This\ class\ is\ only\ constructed\ by\ EmptyNodeType.\ Normally,\ pointers\ to\ the}}
\DoxyCodeLine{00570\ \textcolor{stringliteral}{\ \ //\ layout\ above\ are\ allocated,\ cast\ to\ btree\_node*,\ and\ de-\/allocated\ within}}
\DoxyCodeLine{00571\ \textcolor{stringliteral}{\ \ //\ the\ btree\ implementation.}}
\DoxyCodeLine{00572\ \textcolor{stringliteral}{\ \ \string~btree\_node()\ =\ default;}}
\DoxyCodeLine{00573\ \textcolor{stringliteral}{\ \ btree\_node(btree\_node\ const\ \&)\ =\ delete;}}
\DoxyCodeLine{00574\ \textcolor{stringliteral}{\ \ btree\_node\ \&operator=(btree\_node\ const\ \&)\ =\ delete;}}
\DoxyCodeLine{00575\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00576\ \textcolor{stringliteral}{\ protected:}}
\DoxyCodeLine{00577\ \textcolor{stringliteral}{\ \ btree\_node()\ =\ default;}}
\DoxyCodeLine{00578\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00579\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{00580\ \textcolor{stringliteral}{\ \ using\ layout\_type\ =}}
\DoxyCodeLine{00581\ \textcolor{stringliteral}{\ \ \ \ \ \ absl::container\_internal::Layout<btree\_node\ *,\ uint32\_t,\ field\_type,}}
\DoxyCodeLine{00582\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ slot\_type,\ btree\_node\ *>;}}
\DoxyCodeLine{00583\ \textcolor{stringliteral}{\ \ using\ leaf\_layout\_type\ =\ typename\ layout\_type::template\ WithStaticSizes<}}
\DoxyCodeLine{00584\ \textcolor{stringliteral}{\ \ \ \ \ \ /*parent*/\ 1,}}
\DoxyCodeLine{00585\ \textcolor{stringliteral}{\ \ \ \ \ \ /*generation*/\ BtreeGenerationsEnabled()\ ?\ 1\ :\ 0,}}
\DoxyCodeLine{00586\ \textcolor{stringliteral}{\ \ \ \ \ \ /*position,\ start,\ finish,\ max\_count*/\ 4>;}}
\DoxyCodeLine{00587\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ SizeWithNSlots(size\_type\ n)\ \{}}
\DoxyCodeLine{00588\ \textcolor{stringliteral}{\ \ \ \ return\ leaf\_layout\_type(/*slots*/\ n,\ /*children*/\ 0).AllocSize();}}
\DoxyCodeLine{00589\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00590\ \textcolor{stringliteral}{\ \ //\ A\ lower\ bound\ for\ the\ overhead\ of\ fields\ other\ than\ slots\ in\ a\ leaf\ node.}}
\DoxyCodeLine{00591\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ MinimumOverhead()\ \{}}
\DoxyCodeLine{00592\ \textcolor{stringliteral}{\ \ \ \ return\ SizeWithNSlots(1)\ -\/\ sizeof(slot\_type);}}
\DoxyCodeLine{00593\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00594\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00595\ \textcolor{stringliteral}{\ \ //\ Compute\ how\ many\ values\ we\ can\ fit\ onto\ a\ leaf\ node\ taking\ into\ account}}
\DoxyCodeLine{00596\ \textcolor{stringliteral}{\ \ //\ padding.}}
\DoxyCodeLine{00597\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ NodeTargetSlots(const\ size\_type\ begin,}}
\DoxyCodeLine{00598\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ size\_type\ end)\ \{}}
\DoxyCodeLine{00599\ \textcolor{stringliteral}{\ \ \ \ return\ begin\ ==\ end\ ?\ begin}}
\DoxyCodeLine{00600\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ :\ SizeWithNSlots((begin\ +\ end)\ /\ 2\ +\ 1)\ >}}
\DoxyCodeLine{00601\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ params\_type::kTargetNodeSize}}
\DoxyCodeLine{00602\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ NodeTargetSlots(begin,\ (begin\ +\ end)\ /\ 2)}}
\DoxyCodeLine{00603\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ NodeTargetSlots((begin\ +\ end)\ /\ 2\ +\ 1,\ end);}}
\DoxyCodeLine{00604\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00605\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00606\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ kTargetNodeSize\ =\ params\_type::kTargetNodeSize;}}
\DoxyCodeLine{00607\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ kNodeTargetSlots\ =}}
\DoxyCodeLine{00608\ \textcolor{stringliteral}{\ \ \ \ \ \ NodeTargetSlots(0,\ kTargetNodeSize);}}
\DoxyCodeLine{00609\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00610\ \textcolor{stringliteral}{\ \ //\ We\ need\ a\ minimum\ of\ 3\ slots\ per\ internal\ node\ in\ order\ to\ perform}}
\DoxyCodeLine{00611\ \textcolor{stringliteral}{\ \ //\ splitting\ (1\ value\ for\ the\ two\ nodes\ involved\ in\ the\ split\ and\ 1\ value}}
\DoxyCodeLine{00612\ \textcolor{stringliteral}{\ \ //\ propagated\ to\ the\ parent\ as\ the\ delimiter\ for\ the\ split).\ For\ performance}}
\DoxyCodeLine{00613\ \textcolor{stringliteral}{\ \ //\ reasons,\ we\ don't\ allow\ 3\ slots-\/per-\/node\ due\ to\ bad\ worst\ case\ occupancy\ of}}
\DoxyCodeLine{00614\ \textcolor{stringliteral}{\ \ //\ 1/3\ (for\ a\ node,\ not\ a\ b-\/tree).}}
\DoxyCodeLine{00615\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ kMinNodeSlots\ =\ 4;}}
\DoxyCodeLine{00616\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00617\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ kNodeSlots\ =}}
\DoxyCodeLine{00618\ \textcolor{stringliteral}{\ \ \ \ \ \ kNodeTargetSlots\ >=\ kMinNodeSlots\ ?\ kNodeTargetSlots\ :\ kMinNodeSlots;}}
\DoxyCodeLine{00619\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00620\ \textcolor{stringliteral}{\ \ using\ internal\_layout\_type\ =\ typename\ layout\_type::template\ WithStaticSizes<}}
\DoxyCodeLine{00621\ \textcolor{stringliteral}{\ \ \ \ \ \ /*parent*/\ 1,}}
\DoxyCodeLine{00622\ \textcolor{stringliteral}{\ \ \ \ \ \ /*generation*/\ BtreeGenerationsEnabled()\ ?\ 1\ :\ 0,}}
\DoxyCodeLine{00623\ \textcolor{stringliteral}{\ \ \ \ \ \ /*position,\ start,\ finish,\ max\_count*/\ 4,\ /*slots*/\ kNodeSlots,}}
\DoxyCodeLine{00624\ \textcolor{stringliteral}{\ \ \ \ \ \ /*children*/\ kNodeSlots\ +\ 1>;}}
\DoxyCodeLine{00625\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00626\ \textcolor{stringliteral}{\ \ //\ The\ node\ is\ internal\ (i.e.\ is\ not\ a\ leaf\ node)\ if\ and\ only\ if\ \`{}max\_count`}}
\DoxyCodeLine{00627\ \textcolor{stringliteral}{\ \ //\ has\ this\ value.}}
\DoxyCodeLine{00628\ \textcolor{stringliteral}{\ \ constexpr\ static\ field\_type\ kInternalNodeMaxCount\ =\ 0;}}
\DoxyCodeLine{00629\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00630\ \textcolor{stringliteral}{\ \ //\ Leaves\ can\ have\ less\ than\ kNodeSlots\ values.}}
\DoxyCodeLine{00631\ \textcolor{stringliteral}{\ \ constexpr\ static\ leaf\_layout\_type\ LeafLayout(}}
\DoxyCodeLine{00632\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ size\_type\ slot\_count\ =\ kNodeSlots)\ \{}}
\DoxyCodeLine{00633\ \textcolor{stringliteral}{\ \ \ \ return\ leaf\_layout\_type(slot\_count,\ 0);}}
\DoxyCodeLine{00634\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00635\ \textcolor{stringliteral}{\ \ constexpr\ static\ auto\ InternalLayout()\ \{\ return\ internal\_layout\_type();\ \}}}
\DoxyCodeLine{00636\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ LeafSize(const\ size\_type\ slot\_count\ =\ kNodeSlots)\ \{}}
\DoxyCodeLine{00637\ \textcolor{stringliteral}{\ \ \ \ return\ LeafLayout(slot\_count).AllocSize();}}
\DoxyCodeLine{00638\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00639\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ InternalSize()\ \{}}
\DoxyCodeLine{00640\ \textcolor{stringliteral}{\ \ \ \ return\ InternalLayout().AllocSize();}}
\DoxyCodeLine{00641\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00642\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00643\ \textcolor{stringliteral}{\ \ constexpr\ static\ size\_type\ Alignment()\ \{}}
\DoxyCodeLine{00644\ \textcolor{stringliteral}{\ \ \ \ static\_assert(LeafLayout(1).Alignment()\ ==\ InternalLayout().Alignment(),}}
\DoxyCodeLine{00645\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}Alignment\ of\ all\ nodes\ must\ be\ equal.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{00646\ \textcolor{stringliteral}{\ \ \ \ return\ InternalLayout().Alignment();}}
\DoxyCodeLine{00647\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00648\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00649\ \textcolor{stringliteral}{\ \ //\ N\ is\ the\ index\ of\ the\ type\ in\ the\ Layout\ definition.}}
\DoxyCodeLine{00650\ \textcolor{stringliteral}{\ \ //\ ElementType<N>\ is\ the\ Nth\ type\ in\ the\ Layout\ definition.}}
\DoxyCodeLine{00651\ \textcolor{stringliteral}{\ \ template\ <size\_type\ N>}}
\DoxyCodeLine{00652\ \textcolor{stringliteral}{\ \ inline\ typename\ layout\_type::template\ ElementType<N>\ *GetField()\ \{}}
\DoxyCodeLine{00653\ \textcolor{stringliteral}{\ \ \ \ //\ We\ assert\ that\ we\ don't\ read\ from\ values\ that\ aren't\ there.}}
\DoxyCodeLine{00654\ \textcolor{stringliteral}{\ \ \ \ assert(N\ <\ 4\ ||\ is\_internal());}}
\DoxyCodeLine{00655\ \textcolor{stringliteral}{\ \ \ \ return\ InternalLayout().template\ Pointer<N>(reinterpret\_cast<char\ *>(this));}}
\DoxyCodeLine{00656\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00657\ \textcolor{stringliteral}{\ \ template\ <size\_type\ N>}}
\DoxyCodeLine{00658\ \textcolor{stringliteral}{\ \ inline\ const\ typename\ layout\_type::template\ ElementType<N>\ *GetField()\ const\ \{}}
\DoxyCodeLine{00659\ \textcolor{stringliteral}{\ \ \ \ assert(N\ <\ 4\ ||\ is\_internal());}}
\DoxyCodeLine{00660\ \textcolor{stringliteral}{\ \ \ \ return\ InternalLayout().template\ Pointer<N>(}}
\DoxyCodeLine{00661\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ reinterpret\_cast<const\ char\ *>(this));}}
\DoxyCodeLine{00662\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00663\ \textcolor{stringliteral}{\ \ void\ set\_parent(btree\_node\ *p)\ \{\ *GetField<0>()\ =\ p;\ \}}}
\DoxyCodeLine{00664\ \textcolor{stringliteral}{\ \ field\_type\ \&mutable\_finish()\ \{\ return\ GetField<2>()[2];\ \}}}
\DoxyCodeLine{00665\ \textcolor{stringliteral}{\ \ slot\_type\ *slot(size\_type\ i)\ \{\ return\ \&GetField<3>()[i];\ \}}}
\DoxyCodeLine{00666\ \textcolor{stringliteral}{\ \ slot\_type\ *start\_slot()\ \{\ return\ slot(start());\ \}}}
\DoxyCodeLine{00667\ \textcolor{stringliteral}{\ \ slot\_type\ *finish\_slot()\ \{\ return\ slot(finish());\ \}}}
\DoxyCodeLine{00668\ \textcolor{stringliteral}{\ \ const\ slot\_type\ *slot(size\_type\ i)\ const\ \{\ return\ \&GetField<3>()[i];\ \}}}
\DoxyCodeLine{00669\ \textcolor{stringliteral}{\ \ void\ set\_position(field\_type\ v)\ \{\ GetField<2>()[0]\ =\ v;\ \}}}
\DoxyCodeLine{00670\ \textcolor{stringliteral}{\ \ void\ set\_start(field\_type\ v)\ \{\ GetField<2>()[1]\ =\ v;\ \}}}
\DoxyCodeLine{00671\ \textcolor{stringliteral}{\ \ void\ set\_finish(field\_type\ v)\ \{\ GetField<2>()[2]\ =\ v;\ \}}}
\DoxyCodeLine{00672\ \textcolor{stringliteral}{\ \ //\ This\ method\ is\ only\ called\ by\ the\ node\ init\ methods.}}
\DoxyCodeLine{00673\ \textcolor{stringliteral}{\ \ void\ set\_max\_count(field\_type\ v)\ \{\ GetField<2>()[3]\ =\ v;\ \}}}
\DoxyCodeLine{00674\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00675\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{00676\ \textcolor{stringliteral}{\ \ //\ Whether\ this\ is\ a\ leaf\ node\ or\ not.\ This\ value\ doesn't\ change\ after\ the}}
\DoxyCodeLine{00677\ \textcolor{stringliteral}{\ \ //\ node\ is\ created.}}
\DoxyCodeLine{00678\ \textcolor{stringliteral}{\ \ bool\ is\_leaf()\ const\ \{\ return\ GetField<2>()[3]\ !=\ kInternalNodeMaxCount;\ \}}}
\DoxyCodeLine{00679\ \textcolor{stringliteral}{\ \ //\ Whether\ this\ is\ an\ internal\ node\ or\ not.\ This\ value\ doesn't\ change\ after}}
\DoxyCodeLine{00680\ \textcolor{stringliteral}{\ \ //\ the\ node\ is\ created.}}
\DoxyCodeLine{00681\ \textcolor{stringliteral}{\ \ bool\ is\_internal()\ const\ \{\ return\ !is\_leaf();\ \}}}
\DoxyCodeLine{00682\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00683\ \textcolor{stringliteral}{\ \ //\ Getter\ for\ the\ position\ of\ this\ node\ in\ its\ parent.}}
\DoxyCodeLine{00684\ \textcolor{stringliteral}{\ \ field\_type\ position()\ const\ \{\ return\ GetField<2>()[0];\ \}}}
\DoxyCodeLine{00685\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00686\ \textcolor{stringliteral}{\ \ //\ Getter\ for\ the\ offset\ of\ the\ first\ value\ in\ the\ \`{}values`\ array.}}
\DoxyCodeLine{00687\ \textcolor{stringliteral}{\ \ field\_type\ start()\ const\ \{}}
\DoxyCodeLine{00688\ \textcolor{stringliteral}{\ \ \ \ //\ TODO(ezb):\ when\ floating\ storage\ is\ implemented,\ return\ GetField<2>()[1];}}
\DoxyCodeLine{00689\ \textcolor{stringliteral}{\ \ \ \ assert(GetField<2>()[1]\ ==\ 0);}}
\DoxyCodeLine{00690\ \textcolor{stringliteral}{\ \ \ \ return\ 0;}}
\DoxyCodeLine{00691\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00692\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00693\ \textcolor{stringliteral}{\ \ //\ Getter\ for\ the\ offset\ after\ the\ last\ value\ in\ the\ \`{}values`\ array.}}
\DoxyCodeLine{00694\ \textcolor{stringliteral}{\ \ field\_type\ finish()\ const\ \{\ return\ GetField<2>()[2];\ \}}}
\DoxyCodeLine{00695\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00696\ \textcolor{stringliteral}{\ \ //\ Getters\ for\ the\ number\ of\ values\ stored\ in\ this\ node.}}
\DoxyCodeLine{00697\ \textcolor{stringliteral}{\ \ field\_type\ count()\ const\ \{}}
\DoxyCodeLine{00698\ \textcolor{stringliteral}{\ \ \ \ assert(finish()\ >=\ start());}}
\DoxyCodeLine{00699\ \textcolor{stringliteral}{\ \ \ \ return\ finish()\ -\/\ start();}}
\DoxyCodeLine{00700\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00701\ \textcolor{stringliteral}{\ \ field\_type\ max\_count()\ const\ \{}}
\DoxyCodeLine{00702\ \textcolor{stringliteral}{\ \ \ \ //\ Internal\ nodes\ have\ max\_count==kInternalNodeMaxCount.}}
\DoxyCodeLine{00703\ \textcolor{stringliteral}{\ \ \ \ //\ Leaf\ nodes\ have\ max\_count\ in\ [1,\ kNodeSlots].}}
\DoxyCodeLine{00704\ \textcolor{stringliteral}{\ \ \ \ const\ field\_type\ max\_count\ =\ GetField<2>()[3];}}
\DoxyCodeLine{00705\ \textcolor{stringliteral}{\ \ \ \ return\ max\_count\ ==\ field\_type\{kInternalNodeMaxCount\}}}
\DoxyCodeLine{00706\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ field\_type\{kNodeSlots\}}}
\DoxyCodeLine{00707\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ max\_count;}}
\DoxyCodeLine{00708\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00709\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00710\ \textcolor{stringliteral}{\ \ //\ Getter\ for\ the\ parent\ of\ this\ node.}}
\DoxyCodeLine{00711\ \textcolor{stringliteral}{\ \ btree\_node\ *parent()\ const\ \{\ return\ *GetField<0>();\ \}}}
\DoxyCodeLine{00712\ \textcolor{stringliteral}{\ \ //\ Getter\ for\ whether\ the\ node\ is\ the\ root\ of\ the\ tree.\ The\ parent\ of\ the}}
\DoxyCodeLine{00713\ \textcolor{stringliteral}{\ \ //\ root\ of\ the\ tree\ is\ the\ leftmost\ node\ in\ the\ tree\ which\ is\ guaranteed\ to}}
\DoxyCodeLine{00714\ \textcolor{stringliteral}{\ \ //\ be\ a\ leaf.}}
\DoxyCodeLine{00715\ \textcolor{stringliteral}{\ \ bool\ is\_root()\ const\ \{\ return\ parent()-\/>is\_leaf();\ \}}}
\DoxyCodeLine{00716\ \textcolor{stringliteral}{\ \ void\ make\_root()\ \{}}
\DoxyCodeLine{00717\ \textcolor{stringliteral}{\ \ \ \ assert(parent()-\/>is\_root());}}
\DoxyCodeLine{00718\ \textcolor{stringliteral}{\ \ \ \ set\_generation(parent()-\/>generation());}}
\DoxyCodeLine{00719\ \textcolor{stringliteral}{\ \ \ \ set\_parent(parent()-\/>parent());}}
\DoxyCodeLine{00720\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00721\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00722\ \textcolor{stringliteral}{\ \ //\ Gets\ the\ root\ node's\ generation\ integer,\ which\ is\ the\ one\ used\ by\ the\ tree.}}
\DoxyCodeLine{00723\ \textcolor{stringliteral}{\ \ uint32\_t\ *get\_root\_generation()\ const\ \{}}
\DoxyCodeLine{00724\ \textcolor{stringliteral}{\ \ \ \ assert(BtreeGenerationsEnabled());}}
\DoxyCodeLine{00725\ \textcolor{stringliteral}{\ \ \ \ const\ btree\_node\ *curr\ =\ this;}}
\DoxyCodeLine{00726\ \textcolor{stringliteral}{\ \ \ \ for\ (;\ !curr-\/>is\_root();\ curr\ =\ curr-\/>parent())\ continue;}}
\DoxyCodeLine{00727\ \textcolor{stringliteral}{\ \ \ \ return\ const\_cast<uint32\_t\ *>(\&curr-\/>GetField<1>()[0]);}}
\DoxyCodeLine{00728\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00729\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00730\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ generation\ for\ iterator\ validation.}}
\DoxyCodeLine{00731\ \textcolor{stringliteral}{\ \ uint32\_t\ generation()\ const\ \{}}
\DoxyCodeLine{00732\ \textcolor{stringliteral}{\ \ \ \ return\ BtreeGenerationsEnabled()\ ?\ *get\_root\_generation()\ :\ 0;}}
\DoxyCodeLine{00733\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00734\ \textcolor{stringliteral}{\ \ //\ Updates\ generation.\ Should\ only\ be\ called\ on\ a\ root\ node\ or\ during\ node}}
\DoxyCodeLine{00735\ \textcolor{stringliteral}{\ \ //\ initialization.}}
\DoxyCodeLine{00736\ \textcolor{stringliteral}{\ \ void\ set\_generation(uint32\_t\ generation)\ \{}}
\DoxyCodeLine{00737\ \textcolor{stringliteral}{\ \ \ \ if\ (BtreeGenerationsEnabled())\ GetField<1>()[0]\ =\ generation;}}
\DoxyCodeLine{00738\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00739\ \textcolor{stringliteral}{\ \ //\ Updates\ the\ generation.\ We\ do\ this\ whenever\ the\ node\ is\ mutated.}}
\DoxyCodeLine{00740\ \textcolor{stringliteral}{\ \ void\ next\_generation()\ \{}}
\DoxyCodeLine{00741\ \textcolor{stringliteral}{\ \ \ \ if\ (BtreeGenerationsEnabled())\ ++*get\_root\_generation();}}
\DoxyCodeLine{00742\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00743\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00744\ \textcolor{stringliteral}{\ \ //\ Getters\ for\ the\ key/value\ at\ position\ i\ in\ the\ node.}}
\DoxyCodeLine{00745\ \textcolor{stringliteral}{\ \ const\ key\_type\ \&key(size\_type\ i)\ const\ \{\ return\ params\_type::key(slot(i));\ \}}}
\DoxyCodeLine{00746\ \textcolor{stringliteral}{\ \ reference\ value(size\_type\ i)\ \{\ return\ params\_type::element(slot(i));\ \}}}
\DoxyCodeLine{00747\ \textcolor{stringliteral}{\ \ const\_reference\ value(size\_type\ i)\ const\ \{}}
\DoxyCodeLine{00748\ \textcolor{stringliteral}{\ \ \ \ return\ params\_type::element(slot(i));}}
\DoxyCodeLine{00749\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00750\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00751\ \textcolor{stringliteral}{\ \ //\ Getters/setter\ for\ the\ child\ at\ position\ i\ in\ the\ node.}}
\DoxyCodeLine{00752\ \textcolor{stringliteral}{\ \ btree\_node\ *child(field\_type\ i)\ const\ \{\ return\ GetField<4>()[i];\ \}}}
\DoxyCodeLine{00753\ \textcolor{stringliteral}{\ \ btree\_node\ *start\_child()\ const\ \{\ return\ child(start());\ \}}}
\DoxyCodeLine{00754\ \textcolor{stringliteral}{\ \ btree\_node\ *\&mutable\_child(field\_type\ i)\ \{\ return\ GetField<4>()[i];\ \}}}
\DoxyCodeLine{00755\ \textcolor{stringliteral}{\ \ void\ clear\_child(field\_type\ i)\ \{}}
\DoxyCodeLine{00756\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerPoisonObject(\&mutable\_child(i));}}
\DoxyCodeLine{00757\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00758\ \textcolor{stringliteral}{\ \ void\ set\_child\_noupdate\_position(field\_type\ i,\ btree\_node\ *c)\ \{}}
\DoxyCodeLine{00759\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerUnpoisonObject(\&mutable\_child(i));}}
\DoxyCodeLine{00760\ \textcolor{stringliteral}{\ \ \ \ mutable\_child(i)\ =\ c;}}
\DoxyCodeLine{00761\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00762\ \textcolor{stringliteral}{\ \ void\ set\_child(field\_type\ i,\ btree\_node\ *c)\ \{}}
\DoxyCodeLine{00763\ \textcolor{stringliteral}{\ \ \ \ set\_child\_noupdate\_position(i,\ c);}}
\DoxyCodeLine{00764\ \textcolor{stringliteral}{\ \ \ \ c-\/>set\_position(i);}}
\DoxyCodeLine{00765\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00766\ \textcolor{stringliteral}{\ \ void\ init\_child(field\_type\ i,\ btree\_node\ *c)\ \{}}
\DoxyCodeLine{00767\ \textcolor{stringliteral}{\ \ \ \ set\_child(i,\ c);}}
\DoxyCodeLine{00768\ \textcolor{stringliteral}{\ \ \ \ c-\/>set\_parent(this);}}
\DoxyCodeLine{00769\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00770\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00771\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k.}}
\DoxyCodeLine{00772\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{00773\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ is\_key\_compare\_to::value>\ lower\_bound(}}
\DoxyCodeLine{00774\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&k,\ const\ key\_compare\ \&comp)\ const\ \{}}
\DoxyCodeLine{00775\ \textcolor{stringliteral}{\ \ \ \ return\ use\_linear\_search::value\ ?\ linear\_search(k,\ comp)}}
\DoxyCodeLine{00776\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ binary\_search(k,\ comp);}}
\DoxyCodeLine{00777\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00778\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ greater\ than\ k.}}
\DoxyCodeLine{00779\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{00780\ \textcolor{stringliteral}{\ \ size\_type\ upper\_bound(const\ K\ \&k,\ const\ key\_compare\ \&comp)\ const\ \{}}
\DoxyCodeLine{00781\ \textcolor{stringliteral}{\ \ \ \ auto\ upper\_compare\ =\ upper\_bound\_adapter<key\_compare>(comp);}}
\DoxyCodeLine{00782\ \textcolor{stringliteral}{\ \ \ \ return\ use\_linear\_search::value\ ?\ linear\_search(k,\ upper\_compare).value}}
\DoxyCodeLine{00783\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ binary\_search(k,\ upper\_compare).value;}}
\DoxyCodeLine{00784\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00785\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00786\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ Compare>}}
\DoxyCodeLine{00787\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ btree\_is\_key\_compare\_to<Compare,\ key\_type>::value>}}
\DoxyCodeLine{00788\ \textcolor{stringliteral}{\ \ linear\_search(const\ K\ \&k,\ const\ Compare\ \&comp)\ const\ \{}}
\DoxyCodeLine{00789\ \textcolor{stringliteral}{\ \ \ \ return\ linear\_search\_impl(k,\ start(),\ finish(),\ comp,}}
\DoxyCodeLine{00790\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_is\_key\_compare\_to<Compare,\ key\_type>());}}
\DoxyCodeLine{00791\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00792\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00793\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ Compare>}}
\DoxyCodeLine{00794\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ btree\_is\_key\_compare\_to<Compare,\ key\_type>::value>}}
\DoxyCodeLine{00795\ \textcolor{stringliteral}{\ \ binary\_search(const\ K\ \&k,\ const\ Compare\ \&comp)\ const\ \{}}
\DoxyCodeLine{00796\ \textcolor{stringliteral}{\ \ \ \ return\ binary\_search\_impl(k,\ start(),\ finish(),\ comp,}}
\DoxyCodeLine{00797\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_is\_key\_compare\_to<Compare,\ key\_type>());}}
\DoxyCodeLine{00798\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00799\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00800\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k\ using}}
\DoxyCodeLine{00801\ \textcolor{stringliteral}{\ \ //\ linear\ search\ performed\ using\ plain\ compare.}}
\DoxyCodeLine{00802\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ Compare>}}
\DoxyCodeLine{00803\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ false>\ linear\_search\_impl(}}
\DoxyCodeLine{00804\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&k,\ size\_type\ s,\ const\ size\_type\ e,\ const\ Compare\ \&comp,}}
\DoxyCodeLine{00805\ \textcolor{stringliteral}{\ \ \ \ \ \ std::false\_type\ /*\ IsCompareTo\ */)\ const\ \{}}
\DoxyCodeLine{00806\ \textcolor{stringliteral}{\ \ \ \ while\ (s\ <\ e)\ \{}}
\DoxyCodeLine{00807\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (!comp(key(s),\ k))\ \{}}
\DoxyCodeLine{00808\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ break;}}
\DoxyCodeLine{00809\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00810\ \textcolor{stringliteral}{\ \ \ \ \ \ ++s;}}
\DoxyCodeLine{00811\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00812\ \textcolor{stringliteral}{\ \ \ \ return\ SearchResult<size\_type,\ false>\{s\};}}
\DoxyCodeLine{00813\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00814\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00815\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k\ using}}
\DoxyCodeLine{00816\ \textcolor{stringliteral}{\ \ //\ linear\ search\ performed\ using\ compare-\/to.}}
\DoxyCodeLine{00817\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ Compare>}}
\DoxyCodeLine{00818\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ true>\ linear\_search\_impl(}}
\DoxyCodeLine{00819\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&k,\ size\_type\ s,\ const\ size\_type\ e,\ const\ Compare\ \&comp,}}
\DoxyCodeLine{00820\ \textcolor{stringliteral}{\ \ \ \ \ \ std::true\_type\ /*\ IsCompareTo\ */)\ const\ \{}}
\DoxyCodeLine{00821\ \textcolor{stringliteral}{\ \ \ \ while\ (s\ <\ e)\ \{}}
\DoxyCodeLine{00822\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ absl::weak\_ordering\ c\ =\ comp(key(s),\ k);}}
\DoxyCodeLine{00823\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (c\ ==\ 0)\ \{}}
\DoxyCodeLine{00824\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ \{s,\ MatchKind::kEq\};}}
\DoxyCodeLine{00825\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ else\ if\ (c\ >\ 0)\ \{}}
\DoxyCodeLine{00826\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ break;}}
\DoxyCodeLine{00827\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00828\ \textcolor{stringliteral}{\ \ \ \ \ \ ++s;}}
\DoxyCodeLine{00829\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00830\ \textcolor{stringliteral}{\ \ \ \ return\ \{s,\ MatchKind::kNe\};}}
\DoxyCodeLine{00831\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00832\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00833\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k\ using}}
\DoxyCodeLine{00834\ \textcolor{stringliteral}{\ \ //\ binary\ search\ performed\ using\ plain\ compare.}}
\DoxyCodeLine{00835\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ Compare>}}
\DoxyCodeLine{00836\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ false>\ binary\_search\_impl(}}
\DoxyCodeLine{00837\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&k,\ size\_type\ s,\ size\_type\ e,\ const\ Compare\ \&comp,}}
\DoxyCodeLine{00838\ \textcolor{stringliteral}{\ \ \ \ \ \ std::false\_type\ /*\ IsCompareTo\ */)\ const\ \{}}
\DoxyCodeLine{00839\ \textcolor{stringliteral}{\ \ \ \ while\ (s\ !=\ e)\ \{}}
\DoxyCodeLine{00840\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ size\_type\ mid\ =\ (s\ +\ e)\ >>\ 1;}}
\DoxyCodeLine{00841\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (comp(key(mid),\ k))\ \{}}
\DoxyCodeLine{00842\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ s\ =\ mid\ +\ 1;}}
\DoxyCodeLine{00843\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{00844\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ e\ =\ mid;}}
\DoxyCodeLine{00845\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00846\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00847\ \textcolor{stringliteral}{\ \ \ \ return\ SearchResult<size\_type,\ false>\{s\};}}
\DoxyCodeLine{00848\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00849\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00850\ \textcolor{stringliteral}{\ \ //\ Returns\ the\ position\ of\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k\ using}}
\DoxyCodeLine{00851\ \textcolor{stringliteral}{\ \ //\ binary\ search\ performed\ using\ compare-\/to.}}
\DoxyCodeLine{00852\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename\ CompareTo>}}
\DoxyCodeLine{00853\ \textcolor{stringliteral}{\ \ SearchResult<size\_type,\ true>\ binary\_search\_impl(}}
\DoxyCodeLine{00854\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&k,\ size\_type\ s,\ size\_type\ e,\ const\ CompareTo\ \&comp,}}
\DoxyCodeLine{00855\ \textcolor{stringliteral}{\ \ \ \ \ \ std::true\_type\ /*\ IsCompareTo\ */)\ const\ \{}}
\DoxyCodeLine{00856\ \textcolor{stringliteral}{\ \ \ \ if\ (params\_type::template\ can\_have\_multiple\_equivalent\_keys<K>())\ \{}}
\DoxyCodeLine{00857\ \textcolor{stringliteral}{\ \ \ \ \ \ MatchKind\ exact\_match\ =\ MatchKind::kNe;}}
\DoxyCodeLine{00858\ \textcolor{stringliteral}{\ \ \ \ \ \ while\ (s\ !=\ e)\ \{}}
\DoxyCodeLine{00859\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ const\ size\_type\ mid\ =\ (s\ +\ e)\ >>\ 1;}}
\DoxyCodeLine{00860\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ const\ absl::weak\_ordering\ c\ =\ comp(key(mid),\ k);}}
\DoxyCodeLine{00861\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ if\ (c\ <\ 0)\ \{}}
\DoxyCodeLine{00862\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ s\ =\ mid\ +\ 1;}}
\DoxyCodeLine{00863\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{00864\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ e\ =\ mid;}}
\DoxyCodeLine{00865\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ if\ (c\ ==\ 0)\ \{}}
\DoxyCodeLine{00866\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ //\ Need\ to\ return\ the\ first\ value\ whose\ key\ is\ not\ less\ than\ k,}}
\DoxyCodeLine{00867\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ //\ which\ requires\ continuing\ the\ binary\ search\ if\ there\ could\ be}}
\DoxyCodeLine{00868\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ //\ multiple\ equivalent\ keys.}}
\DoxyCodeLine{00869\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ exact\_match\ =\ MatchKind::kEq;}}
\DoxyCodeLine{00870\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{00871\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{00872\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00873\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ \{s,\ exact\_match\};}}
\DoxyCodeLine{00874\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{\ \ //\ Can't\ have\ multiple\ equivalent\ keys.}}
\DoxyCodeLine{00875\ \textcolor{stringliteral}{\ \ \ \ \ \ while\ (s\ !=\ e)\ \{}}
\DoxyCodeLine{00876\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ const\ size\_type\ mid\ =\ (s\ +\ e)\ >>\ 1;}}
\DoxyCodeLine{00877\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ const\ absl::weak\_ordering\ c\ =\ comp(key(mid),\ k);}}
\DoxyCodeLine{00878\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ if\ (c\ <\ 0)\ \{}}
\DoxyCodeLine{00879\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ s\ =\ mid\ +\ 1;}}
\DoxyCodeLine{00880\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}\ else\ if\ (c\ >\ 0)\ \{}}
\DoxyCodeLine{00881\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ e\ =\ mid;}}
\DoxyCodeLine{00882\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{00883\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ return\ \{mid,\ MatchKind::kEq\};}}
\DoxyCodeLine{00884\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{00885\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00886\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ \{s,\ MatchKind::kNe\};}}
\DoxyCodeLine{00887\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00888\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00889\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00890\ \textcolor{stringliteral}{\ \ //\ Returns\ whether\ key\ i\ is\ ordered\ correctly\ with\ respect\ to\ the\ other\ keys}}
\DoxyCodeLine{00891\ \textcolor{stringliteral}{\ \ //\ in\ the\ node.\ The\ motivation\ here\ is\ to\ detect\ comparators\ that\ violate}}
\DoxyCodeLine{00892\ \textcolor{stringliteral}{\ \ //\ transitivity.\ Note:\ we\ only\ do\ comparisons\ of\ keys\ on\ this\ node\ rather\ than}}
\DoxyCodeLine{00893\ \textcolor{stringliteral}{\ \ //\ the\ whole\ tree\ so\ that\ this\ is\ constant\ time.}}
\DoxyCodeLine{00894\ \textcolor{stringliteral}{\ \ template\ <typename\ Compare>}}
\DoxyCodeLine{00895\ \textcolor{stringliteral}{\ \ bool\ is\_ordered\_correctly(field\_type\ i,\ const\ Compare\ \&comp)\ const\ \{}}
\DoxyCodeLine{00896\ \textcolor{stringliteral}{\ \ \ \ if\ (std::is\_base\_of<BtreeTestOnlyCheckedCompareOptOutBase,}}
\DoxyCodeLine{00897\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Compare>::value\ ||}}
\DoxyCodeLine{00898\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ params\_type::kIsKeyCompareStringAdapted)\ \{}}
\DoxyCodeLine{00899\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ true;}}
\DoxyCodeLine{00900\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00901\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00902\ \textcolor{stringliteral}{\ \ \ \ const\ auto\ compare\ =\ [\&](field\_type\ a,\ field\_type\ b)\ \{}}
\DoxyCodeLine{00903\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ absl::weak\_ordering\ cmp\ =}}
\DoxyCodeLine{00904\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ compare\_internal::do\_three\_way\_comparison(comp,\ key(a),\ key(b));}}
\DoxyCodeLine{00905\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ cmp\ <\ 0\ ?\ -\/1\ :\ cmp\ >\ 0\ ?\ 1\ :\ 0;}}
\DoxyCodeLine{00906\ \textcolor{stringliteral}{\ \ \ \ \};}}
\DoxyCodeLine{00907\ \textcolor{stringliteral}{\ \ \ \ int\ cmp\ =\ -\/1;}}
\DoxyCodeLine{00908\ \textcolor{stringliteral}{\ \ \ \ constexpr\ bool\ kCanHaveEquivKeys\ =}}
\DoxyCodeLine{00909\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ params\_type::template\ can\_have\_multiple\_equivalent\_keys<key\_type>();}}
\DoxyCodeLine{00910\ \textcolor{stringliteral}{\ \ \ \ for\ (field\_type\ j\ =\ start();\ j\ <\ finish();\ ++j)\ \{}}
\DoxyCodeLine{00911\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (j\ ==\ i)\ \{}}
\DoxyCodeLine{00912\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ if\ (cmp\ >\ 0)\ return\ false;}}
\DoxyCodeLine{00913\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ continue;}}
\DoxyCodeLine{00914\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{00915\ \textcolor{stringliteral}{\ \ \ \ \ \ int\ new\_cmp\ =\ compare(j,\ i);}}
\DoxyCodeLine{00916\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (new\_cmp\ <\ cmp\ ||\ (!kCanHaveEquivKeys\ \&\&\ new\_cmp\ ==\ 0))\ return\ false;}}
\DoxyCodeLine{00917\ \textcolor{stringliteral}{\ \ \ \ \ \ cmp\ =\ new\_cmp;}}
\DoxyCodeLine{00918\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00919\ \textcolor{stringliteral}{\ \ \ \ return\ true;}}
\DoxyCodeLine{00920\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00921\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00922\ \textcolor{stringliteral}{\ \ //\ Emplaces\ a\ value\ at\ position\ i,\ shifting\ all\ existing\ values\ and}}
\DoxyCodeLine{00923\ \textcolor{stringliteral}{\ \ //\ children\ at\ positions\ >=\ i\ to\ the\ right\ by\ 1.}}
\DoxyCodeLine{00924\ \textcolor{stringliteral}{\ \ template\ <typename...\ Args>}}
\DoxyCodeLine{00925\ \textcolor{stringliteral}{\ \ void\ emplace\_value(field\_type\ i,\ allocator\_type\ *alloc,\ Args\ \&\&...args);}}
\DoxyCodeLine{00926\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00927\ \textcolor{stringliteral}{\ \ //\ Removes\ the\ values\ at\ positions\ [i,\ i\ +\ to\_erase),\ shifting\ all\ existing}}
\DoxyCodeLine{00928\ \textcolor{stringliteral}{\ \ //\ values\ and\ children\ after\ that\ range\ to\ the\ left\ by\ to\_erase.\ Clears\ all}}
\DoxyCodeLine{00929\ \textcolor{stringliteral}{\ \ //\ children\ between\ [i,\ i\ +\ to\_erase).}}
\DoxyCodeLine{00930\ \textcolor{stringliteral}{\ \ void\ remove\_values(field\_type\ i,\ field\_type\ to\_erase,\ allocator\_type\ *alloc);}}
\DoxyCodeLine{00931\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00932\ \textcolor{stringliteral}{\ \ //\ Rebalances\ a\ node\ with\ its\ right\ sibling.}}
\DoxyCodeLine{00933\ \textcolor{stringliteral}{\ \ void\ rebalance\_right\_to\_left(field\_type\ to\_move,\ btree\_node\ *right,}}
\DoxyCodeLine{00934\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc);}}
\DoxyCodeLine{00935\ \textcolor{stringliteral}{\ \ void\ rebalance\_left\_to\_right(field\_type\ to\_move,\ btree\_node\ *right,}}
\DoxyCodeLine{00936\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc);}}
\DoxyCodeLine{00937\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00938\ \textcolor{stringliteral}{\ \ //\ Splits\ a\ node,\ moving\ a\ portion\ of\ the\ node's\ values\ to\ its\ right\ sibling.}}
\DoxyCodeLine{00939\ \textcolor{stringliteral}{\ \ void\ split(int\ insert\_position,\ btree\_node\ *dest,\ allocator\_type\ *alloc);}}
\DoxyCodeLine{00940\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00941\ \textcolor{stringliteral}{\ \ //\ Merges\ a\ node\ with\ its\ right\ sibling,\ moving\ all\ of\ the\ values\ and\ the}}
\DoxyCodeLine{00942\ \textcolor{stringliteral}{\ \ //\ delimiting\ key\ in\ the\ parent\ node\ onto\ itself,\ and\ deleting\ the\ src\ node.}}
\DoxyCodeLine{00943\ \textcolor{stringliteral}{\ \ void\ merge(btree\_node\ *src,\ allocator\_type\ *alloc);}}
\DoxyCodeLine{00944\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00945\ \textcolor{stringliteral}{\ \ //\ Node\ allocation/deletion\ routines.}}
\DoxyCodeLine{00946\ \textcolor{stringliteral}{\ \ void\ init\_leaf(field\_type\ position,\ field\_type\ max\_count,}}
\DoxyCodeLine{00947\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_node\ *parent)\ \{}}
\DoxyCodeLine{00948\ \textcolor{stringliteral}{\ \ \ \ set\_generation(0);}}
\DoxyCodeLine{00949\ \textcolor{stringliteral}{\ \ \ \ set\_parent(parent);}}
\DoxyCodeLine{00950\ \textcolor{stringliteral}{\ \ \ \ set\_position(position);}}
\DoxyCodeLine{00951\ \textcolor{stringliteral}{\ \ \ \ set\_start(0);}}
\DoxyCodeLine{00952\ \textcolor{stringliteral}{\ \ \ \ set\_finish(0);}}
\DoxyCodeLine{00953\ \textcolor{stringliteral}{\ \ \ \ set\_max\_count(max\_count);}}
\DoxyCodeLine{00954\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerPoisonMemoryRegion(}}
\DoxyCodeLine{00955\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ start\_slot(),\ max\_count\ *\ sizeof(slot\_type));}}
\DoxyCodeLine{00956\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00957\ \textcolor{stringliteral}{\ \ void\ init\_internal(field\_type\ position,\ btree\_node\ *parent)\ \{}}
\DoxyCodeLine{00958\ \textcolor{stringliteral}{\ \ \ \ init\_leaf(position,\ kNodeSlots,\ parent);}}
\DoxyCodeLine{00959\ \textcolor{stringliteral}{\ \ \ \ //\ Set\ \`{}max\_count`\ to\ a\ sentinel\ value\ to\ indicate\ that\ this\ node\ is}}
\DoxyCodeLine{00960\ \textcolor{stringliteral}{\ \ \ \ //\ internal.}}
\DoxyCodeLine{00961\ \textcolor{stringliteral}{\ \ \ \ set\_max\_count(kInternalNodeMaxCount);}}
\DoxyCodeLine{00962\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerPoisonMemoryRegion(}}
\DoxyCodeLine{00963\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \&mutable\_child(start()),\ (kNodeSlots\ +\ 1)\ *\ sizeof(btree\_node\ *));}}
\DoxyCodeLine{00964\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00965\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00966\ \textcolor{stringliteral}{\ \ static\ void\ deallocate(const\ size\_type\ size,\ btree\_node\ *node,}}
\DoxyCodeLine{00967\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{00968\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerUnpoisonMemoryRegion(node,\ size);}}
\DoxyCodeLine{00969\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::Deallocate<Alignment()>(alloc,\ node,\ size);}}
\DoxyCodeLine{00970\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00971\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00972\ \textcolor{stringliteral}{\ \ //\ Deletes\ a\ node\ and\ all\ of\ its\ children.}}
\DoxyCodeLine{00973\ \textcolor{stringliteral}{\ \ static\ void\ clear\_and\_delete(btree\_node\ *node,\ allocator\_type\ *alloc);}}
\DoxyCodeLine{00974\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00975\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{00976\ \textcolor{stringliteral}{\ \ template\ <typename...\ Args>}}
\DoxyCodeLine{00977\ \textcolor{stringliteral}{\ \ void\ value\_init(const\ field\_type\ i,\ allocator\_type\ *alloc,\ Args\ \&\&...args)\ \{}}
\DoxyCodeLine{00978\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{00979\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerUnpoisonObject(slot(i));}}
\DoxyCodeLine{00980\ \textcolor{stringliteral}{\ \ \ \ params\_type::construct(alloc,\ slot(i),\ std::forward<Args>(args)...);}}
\DoxyCodeLine{00981\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00982\ \textcolor{stringliteral}{\ \ void\ value\_destroy(const\ field\_type\ i,\ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{00983\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{00984\ \textcolor{stringliteral}{\ \ \ \ params\_type::destroy(alloc,\ slot(i));}}
\DoxyCodeLine{00985\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerPoisonObject(slot(i));}}
\DoxyCodeLine{00986\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00987\ \textcolor{stringliteral}{\ \ void\ value\_destroy\_n(const\ field\_type\ i,\ const\ field\_type\ n,}}
\DoxyCodeLine{00988\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{00989\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{00990\ \textcolor{stringliteral}{\ \ \ \ for\ (slot\_type\ *s\ =\ slot(i),\ *end\ =\ slot(i\ +\ n);\ s\ !=\ end;\ ++s)\ \{}}
\DoxyCodeLine{00991\ \textcolor{stringliteral}{\ \ \ \ \ \ params\_type::destroy(alloc,\ s);}}
\DoxyCodeLine{00992\ \textcolor{stringliteral}{\ \ \ \ \ \ absl::container\_internal::SanitizerPoisonObject(s);}}
\DoxyCodeLine{00993\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{00994\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{00995\ \textcolor{stringliteral}{}}
\DoxyCodeLine{00996\ \textcolor{stringliteral}{\ \ static\ void\ transfer(slot\_type\ *dest,\ slot\_type\ *src,\ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{00997\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerUnpoisonObject(dest);}}
\DoxyCodeLine{00998\ \textcolor{stringliteral}{\ \ \ \ params\_type::transfer(alloc,\ dest,\ src);}}
\DoxyCodeLine{00999\ \textcolor{stringliteral}{\ \ \ \ absl::container\_internal::SanitizerPoisonObject(src);}}
\DoxyCodeLine{01000\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01001\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01002\ \textcolor{stringliteral}{\ \ //\ Transfers\ value\ from\ slot\ \`{}src\_i`\ in\ \`{}src\_node`\ to\ slot\ \`{}dest\_i`\ in\ \`{}this`.}}
\DoxyCodeLine{01003\ \textcolor{stringliteral}{\ \ void\ transfer(const\ size\_type\ dest\_i,\ const\ size\_type\ src\_i,}}
\DoxyCodeLine{01004\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_node\ *src\_node,\ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{01005\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{01006\ \textcolor{stringliteral}{\ \ \ \ transfer(slot(dest\_i),\ src\_node-\/>slot(src\_i),\ alloc);}}
\DoxyCodeLine{01007\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01008\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01009\ \textcolor{stringliteral}{\ \ //\ Transfers\ \`{}n`\ values\ starting\ at\ value\ \`{}src\_i`\ in\ \`{}src\_node`\ into\ the}}
\DoxyCodeLine{01010\ \textcolor{stringliteral}{\ \ //\ values\ starting\ at\ value\ \`{}dest\_i`\ in\ \`{}this`.}}
\DoxyCodeLine{01011\ \textcolor{stringliteral}{\ \ void\ transfer\_n(const\ size\_type\ n,\ const\ size\_type\ dest\_i,}}
\DoxyCodeLine{01012\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ size\_type\ src\_i,\ btree\_node\ *src\_node,}}
\DoxyCodeLine{01013\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{01014\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{01015\ \textcolor{stringliteral}{\ \ \ \ for\ (slot\_type\ *src\ =\ src\_node-\/>slot(src\_i),\ *end\ =\ src\ +\ n,}}
\DoxyCodeLine{01016\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *dest\ =\ slot(dest\_i);}}
\DoxyCodeLine{01017\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ src\ !=\ end;\ ++src,\ ++dest)\ \{}}
\DoxyCodeLine{01018\ \textcolor{stringliteral}{\ \ \ \ \ \ transfer(dest,\ src,\ alloc);}}
\DoxyCodeLine{01019\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01020\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01021\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01022\ \textcolor{stringliteral}{\ \ //\ Same\ as\ above,\ except\ that\ we\ start\ at\ the\ end\ and\ work\ our\ way\ to\ the}}
\DoxyCodeLine{01023\ \textcolor{stringliteral}{\ \ //\ beginning.}}
\DoxyCodeLine{01024\ \textcolor{stringliteral}{\ \ void\ transfer\_n\_backward(const\ size\_type\ n,\ const\ size\_type\ dest\_i,}}
\DoxyCodeLine{01025\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ size\_type\ src\_i,\ btree\_node\ *src\_node,}}
\DoxyCodeLine{01026\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}}
\DoxyCodeLine{01027\ \textcolor{stringliteral}{\ \ \ \ next\_generation();}}
\DoxyCodeLine{01028\ \textcolor{stringliteral}{\ \ \ \ for\ (slot\_type\ *src\ =\ src\_node-\/>slot(src\_i\ +\ n),\ *end\ =\ src\ -\/\ n,}}
\DoxyCodeLine{01029\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ *dest\ =\ slot(dest\_i\ +\ n);}}
\DoxyCodeLine{01030\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ src\ !=\ end;\ -\/-\/src,\ -\/-\/dest)\ \{}}
\DoxyCodeLine{01031\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ If\ we\ modified\ the\ loop\ index\ calculations\ above\ to\ avoid\ the\ -\/1s\ here,}}
\DoxyCodeLine{01032\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ it\ would\ result\ in\ UB\ in\ the\ computation\ of\ \`{}end`\ (and\ possibly\ \`{}src`}}
\DoxyCodeLine{01033\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ as\ well,\ if\ n\ ==\ 0),\ since\ slot()\ is\ effectively\ an\ array\ index\ and\ it}}
\DoxyCodeLine{01034\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ is\ UB\ to\ compute\ the\ address\ of\ any\ out-\/of-\/bounds\ array\ element\ except}}
\DoxyCodeLine{01035\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ for\ one-\/past-\/the-\/end.}}
\DoxyCodeLine{01036\ \textcolor{stringliteral}{\ \ \ \ \ \ transfer(dest\ -\/\ 1,\ src\ -\/\ 1,\ alloc);}}
\DoxyCodeLine{01037\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01038\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01039\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01040\ \textcolor{stringliteral}{\ \ template\ <typename\ P>}}
\DoxyCodeLine{01041\ \textcolor{stringliteral}{\ \ friend\ class\ btree;}}
\DoxyCodeLine{01042\ \textcolor{stringliteral}{\ \ template\ <typename\ N,\ typename\ R,\ typename\ P>}}
\DoxyCodeLine{01043\ \textcolor{stringliteral}{\ \ friend\ class\ btree\_iterator;}}
\DoxyCodeLine{01044\ \textcolor{stringliteral}{\ \ friend\ class\ BtreeNodePeer;}}
\DoxyCodeLine{01045\ \textcolor{stringliteral}{\ \ friend\ struct\ btree\_access;}}
\DoxyCodeLine{01046\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{01047\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01048\ \textcolor{stringliteral}{template\ <typename\ Node>}}
\DoxyCodeLine{01049\ \textcolor{stringliteral}{bool\ AreNodesFromSameContainer(const\ Node\ *node\_a,\ const\ Node\ *node\_b)\ \{}}
\DoxyCodeLine{01050\ \textcolor{stringliteral}{\ \ //\ If\ either\ node\ is\ null,\ then\ give\ up\ on\ checking\ whether\ they're\ from\ the}}
\DoxyCodeLine{01051\ \textcolor{stringliteral}{\ \ //\ same\ container.\ (If\ exactly\ one\ is\ null,\ then\ we'll\ trigger\ the}}
\DoxyCodeLine{01052\ \textcolor{stringliteral}{\ \ //\ default-\/constructed\ assert\ in\ Equals.)}}
\DoxyCodeLine{01053\ \textcolor{stringliteral}{\ \ if\ (node\_a\ ==\ nullptr\ ||\ node\_b\ ==\ nullptr)\ return\ true;}}
\DoxyCodeLine{01054\ \textcolor{stringliteral}{\ \ while\ (!node\_a-\/>is\_root())\ node\_a\ =\ node\_a-\/>parent();}}
\DoxyCodeLine{01055\ \textcolor{stringliteral}{\ \ while\ (!node\_b-\/>is\_root())\ node\_b\ =\ node\_b-\/>parent();}}
\DoxyCodeLine{01056\ \textcolor{stringliteral}{\ \ return\ node\_a\ ==\ node\_b;}}
\DoxyCodeLine{01057\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{01058\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01059\ \textcolor{stringliteral}{class\ btree\_iterator\_generation\_info\_enabled\ \{}}
\DoxyCodeLine{01060\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{01061\ \textcolor{stringliteral}{\ \ explicit\ btree\_iterator\_generation\_info\_enabled(uint32\_t\ g)}}
\DoxyCodeLine{01062\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ generation\_(g)\ \{\}}}
\DoxyCodeLine{01063\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01064\ \textcolor{stringliteral}{\ \ //\ Updates\ the\ generation.\ For\ use\ internally\ right\ before\ we\ return\ an}}
\DoxyCodeLine{01065\ \textcolor{stringliteral}{\ \ //\ iterator\ to\ the\ user.}}
\DoxyCodeLine{01066\ \textcolor{stringliteral}{\ \ template\ <typename\ Node>}}
\DoxyCodeLine{01067\ \textcolor{stringliteral}{\ \ void\ update\_generation(const\ Node\ *node)\ \{}}
\DoxyCodeLine{01068\ \textcolor{stringliteral}{\ \ \ \ if\ (node\ !=\ nullptr)\ generation\_\ =\ node-\/>generation();}}
\DoxyCodeLine{01069\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01070\ \textcolor{stringliteral}{\ \ uint32\_t\ generation()\ const\ \{\ return\ generation\_;\ \}}}
\DoxyCodeLine{01071\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01072\ \textcolor{stringliteral}{\ \ template\ <typename\ Node>}}
\DoxyCodeLine{01073\ \textcolor{stringliteral}{\ \ void\ assert\_valid\_generation(const\ Node\ *node)\ const\ \{}}
\DoxyCodeLine{01074\ \textcolor{stringliteral}{\ \ \ \ if\ (node\ !=\ nullptr\ \&\&\ node-\/>generation()\ !=\ generation\_)\ \{}}
\DoxyCodeLine{01075\ \textcolor{stringliteral}{\ \ \ \ \ \ ABSL\_INTERNAL\_LOG(}}
\DoxyCodeLine{01076\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ FATAL,}}
\DoxyCodeLine{01077\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ "{}}Attempting\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2layout__test_8cc_a633ab603a49d0a046734a0f3e6de45e9}{to}}\ use\ an\ invalidated\ iterator.\ The\ corresponding\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2layout__test_8cc_ad66453096871179e6c6effe0df4b483b}{b}}-\/tree\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{01078\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ "{}}container\ has\ been\ mutated\ since\ \textcolor{keyword}{this}\ iterator\ was\ constructed.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{01079\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01080\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01081\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01082\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{01083\ \textcolor{stringliteral}{\ \ //\ Used\ to\ check\ that\ the\ iterator\ hasn't\ been\ invalidated.}}
\DoxyCodeLine{01084\ \textcolor{stringliteral}{\ \ uint32\_t\ generation\_;}}
\DoxyCodeLine{01085\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{01086\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01087\ \textcolor{stringliteral}{class\ btree\_iterator\_generation\_info\_disabled\ \{}}
\DoxyCodeLine{01088\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{01089\ \textcolor{stringliteral}{\ \ explicit\ btree\_iterator\_generation\_info\_disabled(uint32\_t)\ \{\}}}
\DoxyCodeLine{01090\ \textcolor{stringliteral}{\ \ static\ void\ update\_generation(const\ void\ *)\ \{\}}}
\DoxyCodeLine{01091\ \textcolor{stringliteral}{\ \ static\ uint32\_t\ generation()\ \{\ return\ 0;\ \}}}
\DoxyCodeLine{01092\ \textcolor{stringliteral}{\ \ static\ void\ assert\_valid\_generation(const\ void\ *)\ \{\}}}
\DoxyCodeLine{01093\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{01094\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01095\ \textcolor{stringliteral}{\#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{01096\ \textcolor{stringliteral}{using\ btree\_iterator\_generation\_info\ =\ btree\_iterator\_generation\_info\_enabled;}}
\DoxyCodeLine{01097\ \textcolor{stringliteral}{\#else}}
\DoxyCodeLine{01098\ \textcolor{stringliteral}{using\ btree\_iterator\_generation\_info\ =\ btree\_iterator\_generation\_info\_disabled;}}
\DoxyCodeLine{01099\ \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{01100\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01101\ \textcolor{stringliteral}{template\ <typename\ Node,\ typename\ Reference,\ typename\ Pointer>}}
\DoxyCodeLine{01102\ \textcolor{stringliteral}{class\ btree\_iterator\ :\ private\ btree\_iterator\_generation\_info\ \{}}
\DoxyCodeLine{01103\ \textcolor{stringliteral}{\ \ using\ field\_type\ =\ typename\ Node::field\_type;}}
\DoxyCodeLine{01104\ \textcolor{stringliteral}{\ \ using\ key\_type\ =\ typename\ Node::key\_type;}}
\DoxyCodeLine{01105\ \textcolor{stringliteral}{\ \ using\ size\_type\ =\ typename\ Node::size\_type;}}
\DoxyCodeLine{01106\ \textcolor{stringliteral}{\ \ using\ params\_type\ =\ typename\ Node::params\_type;}}
\DoxyCodeLine{01107\ \textcolor{stringliteral}{\ \ using\ is\_map\_container\ =\ typename\ params\_type::is\_map\_container;}}
\DoxyCodeLine{01108\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01109\ \textcolor{stringliteral}{\ \ using\ node\_type\ =\ Node;}}
\DoxyCodeLine{01110\ \textcolor{stringliteral}{\ \ using\ normal\_node\ =\ typename\ std::remove\_const<Node>::type;}}
\DoxyCodeLine{01111\ \textcolor{stringliteral}{\ \ using\ const\_node\ =\ const\ Node;}}
\DoxyCodeLine{01112\ \textcolor{stringliteral}{\ \ using\ normal\_pointer\ =\ typename\ params\_type::pointer;}}
\DoxyCodeLine{01113\ \textcolor{stringliteral}{\ \ using\ normal\_reference\ =\ typename\ params\_type::reference;}}
\DoxyCodeLine{01114\ \textcolor{stringliteral}{\ \ using\ const\_pointer\ =\ typename\ params\_type::const\_pointer;}}
\DoxyCodeLine{01115\ \textcolor{stringliteral}{\ \ using\ const\_reference\ =\ typename\ params\_type::const\_reference;}}
\DoxyCodeLine{01116\ \textcolor{stringliteral}{\ \ using\ slot\_type\ =\ typename\ params\_type::slot\_type;}}
\DoxyCodeLine{01117\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01118\ \textcolor{stringliteral}{\ \ //\ In\ sets,\ all\ iterators\ are\ const.}}
\DoxyCodeLine{01119\ \textcolor{stringliteral}{\ \ using\ iterator\ =\ absl::conditional\_t<}}
\DoxyCodeLine{01120\ \textcolor{stringliteral}{\ \ \ \ \ \ is\_map\_container::value,}}
\DoxyCodeLine{01121\ \textcolor{stringliteral}{\ \ \ \ \ \ btree\_iterator<normal\_node,\ normal\_reference,\ normal\_pointer>,}}
\DoxyCodeLine{01122\ \textcolor{stringliteral}{\ \ \ \ \ \ btree\_iterator<normal\_node,\ const\_reference,\ const\_pointer>>;}}
\DoxyCodeLine{01123\ \textcolor{stringliteral}{\ \ using\ const\_iterator\ =}}
\DoxyCodeLine{01124\ \textcolor{stringliteral}{\ \ \ \ \ \ btree\_iterator<const\_node,\ const\_reference,\ const\_pointer>;}}
\DoxyCodeLine{01125\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01126\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{01127\ \textcolor{stringliteral}{\ \ //\ These\ aliases\ are\ public\ for\ std::iterator\_traits.}}
\DoxyCodeLine{01128\ \textcolor{stringliteral}{\ \ using\ difference\_type\ =\ typename\ Node::difference\_type;}}
\DoxyCodeLine{01129\ \textcolor{stringliteral}{\ \ using\ value\_type\ =\ typename\ params\_type::value\_type;}}
\DoxyCodeLine{01130\ \textcolor{stringliteral}{\ \ using\ pointer\ =\ Pointer;}}
\DoxyCodeLine{01131\ \textcolor{stringliteral}{\ \ using\ reference\ =\ Reference;}}
\DoxyCodeLine{01132\ \textcolor{stringliteral}{\ \ using\ iterator\_category\ =\ std::bidirectional\_iterator\_tag;}}
\DoxyCodeLine{01133\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01134\ \textcolor{stringliteral}{\ \ btree\_iterator()\ :\ btree\_iterator(nullptr,\ -\/1)\ \{\}}}
\DoxyCodeLine{01135\ \textcolor{stringliteral}{\ \ explicit\ btree\_iterator(Node\ *n)\ :\ btree\_iterator(n,\ n-\/>start())\ \{\}}}
\DoxyCodeLine{01136\ \textcolor{stringliteral}{\ \ btree\_iterator(Node\ *n,\ int\ p)}}
\DoxyCodeLine{01137\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ btree\_iterator\_generation\_info(n\ !=\ nullptr\ ?\ n-\/>generation()}}
\DoxyCodeLine{01138\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ \string~uint32\_t\{\}),}}
\DoxyCodeLine{01139\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ node\_(n),}}
\DoxyCodeLine{01140\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ position\_(p)\ \{\}}}
\DoxyCodeLine{01141\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01142\ \textcolor{stringliteral}{\ \ //\ NOTE:\ this\ SFINAE\ allows\ for\ implicit\ conversions\ from\ iterator\ to}}
\DoxyCodeLine{01143\ \textcolor{stringliteral}{\ \ //\ const\_iterator,\ but\ it\ specifically\ avoids\ hiding\ the\ copy\ constructor\ so}}
\DoxyCodeLine{01144\ \textcolor{stringliteral}{\ \ //\ that\ the\ trivial\ one\ will\ be\ used\ when\ possible.}}
\DoxyCodeLine{01145\ \textcolor{stringliteral}{\ \ template\ <typename\ N,\ typename\ R,\ typename\ P,}}
\DoxyCodeLine{01146\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ absl::enable\_if\_t<}}
\DoxyCodeLine{01147\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<btree\_iterator<N,\ R,\ P>,\ iterator>::value\ \&\&}}
\DoxyCodeLine{01148\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<btree\_iterator,\ const\_iterator>::value,}}
\DoxyCodeLine{01149\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int>\ =\ 0>}}
\DoxyCodeLine{01150\ \textcolor{stringliteral}{\ \ btree\_iterator(const\ btree\_iterator<N,\ R,\ P>\ other)\ \ //\ NOLINT}}
\DoxyCodeLine{01151\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ btree\_iterator\_generation\_info(other),}}
\DoxyCodeLine{01152\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ node\_(other.node\_),}}
\DoxyCodeLine{01153\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ position\_(other.position\_)\ \{\}}}
\DoxyCodeLine{01154\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01155\ \textcolor{stringliteral}{\ \ bool\ operator==(const\ iterator\ \&other)\ const\ \{}}
\DoxyCodeLine{01156\ \textcolor{stringliteral}{\ \ \ \ return\ Equals(other);}}
\DoxyCodeLine{01157\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01158\ \textcolor{stringliteral}{\ \ bool\ operator==(const\ const\_iterator\ \&other)\ const\ \{}}
\DoxyCodeLine{01159\ \textcolor{stringliteral}{\ \ \ \ return\ Equals(other);}}
\DoxyCodeLine{01160\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01161\ \textcolor{stringliteral}{\ \ bool\ operator!=(const\ iterator\ \&other)\ const\ \{}}
\DoxyCodeLine{01162\ \textcolor{stringliteral}{\ \ \ \ return\ !Equals(other);}}
\DoxyCodeLine{01163\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01164\ \textcolor{stringliteral}{\ \ bool\ operator!=(const\ const\_iterator\ \&other)\ const\ \{}}
\DoxyCodeLine{01165\ \textcolor{stringliteral}{\ \ \ \ return\ !Equals(other);}}
\DoxyCodeLine{01166\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01167\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01168\ \textcolor{stringliteral}{\ \ //\ Returns\ n\ such\ that\ n\ calls\ to\ ++other\ yields\ *this.}}
\DoxyCodeLine{01169\ \textcolor{stringliteral}{\ \ //\ Precondition:\ n\ exists.}}
\DoxyCodeLine{01170\ \textcolor{stringliteral}{\ \ difference\_type\ operator-\/(const\_iterator\ other)\ const\ \{}}
\DoxyCodeLine{01171\ \textcolor{stringliteral}{\ \ \ \ if\ (node\_\ ==\ other.node\_)\ \{}}
\DoxyCodeLine{01172\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (node\_-\/>is\_leaf())\ return\ position\_\ -\/\ other.position\_;}}
\DoxyCodeLine{01173\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (position\_\ ==\ other.position\_)\ return\ 0;}}
\DoxyCodeLine{01174\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01175\ \textcolor{stringliteral}{\ \ \ \ return\ distance\_slow(other);}}
\DoxyCodeLine{01176\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01177\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01178\ \textcolor{stringliteral}{\ \ //\ Accessors\ for\ the\ key/value\ the\ iterator\ is\ pointing\ at.}}
\DoxyCodeLine{01179\ \textcolor{stringliteral}{\ \ reference\ operator*()\ const\ \{}}
\DoxyCodeLine{01180\ \textcolor{stringliteral}{\ \ \ \ ABSL\_HARDENING\_ASSERT(node\_\ !=\ nullptr);}}
\DoxyCodeLine{01181\ \textcolor{stringliteral}{\ \ \ \ assert\_valid\_generation(node\_);}}
\DoxyCodeLine{01182\ \textcolor{stringliteral}{\ \ \ \ ABSL\_HARDENING\_ASSERT(position\_\ >=\ node\_-\/>start());}}
\DoxyCodeLine{01183\ \textcolor{stringliteral}{\ \ \ \ if\ (position\_\ >=\ node\_-\/>finish())\ \{}}
\DoxyCodeLine{01184\ \textcolor{stringliteral}{\ \ \ \ \ \ ABSL\_HARDENING\_ASSERT(!IsEndIterator()\ \&\&\ "{}}Dereferencing\ end()\ iterator\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{01185\ \textcolor{stringliteral}{\ \ \ \ \ \ ABSL\_HARDENING\_ASSERT(position\_\ <\ node\_-\/>finish());}}
\DoxyCodeLine{01186\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01187\ \textcolor{stringliteral}{\ \ \ \ return\ node\_-\/>value(static\_cast<field\_type>(position\_));}}
\DoxyCodeLine{01188\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01189\ \textcolor{stringliteral}{\ \ pointer\ operator-\/>()\ const\ \{\ return\ \&operator*();\ \}}}
\DoxyCodeLine{01190\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01191\ \textcolor{stringliteral}{\ \ btree\_iterator\ \&operator++()\ \{}}
\DoxyCodeLine{01192\ \textcolor{stringliteral}{\ \ \ \ increment();}}
\DoxyCodeLine{01193\ \textcolor{stringliteral}{\ \ \ \ return\ *this;}}
\DoxyCodeLine{01194\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01195\ \textcolor{stringliteral}{\ \ btree\_iterator\ \&operator-\/-\/()\ \{}}
\DoxyCodeLine{01196\ \textcolor{stringliteral}{\ \ \ \ decrement();}}
\DoxyCodeLine{01197\ \textcolor{stringliteral}{\ \ \ \ return\ *this;}}
\DoxyCodeLine{01198\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01199\ \textcolor{stringliteral}{\ \ btree\_iterator\ operator++(int)\ \{}}
\DoxyCodeLine{01200\ \textcolor{stringliteral}{\ \ \ \ btree\_iterator\ tmp\ =\ *this;}}
\DoxyCodeLine{01201\ \textcolor{stringliteral}{\ \ \ \ ++*this;}}
\DoxyCodeLine{01202\ \textcolor{stringliteral}{\ \ \ \ return\ tmp;}}
\DoxyCodeLine{01203\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01204\ \textcolor{stringliteral}{\ \ btree\_iterator\ operator-\/-\/(int)\ \{}}
\DoxyCodeLine{01205\ \textcolor{stringliteral}{\ \ \ \ btree\_iterator\ tmp\ =\ *this;}}
\DoxyCodeLine{01206\ \textcolor{stringliteral}{\ \ \ \ -\/-\/*this;}}
\DoxyCodeLine{01207\ \textcolor{stringliteral}{\ \ \ \ return\ tmp;}}
\DoxyCodeLine{01208\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01209\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01210\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{01211\ \textcolor{stringliteral}{\ \ friend\ iterator;}}
\DoxyCodeLine{01212\ \textcolor{stringliteral}{\ \ friend\ const\_iterator;}}
\DoxyCodeLine{01213\ \textcolor{stringliteral}{\ \ template\ <typename\ Params>}}
\DoxyCodeLine{01214\ \textcolor{stringliteral}{\ \ friend\ class\ btree;}}
\DoxyCodeLine{01215\ \textcolor{stringliteral}{\ \ template\ <typename\ Tree>}}
\DoxyCodeLine{01216\ \textcolor{stringliteral}{\ \ friend\ class\ btree\_container;}}
\DoxyCodeLine{01217\ \textcolor{stringliteral}{\ \ template\ <typename\ Tree>}}
\DoxyCodeLine{01218\ \textcolor{stringliteral}{\ \ friend\ class\ btree\_set\_container;}}
\DoxyCodeLine{01219\ \textcolor{stringliteral}{\ \ template\ <typename\ Tree>}}
\DoxyCodeLine{01220\ \textcolor{stringliteral}{\ \ friend\ class\ btree\_map\_container;}}
\DoxyCodeLine{01221\ \textcolor{stringliteral}{\ \ template\ <typename\ Tree>}}
\DoxyCodeLine{01222\ \textcolor{stringliteral}{\ \ friend\ class\ btree\_multiset\_container;}}
\DoxyCodeLine{01223\ \textcolor{stringliteral}{\ \ template\ <typename\ TreeType,\ typename\ CheckerType>}}
\DoxyCodeLine{01224\ \textcolor{stringliteral}{\ \ friend\ class\ base\_checker;}}
\DoxyCodeLine{01225\ \textcolor{stringliteral}{\ \ friend\ struct\ btree\_access;}}
\DoxyCodeLine{01226\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01227\ \textcolor{stringliteral}{\ \ //\ This\ SFINAE\ allows\ explicit\ conversions\ from\ const\_iterator\ to}}
\DoxyCodeLine{01228\ \textcolor{stringliteral}{\ \ //\ iterator,\ but\ also\ avoids\ hiding\ the\ copy\ constructor.}}
\DoxyCodeLine{01229\ \textcolor{stringliteral}{\ \ //\ NOTE:\ the\ const\_cast\ is\ safe\ because\ this\ constructor\ is\ only\ called\ by}}
\DoxyCodeLine{01230\ \textcolor{stringliteral}{\ \ //\ non-\/const\ methods\ and\ the\ container\ owns\ the\ nodes.}}
\DoxyCodeLine{01231\ \textcolor{stringliteral}{\ \ template\ <typename\ N,\ typename\ R,\ typename\ P,}}
\DoxyCodeLine{01232\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ absl::enable\_if\_t<}}
\DoxyCodeLine{01233\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<btree\_iterator<N,\ R,\ P>,\ const\_iterator>::value\ \&\&}}
\DoxyCodeLine{01234\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<btree\_iterator,\ iterator>::value,}}
\DoxyCodeLine{01235\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ int>\ =\ 0>}}
\DoxyCodeLine{01236\ \textcolor{stringliteral}{\ \ explicit\ btree\_iterator(const\ btree\_iterator<N,\ R,\ P>\ other)}}
\DoxyCodeLine{01237\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ btree\_iterator\_generation\_info(other.generation()),}}
\DoxyCodeLine{01238\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ node\_(const\_cast<node\_type\ *>(other.node\_)),}}
\DoxyCodeLine{01239\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ position\_(other.position\_)\ \{\}}}
\DoxyCodeLine{01240\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01241\ \textcolor{stringliteral}{\ \ bool\ Equals(const\ const\_iterator\ other)\ const\ \{}}
\DoxyCodeLine{01242\ \textcolor{stringliteral}{\ \ \ \ ABSL\_HARDENING\_ASSERT(((node\_\ ==\ nullptr\ \&\&\ other.node\_\ ==\ nullptr)\ ||}}
\DoxyCodeLine{01243\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (node\_\ !=\ nullptr\ \&\&\ other.node\_\ !=\ nullptr))\ \&\&}}
\DoxyCodeLine{01244\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}Comparing\ \textcolor{keywordflow}{default}-\/constructed\ iterator\ with\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{01245\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}non-\/\textcolor{keywordflow}{default}-\/constructed\ iterator.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{01246\ \textcolor{stringliteral}{\ \ \ \ //\ Note:\ we\ use\ assert\ instead\ of\ ABSL\_HARDENING\_ASSERT\ here\ because\ this}}
\DoxyCodeLine{01247\ \textcolor{stringliteral}{\ \ \ \ //\ changes\ the\ complexity\ of\ Equals\ from\ O(1)\ to\ O(log(N)\ +\ log(M))\ where}}
\DoxyCodeLine{01248\ \textcolor{stringliteral}{\ \ \ \ //\ N/M\ are\ sizes\ of\ the\ containers\ containing\ node\_/other.node\_.}}
\DoxyCodeLine{01249\ \textcolor{stringliteral}{\ \ \ \ assert(AreNodesFromSameContainer(node\_,\ other.node\_)\ \&\&}}
\DoxyCodeLine{01250\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ "{}}Comparing\ iterators\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2layout__test_8cc_a66a6152caa0d2dec6985ed86838ba876}{from}}\ different\ containers.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{01251\ \textcolor{stringliteral}{\ \ \ \ assert\_valid\_generation(node\_);}}
\DoxyCodeLine{01252\ \textcolor{stringliteral}{\ \ \ \ other.assert\_valid\_generation(other.node\_);}}
\DoxyCodeLine{01253\ \textcolor{stringliteral}{\ \ \ \ return\ node\_\ ==\ other.node\_\ \&\&\ position\_\ ==\ other.position\_;}}
\DoxyCodeLine{01254\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01255\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01256\ \textcolor{stringliteral}{\ \ bool\ IsEndIterator()\ const\ \{}}
\DoxyCodeLine{01257\ \textcolor{stringliteral}{\ \ \ \ if\ (position\_\ !=\ node\_-\/>finish())\ return\ false;}}
\DoxyCodeLine{01258\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *node\ =\ node\_;}}
\DoxyCodeLine{01259\ \textcolor{stringliteral}{\ \ \ \ while\ (!node-\/>is\_root())\ \{}}
\DoxyCodeLine{01260\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (node-\/>position()\ !=\ node-\/>parent()-\/>finish())\ return\ false;}}
\DoxyCodeLine{01261\ \textcolor{stringliteral}{\ \ \ \ \ \ node\ =\ node-\/>parent();}}
\DoxyCodeLine{01262\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01263\ \textcolor{stringliteral}{\ \ \ \ return\ true;}}
\DoxyCodeLine{01264\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01265\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01266\ \textcolor{stringliteral}{\ \ //\ Returns\ n\ such\ that\ n\ calls\ to\ ++other\ yields\ *this.}}
\DoxyCodeLine{01267\ \textcolor{stringliteral}{\ \ //\ Precondition:\ n\ exists\ \&\&\ (this-\/>node\_\ !=\ other.node\_\ ||}}
\DoxyCodeLine{01268\ \textcolor{stringliteral}{\ \ //\ !this-\/>node\_-\/>is\_leaf()\ ||\ this-\/>position\_\ !=\ other.position\_).}}
\DoxyCodeLine{01269\ \textcolor{stringliteral}{\ \ difference\_type\ distance\_slow(const\_iterator\ other)\ const;}}
\DoxyCodeLine{01270\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01271\ \textcolor{stringliteral}{\ \ //\ Increment/decrement\ the\ iterator.}}
\DoxyCodeLine{01272\ \textcolor{stringliteral}{\ \ void\ increment()\ \{}}
\DoxyCodeLine{01273\ \textcolor{stringliteral}{\ \ \ \ assert\_valid\_generation(node\_);}}
\DoxyCodeLine{01274\ \textcolor{stringliteral}{\ \ \ \ if\ (node\_-\/>is\_leaf()\ \&\&\ ++position\_\ <\ node\_-\/>finish())\ \{}}
\DoxyCodeLine{01275\ \textcolor{stringliteral}{\ \ \ \ \ \ return;}}
\DoxyCodeLine{01276\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01277\ \textcolor{stringliteral}{\ \ \ \ increment\_slow();}}
\DoxyCodeLine{01278\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01279\ \textcolor{stringliteral}{\ \ void\ increment\_slow();}}
\DoxyCodeLine{01280\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01281\ \textcolor{stringliteral}{\ \ void\ decrement()\ \{}}
\DoxyCodeLine{01282\ \textcolor{stringliteral}{\ \ \ \ assert\_valid\_generation(node\_);}}
\DoxyCodeLine{01283\ \textcolor{stringliteral}{\ \ \ \ if\ (node\_-\/>is\_leaf()\ \&\&\ -\/-\/position\_\ >=\ node\_-\/>start())\ \{}}
\DoxyCodeLine{01284\ \textcolor{stringliteral}{\ \ \ \ \ \ return;}}
\DoxyCodeLine{01285\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01286\ \textcolor{stringliteral}{\ \ \ \ decrement\_slow();}}
\DoxyCodeLine{01287\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01288\ \textcolor{stringliteral}{\ \ void\ decrement\_slow();}}
\DoxyCodeLine{01289\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01290\ \textcolor{stringliteral}{\ \ const\ key\_type\ \&key()\ const\ \{}}
\DoxyCodeLine{01291\ \textcolor{stringliteral}{\ \ \ \ return\ node\_-\/>key(static\_cast<size\_type>(position\_));}}
\DoxyCodeLine{01292\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01293\ \textcolor{stringliteral}{\ \ decltype(std::declval<Node\ *>()-\/>slot(0))\ slot()\ \{}}
\DoxyCodeLine{01294\ \textcolor{stringliteral}{\ \ \ \ return\ node\_-\/>slot(static\_cast<size\_type>(position\_));}}
\DoxyCodeLine{01295\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01296\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01297\ \textcolor{stringliteral}{\ \ void\ update\_generation()\ \{}}
\DoxyCodeLine{01298\ \textcolor{stringliteral}{\ \ \ \ btree\_iterator\_generation\_info::update\_generation(node\_);}}
\DoxyCodeLine{01299\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01300\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01301\ \textcolor{stringliteral}{\ \ //\ The\ node\ in\ the\ tree\ the\ iterator\ is\ pointing\ at.}}
\DoxyCodeLine{01302\ \textcolor{stringliteral}{\ \ Node\ *node\_;}}
\DoxyCodeLine{01303\ \textcolor{stringliteral}{\ \ //\ The\ position\ within\ the\ node\ of\ the\ tree\ the\ iterator\ is\ pointing\ at.}}
\DoxyCodeLine{01304\ \textcolor{stringliteral}{\ \ //\ NOTE:\ this\ is\ an\ int\ rather\ than\ a\ field\_type\ because\ iterators\ can\ point}}
\DoxyCodeLine{01305\ \textcolor{stringliteral}{\ \ //\ to\ invalid\ positions\ (such\ as\ -\/1)\ in\ certain\ circumstances.}}
\DoxyCodeLine{01306\ \textcolor{stringliteral}{\ \ int\ position\_;}}
\DoxyCodeLine{01307\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{01308\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01309\ \textcolor{stringliteral}{template\ <typename\ Params>}}
\DoxyCodeLine{01310\ \textcolor{stringliteral}{class\ btree\ \{}}
\DoxyCodeLine{01311\ \textcolor{stringliteral}{\ \ using\ node\_type\ =\ btree\_node<Params>;}}
\DoxyCodeLine{01312\ \textcolor{stringliteral}{\ \ using\ is\_key\_compare\_to\ =\ typename\ Params::is\_key\_compare\_to;}}
\DoxyCodeLine{01313\ \textcolor{stringliteral}{\ \ using\ field\_type\ =\ typename\ node\_type::field\_type;}}
\DoxyCodeLine{01314\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01315\ \textcolor{stringliteral}{\ \ //\ We\ use\ a\ static\ empty\ node\ for\ the\ root/leftmost/rightmost\ of\ empty\ btrees}}
\DoxyCodeLine{01316\ \textcolor{stringliteral}{\ \ //\ in\ order\ to\ avoid\ branching\ in\ begin()/end().}}
\DoxyCodeLine{01317\ \textcolor{stringliteral}{\ \ struct\ EmptyNodeType\ :\ node\_type\ \{}}
\DoxyCodeLine{01318\ \textcolor{stringliteral}{\ \ \ \ using\ field\_type\ =\ typename\ node\_type::field\_type;}}
\DoxyCodeLine{01319\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *parent;}}
\DoxyCodeLine{01320\ \textcolor{stringliteral}{\#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{01321\ \textcolor{stringliteral}{\ \ \ \ uint32\_t\ generation\ =\ 0;}}
\DoxyCodeLine{01322\ \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{01323\ \textcolor{stringliteral}{\ \ \ \ field\_type\ position\ =\ 0;}}
\DoxyCodeLine{01324\ \textcolor{stringliteral}{\ \ \ \ field\_type\ start\ =\ 0;}}
\DoxyCodeLine{01325\ \textcolor{stringliteral}{\ \ \ \ field\_type\ finish\ =\ 0;}}
\DoxyCodeLine{01326\ \textcolor{stringliteral}{\ \ \ \ //\ max\_count\ must\ be\ !=\ kInternalNodeMaxCount\ (so\ that\ this\ node\ is\ regarded}}
\DoxyCodeLine{01327\ \textcolor{stringliteral}{\ \ \ \ //\ as\ a\ leaf\ node).\ max\_count()\ is\ never\ called\ when\ the\ tree\ is\ empty.}}
\DoxyCodeLine{01328\ \textcolor{stringliteral}{\ \ \ \ field\_type\ max\_count\ =\ node\_type::kInternalNodeMaxCount\ +\ 1;}}
\DoxyCodeLine{01329\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01330\ \textcolor{stringliteral}{\ \ \ \ constexpr\ EmptyNodeType()\ :\ parent(this)\ \{\}}}
\DoxyCodeLine{01331\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{01332\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01333\ \textcolor{stringliteral}{\ \ static\ node\_type\ *EmptyNode()\ \{}}
\DoxyCodeLine{01334\ \textcolor{stringliteral}{\ \ \ \ alignas(node\_type::Alignment())\ static\ constexpr\ EmptyNodeType\ empty\_node;}}
\DoxyCodeLine{01335\ \textcolor{stringliteral}{\ \ \ \ return\ const\_cast<EmptyNodeType\ *>(\&empty\_node);}}
\DoxyCodeLine{01336\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01337\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01338\ \textcolor{stringliteral}{\ \ enum\ :\ uint32\_t\ \{}}
\DoxyCodeLine{01339\ \textcolor{stringliteral}{\ \ \ \ kNodeSlots\ =\ node\_type::kNodeSlots,}}
\DoxyCodeLine{01340\ \textcolor{stringliteral}{\ \ \ \ kMinNodeValues\ =\ kNodeSlots\ /\ 2,}}
\DoxyCodeLine{01341\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{01342\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01343\ \textcolor{stringliteral}{\ \ struct\ node\_stats\ \{}}
\DoxyCodeLine{01344\ \textcolor{stringliteral}{\ \ \ \ using\ size\_type\ =\ typename\ Params::size\_type;}}
\DoxyCodeLine{01345\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01346\ \textcolor{stringliteral}{\ \ \ \ node\_stats(size\_type\ l,\ size\_type\ i)\ :\ leaf\_nodes(l),\ internal\_nodes(i)\ \{\}}}
\DoxyCodeLine{01347\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01348\ \textcolor{stringliteral}{\ \ \ \ node\_stats\ \&operator+=(const\ node\_stats\ \&other)\ \{}}
\DoxyCodeLine{01349\ \textcolor{stringliteral}{\ \ \ \ \ \ leaf\_nodes\ +=\ other.leaf\_nodes;}}
\DoxyCodeLine{01350\ \textcolor{stringliteral}{\ \ \ \ \ \ internal\_nodes\ +=\ other.internal\_nodes;}}
\DoxyCodeLine{01351\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ *this;}}
\DoxyCodeLine{01352\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01353\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01354\ \textcolor{stringliteral}{\ \ \ \ size\_type\ leaf\_nodes;}}
\DoxyCodeLine{01355\ \textcolor{stringliteral}{\ \ \ \ size\_type\ internal\_nodes;}}
\DoxyCodeLine{01356\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{01357\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01358\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{01359\ \textcolor{stringliteral}{\ \ using\ key\_type\ =\ typename\ Params::key\_type;}}
\DoxyCodeLine{01360\ \textcolor{stringliteral}{\ \ using\ value\_type\ =\ typename\ Params::value\_type;}}
\DoxyCodeLine{01361\ \textcolor{stringliteral}{\ \ using\ size\_type\ =\ typename\ Params::size\_type;}}
\DoxyCodeLine{01362\ \textcolor{stringliteral}{\ \ using\ difference\_type\ =\ typename\ Params::difference\_type;}}
\DoxyCodeLine{01363\ \textcolor{stringliteral}{\ \ using\ key\_compare\ =\ typename\ Params::key\_compare;}}
\DoxyCodeLine{01364\ \textcolor{stringliteral}{\ \ using\ original\_key\_compare\ =\ typename\ Params::original\_key\_compare;}}
\DoxyCodeLine{01365\ \textcolor{stringliteral}{\ \ using\ value\_compare\ =\ typename\ Params::value\_compare;}}
\DoxyCodeLine{01366\ \textcolor{stringliteral}{\ \ using\ allocator\_type\ =\ typename\ Params::allocator\_type;}}
\DoxyCodeLine{01367\ \textcolor{stringliteral}{\ \ using\ reference\ =\ typename\ Params::reference;}}
\DoxyCodeLine{01368\ \textcolor{stringliteral}{\ \ using\ const\_reference\ =\ typename\ Params::const\_reference;}}
\DoxyCodeLine{01369\ \textcolor{stringliteral}{\ \ using\ pointer\ =\ typename\ Params::pointer;}}
\DoxyCodeLine{01370\ \textcolor{stringliteral}{\ \ using\ const\_pointer\ =\ typename\ Params::const\_pointer;}}
\DoxyCodeLine{01371\ \textcolor{stringliteral}{\ \ using\ iterator\ =}}
\DoxyCodeLine{01372\ \textcolor{stringliteral}{\ \ \ \ \ \ typename\ btree\_iterator<node\_type,\ reference,\ pointer>::iterator;}}
\DoxyCodeLine{01373\ \textcolor{stringliteral}{\ \ using\ const\_iterator\ =\ typename\ iterator::const\_iterator;}}
\DoxyCodeLine{01374\ \textcolor{stringliteral}{\ \ using\ reverse\_iterator\ =\ std::reverse\_iterator<iterator>;}}
\DoxyCodeLine{01375\ \textcolor{stringliteral}{\ \ using\ const\_reverse\_iterator\ =\ std::reverse\_iterator<const\_iterator>;}}
\DoxyCodeLine{01376\ \textcolor{stringliteral}{\ \ using\ node\_handle\_type\ =\ node\_handle<Params,\ Params,\ allocator\_type>;}}
\DoxyCodeLine{01377\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01378\ \textcolor{stringliteral}{\ \ //\ Internal\ types\ made\ public\ for\ use\ by\ btree\_container\ types.}}
\DoxyCodeLine{01379\ \textcolor{stringliteral}{\ \ using\ params\_type\ =\ Params;}}
\DoxyCodeLine{01380\ \textcolor{stringliteral}{\ \ using\ slot\_type\ =\ typename\ Params::slot\_type;}}
\DoxyCodeLine{01381\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01382\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{01383\ \textcolor{stringliteral}{\ \ //\ Copies\ or\ moves\ (depending\ on\ the\ template\ parameter)\ the\ values\ in}}
\DoxyCodeLine{01384\ \textcolor{stringliteral}{\ \ //\ other\ into\ this\ btree\ in\ their\ order\ in\ other.\ This\ btree\ must\ be\ empty}}
\DoxyCodeLine{01385\ \textcolor{stringliteral}{\ \ //\ before\ this\ method\ is\ called.\ This\ method\ is\ used\ in\ copy\ construction,}}
\DoxyCodeLine{01386\ \textcolor{stringliteral}{\ \ //\ copy\ assignment,\ and\ move\ assignment.}}
\DoxyCodeLine{01387\ \textcolor{stringliteral}{\ \ template\ <typename\ Btree>}}
\DoxyCodeLine{01388\ \textcolor{stringliteral}{\ \ void\ copy\_or\_move\_values\_in\_order(Btree\ \&other);}}
\DoxyCodeLine{01389\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01390\ \textcolor{stringliteral}{\ \ //\ Validates\ that\ various\ assumptions/requirements\ are\ true\ at\ compile\ time.}}
\DoxyCodeLine{01391\ \textcolor{stringliteral}{\ \ constexpr\ static\ bool\ static\_assert\_validation();}}
\DoxyCodeLine{01392\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01393\ \textcolor{stringliteral}{\ public:}}
\DoxyCodeLine{01394\ \textcolor{stringliteral}{\ \ btree(const\ key\_compare\ \&comp,\ const\ allocator\_type\ \&alloc)}}
\DoxyCodeLine{01395\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ root\_(EmptyNode()),\ rightmost\_(comp,\ alloc,\ EmptyNode()),\ size\_(0)\ \{\}}}
\DoxyCodeLine{01396\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01397\ \textcolor{stringliteral}{\ \ btree(const\ btree\ \&other)\ :\ btree(other,\ other.allocator())\ \{\}}}
\DoxyCodeLine{01398\ \textcolor{stringliteral}{\ \ btree(const\ btree\ \&other,\ const\ allocator\_type\ \&alloc)}}
\DoxyCodeLine{01399\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ btree(other.key\_comp(),\ alloc)\ \{}}
\DoxyCodeLine{01400\ \textcolor{stringliteral}{\ \ \ \ copy\_or\_move\_values\_in\_order(other);}}
\DoxyCodeLine{01401\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01402\ \textcolor{stringliteral}{\ \ btree(btree\ \&\&other)\ noexcept}}
\DoxyCodeLine{01403\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ root\_(std::exchange(other.root\_,\ EmptyNode())),}}
\DoxyCodeLine{01404\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ rightmost\_(std::move(other.rightmost\_)),}}
\DoxyCodeLine{01405\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ size\_(std::exchange(other.size\_,\ 0u))\ \{}}
\DoxyCodeLine{01406\ \textcolor{stringliteral}{\ \ \ \ other.mutable\_rightmost()\ =\ EmptyNode();}}
\DoxyCodeLine{01407\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01408\ \textcolor{stringliteral}{\ \ btree(btree\ \&\&other,\ const\ allocator\_type\ \&alloc)}}
\DoxyCodeLine{01409\ \textcolor{stringliteral}{\ \ \ \ \ \ :\ btree(other.key\_comp(),\ alloc)\ \{}}
\DoxyCodeLine{01410\ \textcolor{stringliteral}{\ \ \ \ if\ (alloc\ ==\ other.allocator())\ \{}}
\DoxyCodeLine{01411\ \textcolor{stringliteral}{\ \ \ \ \ \ swap(other);}}
\DoxyCodeLine{01412\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{01413\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Move\ values\ from\ \`{}other`\ one\ at\ a\ time\ when\ allocators\ are\ different.}}
\DoxyCodeLine{01414\ \textcolor{stringliteral}{\ \ \ \ \ \ copy\_or\_move\_values\_in\_order(other);}}
\DoxyCodeLine{01415\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01416\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01417\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01418\ \textcolor{stringliteral}{\ \ \string~btree()\ \{}}
\DoxyCodeLine{01419\ \textcolor{stringliteral}{\ \ \ \ //\ Put\ static\_asserts\ in\ destructor\ to\ avoid\ triggering\ them\ before\ the\ type}}
\DoxyCodeLine{01420\ \textcolor{stringliteral}{\ \ \ \ //\ is\ complete.}}
\DoxyCodeLine{01421\ \textcolor{stringliteral}{\ \ \ \ static\_assert(static\_assert\_validation(),\ "{}}This\ call\ must\ be\ elided.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{01422\ \textcolor{stringliteral}{\ \ \ \ clear();}}
\DoxyCodeLine{01423\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01424\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01425\ \textcolor{stringliteral}{\ \ //\ Assign\ the\ contents\ of\ other\ to\ *this.}}
\DoxyCodeLine{01426\ \textcolor{stringliteral}{\ \ btree\ \&operator=(const\ btree\ \&other);}}
\DoxyCodeLine{01427\ \textcolor{stringliteral}{\ \ btree\ \&operator=(btree\ \&\&other)\ noexcept;}}
\DoxyCodeLine{01428\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01429\ \textcolor{stringliteral}{\ \ iterator\ begin()\ \{\ return\ iterator(leftmost());\ \}}}
\DoxyCodeLine{01430\ \textcolor{stringliteral}{\ \ const\_iterator\ begin()\ const\ \{\ return\ const\_iterator(leftmost());\ \}}}
\DoxyCodeLine{01431\ \textcolor{stringliteral}{\ \ iterator\ end()\ \{\ return\ iterator(rightmost(),\ rightmost()-\/>finish());\ \}}}
\DoxyCodeLine{01432\ \textcolor{stringliteral}{\ \ const\_iterator\ end()\ const\ \{}}
\DoxyCodeLine{01433\ \textcolor{stringliteral}{\ \ \ \ return\ const\_iterator(rightmost(),\ rightmost()-\/>finish());}}
\DoxyCodeLine{01434\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01435\ \textcolor{stringliteral}{\ \ reverse\_iterator\ rbegin()\ \{\ return\ reverse\_iterator(end());\ \}}}
\DoxyCodeLine{01436\ \textcolor{stringliteral}{\ \ const\_reverse\_iterator\ rbegin()\ const\ \{}}
\DoxyCodeLine{01437\ \textcolor{stringliteral}{\ \ \ \ return\ const\_reverse\_iterator(end());}}
\DoxyCodeLine{01438\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01439\ \textcolor{stringliteral}{\ \ reverse\_iterator\ rend()\ \{\ return\ reverse\_iterator(begin());\ \}}}
\DoxyCodeLine{01440\ \textcolor{stringliteral}{\ \ const\_reverse\_iterator\ rend()\ const\ \{}}
\DoxyCodeLine{01441\ \textcolor{stringliteral}{\ \ \ \ return\ const\_reverse\_iterator(begin());}}
\DoxyCodeLine{01442\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01443\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01444\ \textcolor{stringliteral}{\ \ //\ Finds\ the\ first\ element\ whose\ key\ is\ not\ less\ than\ \`{}key`.}}
\DoxyCodeLine{01445\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01446\ \textcolor{stringliteral}{\ \ iterator\ lower\_bound(const\ K\ \&key)\ \{}}
\DoxyCodeLine{01447\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_lower\_bound(key).value);}}
\DoxyCodeLine{01448\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01449\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01450\ \textcolor{stringliteral}{\ \ const\_iterator\ lower\_bound(const\ K\ \&key)\ const\ \{}}
\DoxyCodeLine{01451\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_lower\_bound(key).value);}}
\DoxyCodeLine{01452\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01453\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01454\ \textcolor{stringliteral}{\ \ //\ Finds\ the\ first\ element\ whose\ key\ is\ not\ less\ than\ \`{}key`\ and\ also\ returns}}
\DoxyCodeLine{01455\ \textcolor{stringliteral}{\ \ //\ whether\ that\ element\ is\ equal\ to\ \`{}key`.}}
\DoxyCodeLine{01456\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01457\ \textcolor{stringliteral}{\ \ std::pair<iterator,\ bool>\ lower\_bound\_equal(const\ K\ \&key)\ const;}}
\DoxyCodeLine{01458\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01459\ \textcolor{stringliteral}{\ \ //\ Finds\ the\ first\ element\ whose\ key\ is\ greater\ than\ \`{}key`.}}
\DoxyCodeLine{01460\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01461\ \textcolor{stringliteral}{\ \ iterator\ upper\_bound(const\ K\ \&key)\ \{}}
\DoxyCodeLine{01462\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_upper\_bound(key));}}
\DoxyCodeLine{01463\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01464\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01465\ \textcolor{stringliteral}{\ \ const\_iterator\ upper\_bound(const\ K\ \&key)\ const\ \{}}
\DoxyCodeLine{01466\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_upper\_bound(key));}}
\DoxyCodeLine{01467\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01468\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01469\ \textcolor{stringliteral}{\ \ //\ Finds\ the\ range\ of\ values\ which\ compare\ equal\ to\ key.\ The\ first\ member\ of}}
\DoxyCodeLine{01470\ \textcolor{stringliteral}{\ \ //\ the\ returned\ pair\ is\ equal\ to\ lower\_bound(key).\ The\ second\ member\ of\ the}}
\DoxyCodeLine{01471\ \textcolor{stringliteral}{\ \ //\ pair\ is\ equal\ to\ upper\_bound(key).}}
\DoxyCodeLine{01472\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01473\ \textcolor{stringliteral}{\ \ std::pair<iterator,\ iterator>\ equal\_range(const\ K\ \&key);}}
\DoxyCodeLine{01474\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01475\ \textcolor{stringliteral}{\ \ std::pair<const\_iterator,\ const\_iterator>\ equal\_range(const\ K\ \&key)\ const\ \{}}
\DoxyCodeLine{01476\ \textcolor{stringliteral}{\ \ \ \ return\ const\_cast<btree\ *>(this)-\/>equal\_range(key);}}
\DoxyCodeLine{01477\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01478\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01479\ \textcolor{stringliteral}{\ \ //\ Inserts\ a\ value\ into\ the\ btree\ only\ if\ it\ does\ not\ already\ exist.\ The}}
\DoxyCodeLine{01480\ \textcolor{stringliteral}{\ \ //\ boolean\ return\ value\ indicates\ whether\ insertion\ succeeded\ or\ failed.}}
\DoxyCodeLine{01481\ \textcolor{stringliteral}{\ \ //\ Requirement:\ if\ \`{}key`\ already\ exists\ in\ the\ btree,\ does\ not\ consume\ \`{}args`.}}
\DoxyCodeLine{01482\ \textcolor{stringliteral}{\ \ //\ Requirement:\ \`{}key`\ is\ never\ referenced\ after\ consuming\ \`{}args`.}}
\DoxyCodeLine{01483\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename...\ Args>}}
\DoxyCodeLine{01484\ \textcolor{stringliteral}{\ \ std::pair<iterator,\ bool>\ insert\_unique(const\ K\ \&key,\ Args\ \&\&...args);}}
\DoxyCodeLine{01485\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01486\ \textcolor{stringliteral}{\ \ //\ Inserts\ with\ hint.\ Checks\ to\ see\ if\ the\ value\ should\ be\ placed\ immediately}}
\DoxyCodeLine{01487\ \textcolor{stringliteral}{\ \ //\ before\ \`{}position`\ in\ the\ tree.\ If\ so,\ then\ the\ insertion\ will\ take}}
\DoxyCodeLine{01488\ \textcolor{stringliteral}{\ \ //\ amortized\ constant\ time.\ If\ not,\ the\ insertion\ will\ take\ amortized}}
\DoxyCodeLine{01489\ \textcolor{stringliteral}{\ \ //\ logarithmic\ time\ as\ if\ a\ call\ to\ insert\_unique()\ were\ made.}}
\DoxyCodeLine{01490\ \textcolor{stringliteral}{\ \ //\ Requirement:\ if\ \`{}key`\ already\ exists\ in\ the\ btree,\ does\ not\ consume\ \`{}args`.}}
\DoxyCodeLine{01491\ \textcolor{stringliteral}{\ \ //\ Requirement:\ \`{}key`\ is\ never\ referenced\ after\ consuming\ \`{}args`.}}
\DoxyCodeLine{01492\ \textcolor{stringliteral}{\ \ template\ <typename\ K,\ typename...\ Args>}}
\DoxyCodeLine{01493\ \textcolor{stringliteral}{\ \ std::pair<iterator,\ bool>\ insert\_hint\_unique(iterator\ position,\ const\ K\ \&key,}}
\DoxyCodeLine{01494\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Args\ \&\&...args);}}
\DoxyCodeLine{01495\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01496\ \textcolor{stringliteral}{\ \ //\ Insert\ a\ range\ of\ values\ into\ the\ btree.}}
\DoxyCodeLine{01497\ \textcolor{stringliteral}{\ \ //\ Note:\ the\ first\ overload\ avoids\ constructing\ a\ value\_type\ if\ the\ key}}
\DoxyCodeLine{01498\ \textcolor{stringliteral}{\ \ //\ already\ exists\ in\ the\ btree.}}
\DoxyCodeLine{01499\ \textcolor{stringliteral}{\ \ template\ <typename\ InputIterator,}}
\DoxyCodeLine{01500\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ typename\ =\ decltype(std::declval<const\ key\_compare\ \&>()(}}
\DoxyCodeLine{01501\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ params\_type::key(*std::declval<InputIterator>()),}}
\DoxyCodeLine{01502\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::declval<const\ key\_type\ \&>()))>}}
\DoxyCodeLine{01503\ \textcolor{stringliteral}{\ \ void\ insert\_iterator\_unique(InputIterator\ b,\ InputIterator\ e,\ int);}}
\DoxyCodeLine{01504\ \textcolor{stringliteral}{\ \ //\ We\ need\ the\ second\ overload\ for\ cases\ in\ which\ we\ need\ to\ construct\ a}}
\DoxyCodeLine{01505\ \textcolor{stringliteral}{\ \ //\ value\_type\ in\ order\ to\ compare\ it\ with\ the\ keys\ already\ in\ the\ btree.}}
\DoxyCodeLine{01506\ \textcolor{stringliteral}{\ \ template\ <typename\ InputIterator>}}
\DoxyCodeLine{01507\ \textcolor{stringliteral}{\ \ void\ insert\_iterator\_unique(InputIterator\ b,\ InputIterator\ e,\ char);}}
\DoxyCodeLine{01508\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01509\ \textcolor{stringliteral}{\ \ //\ Inserts\ a\ value\ into\ the\ btree.}}
\DoxyCodeLine{01510\ \textcolor{stringliteral}{\ \ template\ <typename\ ValueType>}}
\DoxyCodeLine{01511\ \textcolor{stringliteral}{\ \ iterator\ insert\_multi(const\ key\_type\ \&key,\ ValueType\ \&\&v);}}
\DoxyCodeLine{01512\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01513\ \textcolor{stringliteral}{\ \ //\ Inserts\ a\ value\ into\ the\ btree.}}
\DoxyCodeLine{01514\ \textcolor{stringliteral}{\ \ template\ <typename\ ValueType>}}
\DoxyCodeLine{01515\ \textcolor{stringliteral}{\ \ iterator\ insert\_multi(ValueType\ \&\&v)\ \{}}
\DoxyCodeLine{01516\ \textcolor{stringliteral}{\ \ \ \ return\ insert\_multi(params\_type::key(v),\ std::forward<ValueType>(v));}}
\DoxyCodeLine{01517\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01518\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01519\ \textcolor{stringliteral}{\ \ //\ Insert\ with\ hint.\ Check\ to\ see\ if\ the\ value\ should\ be\ placed\ immediately}}
\DoxyCodeLine{01520\ \textcolor{stringliteral}{\ \ //\ before\ position\ in\ the\ tree.\ If\ it\ does,\ then\ the\ insertion\ will\ take}}
\DoxyCodeLine{01521\ \textcolor{stringliteral}{\ \ //\ amortized\ constant\ time.\ If\ not,\ the\ insertion\ will\ take\ amortized}}
\DoxyCodeLine{01522\ \textcolor{stringliteral}{\ \ //\ logarithmic\ time\ as\ if\ a\ call\ to\ insert\_multi(v)\ were\ made.}}
\DoxyCodeLine{01523\ \textcolor{stringliteral}{\ \ template\ <typename\ ValueType>}}
\DoxyCodeLine{01524\ \textcolor{stringliteral}{\ \ iterator\ insert\_hint\_multi(iterator\ position,\ ValueType\ \&\&v);}}
\DoxyCodeLine{01525\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01526\ \textcolor{stringliteral}{\ \ //\ Insert\ a\ range\ of\ values\ into\ the\ btree.}}
\DoxyCodeLine{01527\ \textcolor{stringliteral}{\ \ template\ <typename\ InputIterator>}}
\DoxyCodeLine{01528\ \textcolor{stringliteral}{\ \ void\ insert\_iterator\_multi(InputIterator\ b,}}
\DoxyCodeLine{01529\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ InputIterator\ e);}}
\DoxyCodeLine{01530\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01531\ \textcolor{stringliteral}{\ \ //\ Erase\ the\ specified\ iterator\ from\ the\ btree.\ The\ iterator\ must\ be\ valid}}
\DoxyCodeLine{01532\ \textcolor{stringliteral}{\ \ //\ (i.e.\ not\ equal\ to\ end()).\ \ Return\ an\ iterator\ pointing\ to\ the\ node\ after}}
\DoxyCodeLine{01533\ \textcolor{stringliteral}{\ \ //\ the\ one\ that\ was\ erased\ (or\ end()\ if\ none\ exists).}}
\DoxyCodeLine{01534\ \textcolor{stringliteral}{\ \ //\ Requirement:\ does\ not\ read\ the\ value\ at\ \`{}*iter`.}}
\DoxyCodeLine{01535\ \textcolor{stringliteral}{\ \ iterator\ erase(iterator\ iter);}}
\DoxyCodeLine{01536\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01537\ \textcolor{stringliteral}{\ \ //\ Erases\ range.\ Returns\ the\ number\ of\ keys\ erased\ and\ an\ iterator\ pointing}}
\DoxyCodeLine{01538\ \textcolor{stringliteral}{\ \ //\ to\ the\ element\ after\ the\ last\ erased\ element.}}
\DoxyCodeLine{01539\ \textcolor{stringliteral}{\ \ std::pair<size\_type,\ iterator>\ erase\_range(iterator\ begin,\ iterator\ end);}}
\DoxyCodeLine{01540\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01541\ \textcolor{stringliteral}{\ \ //\ Finds\ an\ element\ with\ key\ equivalent\ to\ \`{}key`\ or\ returns\ \`{}end()`\ if\ \`{}key`}}
\DoxyCodeLine{01542\ \textcolor{stringliteral}{\ \ //\ is\ not\ present.}}
\DoxyCodeLine{01543\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01544\ \textcolor{stringliteral}{\ \ iterator\ find(const\ K\ \&key)\ \{}}
\DoxyCodeLine{01545\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_find(key));}}
\DoxyCodeLine{01546\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01547\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01548\ \textcolor{stringliteral}{\ \ const\_iterator\ find(const\ K\ \&key)\ const\ \{}}
\DoxyCodeLine{01549\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_end(internal\_find(key));}}
\DoxyCodeLine{01550\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01551\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01552\ \textcolor{stringliteral}{\ \ //\ Clear\ the\ btree,\ deleting\ all\ of\ the\ values\ it\ contains.}}
\DoxyCodeLine{01553\ \textcolor{stringliteral}{\ \ void\ clear();}}
\DoxyCodeLine{01554\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01555\ \textcolor{stringliteral}{\ \ //\ Swaps\ the\ contents\ of\ \`{}this`\ and\ \`{}other`.}}
\DoxyCodeLine{01556\ \textcolor{stringliteral}{\ \ void\ swap(btree\ \&other);}}
\DoxyCodeLine{01557\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01558\ \textcolor{stringliteral}{\ \ const\ key\_compare\ \&key\_comp()\ const\ noexcept\ \{}}
\DoxyCodeLine{01559\ \textcolor{stringliteral}{\ \ \ \ return\ rightmost\_.template\ get<0>();}}
\DoxyCodeLine{01560\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01561\ \textcolor{stringliteral}{\ \ template\ <typename\ K1,\ typename\ K2>}}
\DoxyCodeLine{01562\ \textcolor{stringliteral}{\ \ bool\ compare\_keys(const\ K1\ \&a,\ const\ K2\ \&b)\ const\ \{}}
\DoxyCodeLine{01563\ \textcolor{stringliteral}{\ \ \ \ return\ compare\_internal::compare\_result\_as\_less\_than(key\_comp()(a,\ b));}}
\DoxyCodeLine{01564\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01565\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01566\ \textcolor{stringliteral}{\ \ value\_compare\ value\_comp()\ const\ \{}}
\DoxyCodeLine{01567\ \textcolor{stringliteral}{\ \ \ \ return\ value\_compare(original\_key\_compare(key\_comp()));}}
\DoxyCodeLine{01568\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01569\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01570\ \textcolor{stringliteral}{\ \ //\ Verifies\ the\ structure\ of\ the\ btree.}}
\DoxyCodeLine{01571\ \textcolor{stringliteral}{\ \ void\ verify()\ const;}}
\DoxyCodeLine{01572\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01573\ \textcolor{stringliteral}{\ \ //\ Size\ routines.}}
\DoxyCodeLine{01574\ \textcolor{stringliteral}{\ \ size\_type\ size()\ const\ \{\ return\ size\_;\ \}}}
\DoxyCodeLine{01575\ \textcolor{stringliteral}{\ \ size\_type\ max\_size()\ const\ \{\ return\ (std::numeric\_limits<size\_type>::max)();\ \}}}
\DoxyCodeLine{01576\ \textcolor{stringliteral}{\ \ bool\ empty()\ const\ \{\ return\ size\_\ ==\ 0;\ \}}}
\DoxyCodeLine{01577\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01578\ \textcolor{stringliteral}{\ \ //\ The\ height\ of\ the\ btree.\ An\ empty\ tree\ will\ have\ height\ 0.}}
\DoxyCodeLine{01579\ \textcolor{stringliteral}{\ \ size\_type\ height()\ const\ \{}}
\DoxyCodeLine{01580\ \textcolor{stringliteral}{\ \ \ \ size\_type\ h\ =\ 0;}}
\DoxyCodeLine{01581\ \textcolor{stringliteral}{\ \ \ \ if\ (!empty())\ \{}}
\DoxyCodeLine{01582\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Count\ the\ length\ of\ the\ chain\ from\ the\ leftmost\ node\ up\ to\ the}}
\DoxyCodeLine{01583\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ root.\ We\ actually\ count\ from\ the\ root\ back\ around\ to\ the\ level\ below}}
\DoxyCodeLine{01584\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ the\ root,\ but\ the\ calculation\ is\ the\ same\ because\ of\ the\ circularity}}
\DoxyCodeLine{01585\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ of\ that\ traversal.}}
\DoxyCodeLine{01586\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ node\_type\ *n\ =\ root();}}
\DoxyCodeLine{01587\ \textcolor{stringliteral}{\ \ \ \ \ \ do\ \{}}
\DoxyCodeLine{01588\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ ++h;}}
\DoxyCodeLine{01589\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ n\ =\ n-\/>parent();}}
\DoxyCodeLine{01590\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ while\ (n\ !=\ root());}}
\DoxyCodeLine{01591\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01592\ \textcolor{stringliteral}{\ \ \ \ return\ h;}}
\DoxyCodeLine{01593\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01594\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01595\ \textcolor{stringliteral}{\ \ //\ The\ number\ of\ internal,\ leaf\ and\ total\ nodes\ used\ by\ the\ btree.}}
\DoxyCodeLine{01596\ \textcolor{stringliteral}{\ \ size\_type\ leaf\_nodes()\ const\ \{\ return\ internal\_stats(root()).leaf\_nodes;\ \}}}
\DoxyCodeLine{01597\ \textcolor{stringliteral}{\ \ size\_type\ internal\_nodes()\ const\ \{}}
\DoxyCodeLine{01598\ \textcolor{stringliteral}{\ \ \ \ return\ internal\_stats(root()).internal\_nodes;}}
\DoxyCodeLine{01599\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01600\ \textcolor{stringliteral}{\ \ size\_type\ nodes()\ const\ \{}}
\DoxyCodeLine{01601\ \textcolor{stringliteral}{\ \ \ \ node\_stats\ stats\ =\ internal\_stats(root());}}
\DoxyCodeLine{01602\ \textcolor{stringliteral}{\ \ \ \ return\ stats.leaf\_nodes\ +\ stats.internal\_nodes;}}
\DoxyCodeLine{01603\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01604\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01605\ \textcolor{stringliteral}{\ \ //\ The\ total\ number\ of\ bytes\ used\ by\ the\ btree.}}
\DoxyCodeLine{01606\ \textcolor{stringliteral}{\ \ //\ TODO(b/169338300):\ update\ to\ support\ node\_btree\_*.}}
\DoxyCodeLine{01607\ \textcolor{stringliteral}{\ \ size\_type\ bytes\_used()\ const\ \{}}
\DoxyCodeLine{01608\ \textcolor{stringliteral}{\ \ \ \ node\_stats\ stats\ =\ internal\_stats(root());}}
\DoxyCodeLine{01609\ \textcolor{stringliteral}{\ \ \ \ if\ (stats.leaf\_nodes\ ==\ 1\ \&\&\ stats.internal\_nodes\ ==\ 0)\ \{}}
\DoxyCodeLine{01610\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ sizeof(*this)\ +\ node\_type::LeafSize(root()-\/>max\_count());}}
\DoxyCodeLine{01611\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{01612\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ sizeof(*this)\ +\ stats.leaf\_nodes\ *\ node\_type::LeafSize()\ +}}
\DoxyCodeLine{01613\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ stats.internal\_nodes\ *\ node\_type::InternalSize();}}
\DoxyCodeLine{01614\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01615\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01616\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01617\ \textcolor{stringliteral}{\ \ //\ The\ average\ number\ of\ bytes\ used\ per\ value\ stored\ in\ the\ btree\ assuming}}
\DoxyCodeLine{01618\ \textcolor{stringliteral}{\ \ //\ random\ insertion\ order.}}
\DoxyCodeLine{01619\ \textcolor{stringliteral}{\ \ static\ double\ average\_bytes\_per\_value()\ \{}}
\DoxyCodeLine{01620\ \textcolor{stringliteral}{\ \ \ \ //\ The\ expected\ number\ of\ values\ per\ node\ with\ random\ insertion\ order\ is\ the}}
\DoxyCodeLine{01621\ \textcolor{stringliteral}{\ \ \ \ //\ average\ of\ the\ maximum\ and\ minimum\ numbers\ of\ values\ per\ node.}}
\DoxyCodeLine{01622\ \textcolor{stringliteral}{\ \ \ \ const\ double\ expected\_values\_per\_node\ =\ (kNodeSlots\ +\ kMinNodeValues)\ /\ 2.0;}}
\DoxyCodeLine{01623\ \textcolor{stringliteral}{\ \ \ \ return\ node\_type::LeafSize()\ /\ expected\_values\_per\_node;}}
\DoxyCodeLine{01624\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01625\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01626\ \textcolor{stringliteral}{\ \ //\ The\ fullness\ of\ the\ btree.\ Computed\ as\ the\ number\ of\ elements\ in\ the\ btree}}
\DoxyCodeLine{01627\ \textcolor{stringliteral}{\ \ //\ divided\ by\ the\ maximum\ number\ of\ elements\ a\ tree\ with\ the\ current\ number}}
\DoxyCodeLine{01628\ \textcolor{stringliteral}{\ \ //\ of\ nodes\ could\ hold.\ A\ value\ of\ 1\ indicates\ perfect\ space}}
\DoxyCodeLine{01629\ \textcolor{stringliteral}{\ \ //\ utilization.\ Smaller\ values\ indicate\ space\ wastage.}}
\DoxyCodeLine{01630\ \textcolor{stringliteral}{\ \ //\ Returns\ 0\ for\ empty\ trees.}}
\DoxyCodeLine{01631\ \textcolor{stringliteral}{\ \ double\ fullness()\ const\ \{}}
\DoxyCodeLine{01632\ \textcolor{stringliteral}{\ \ \ \ if\ (empty())\ return\ 0.0;}}
\DoxyCodeLine{01633\ \textcolor{stringliteral}{\ \ \ \ return\ static\_cast<double>(size())\ /\ (nodes()\ *\ kNodeSlots);}}
\DoxyCodeLine{01634\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01635\ \textcolor{stringliteral}{\ \ //\ The\ overhead\ of\ the\ btree\ structure\ in\ bytes\ per\ node.\ Computed\ as\ the}}
\DoxyCodeLine{01636\ \textcolor{stringliteral}{\ \ //\ total\ number\ of\ bytes\ used\ by\ the\ btree\ minus\ the\ number\ of\ bytes\ used\ for}}
\DoxyCodeLine{01637\ \textcolor{stringliteral}{\ \ //\ storing\ elements\ divided\ by\ the\ number\ of\ elements.}}
\DoxyCodeLine{01638\ \textcolor{stringliteral}{\ \ //\ Returns\ 0\ for\ empty\ trees.}}
\DoxyCodeLine{01639\ \textcolor{stringliteral}{\ \ double\ overhead()\ const\ \{}}
\DoxyCodeLine{01640\ \textcolor{stringliteral}{\ \ \ \ if\ (empty())\ return\ 0.0;}}
\DoxyCodeLine{01641\ \textcolor{stringliteral}{\ \ \ \ return\ (bytes\_used()\ -\/\ size()\ *\ sizeof(value\_type))\ /}}
\DoxyCodeLine{01642\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ static\_cast<double>(size());}}
\DoxyCodeLine{01643\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01644\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01645\ \textcolor{stringliteral}{\ \ //\ The\ allocator\ used\ by\ the\ btree.}}
\DoxyCodeLine{01646\ \textcolor{stringliteral}{\ \ allocator\_type\ get\_allocator()\ const\ \{\ return\ allocator();\ \}}}
\DoxyCodeLine{01647\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01648\ \textcolor{stringliteral}{\ private:}}
\DoxyCodeLine{01649\ \textcolor{stringliteral}{\ \ friend\ struct\ btree\_access;}}
\DoxyCodeLine{01650\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01651\ \textcolor{stringliteral}{\ \ //\ Internal\ accessor\ routines.}}
\DoxyCodeLine{01652\ \textcolor{stringliteral}{\ \ node\_type\ *root()\ \{\ return\ root\_;\ \}}}
\DoxyCodeLine{01653\ \textcolor{stringliteral}{\ \ const\ node\_type\ *root()\ const\ \{\ return\ root\_;\ \}}}
\DoxyCodeLine{01654\ \textcolor{stringliteral}{\ \ node\_type\ *\&mutable\_root()\ noexcept\ \{\ return\ root\_;\ \}}}
\DoxyCodeLine{01655\ \textcolor{stringliteral}{\ \ node\_type\ *rightmost()\ \{\ return\ rightmost\_.template\ get<2>();\ \}}}
\DoxyCodeLine{01656\ \textcolor{stringliteral}{\ \ const\ node\_type\ *rightmost()\ const\ \{\ return\ rightmost\_.template\ get<2>();\ \}}}
\DoxyCodeLine{01657\ \textcolor{stringliteral}{\ \ node\_type\ *\&mutable\_rightmost()\ noexcept\ \{}}
\DoxyCodeLine{01658\ \textcolor{stringliteral}{\ \ \ \ return\ rightmost\_.template\ get<2>();}}
\DoxyCodeLine{01659\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01660\ \textcolor{stringliteral}{\ \ key\_compare\ *mutable\_key\_comp()\ noexcept\ \{}}
\DoxyCodeLine{01661\ \textcolor{stringliteral}{\ \ \ \ return\ \&rightmost\_.template\ get<0>();}}
\DoxyCodeLine{01662\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01663\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01664\ \textcolor{stringliteral}{\ \ //\ The\ leftmost\ node\ is\ stored\ as\ the\ parent\ of\ the\ root\ node.}}
\DoxyCodeLine{01665\ \textcolor{stringliteral}{\ \ node\_type\ *leftmost()\ \{\ return\ root()-\/>parent();\ \}}}
\DoxyCodeLine{01666\ \textcolor{stringliteral}{\ \ const\ node\_type\ *leftmost()\ const\ \{\ return\ root()-\/>parent();\ \}}}
\DoxyCodeLine{01667\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01668\ \textcolor{stringliteral}{\ \ //\ Allocator\ routines.}}
\DoxyCodeLine{01669\ \textcolor{stringliteral}{\ \ allocator\_type\ *mutable\_allocator()\ noexcept\ \{}}
\DoxyCodeLine{01670\ \textcolor{stringliteral}{\ \ \ \ return\ \&rightmost\_.template\ get<1>();}}
\DoxyCodeLine{01671\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01672\ \textcolor{stringliteral}{\ \ const\ allocator\_type\ \&allocator()\ const\ noexcept\ \{}}
\DoxyCodeLine{01673\ \textcolor{stringliteral}{\ \ \ \ return\ rightmost\_.template\ get<1>();}}
\DoxyCodeLine{01674\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01675\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01676\ \textcolor{stringliteral}{\ \ //\ Allocates\ a\ correctly\ aligned\ node\ of\ at\ least\ size\ bytes\ using\ the}}
\DoxyCodeLine{01677\ \textcolor{stringliteral}{\ \ //\ allocator.}}
\DoxyCodeLine{01678\ \textcolor{stringliteral}{\ \ node\_type\ *allocate(size\_type\ size)\ \{}}
\DoxyCodeLine{01679\ \textcolor{stringliteral}{\ \ \ \ return\ reinterpret\_cast<node\_type\ *>(}}
\DoxyCodeLine{01680\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ absl::container\_internal::Allocate<node\_type::Alignment()>(}}
\DoxyCodeLine{01681\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ mutable\_allocator(),\ size));}}
\DoxyCodeLine{01682\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01683\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01684\ \textcolor{stringliteral}{\ \ //\ Node\ creation/deletion\ routines.}}
\DoxyCodeLine{01685\ \textcolor{stringliteral}{\ \ node\_type\ *new\_internal\_node(field\_type\ position,\ node\_type\ *parent)\ \{}}
\DoxyCodeLine{01686\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *n\ =\ allocate(node\_type::InternalSize());}}
\DoxyCodeLine{01687\ \textcolor{stringliteral}{\ \ \ \ n-\/>init\_internal(position,\ parent);}}
\DoxyCodeLine{01688\ \textcolor{stringliteral}{\ \ \ \ return\ n;}}
\DoxyCodeLine{01689\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01690\ \textcolor{stringliteral}{\ \ node\_type\ *new\_leaf\_node(field\_type\ position,\ node\_type\ *parent)\ \{}}
\DoxyCodeLine{01691\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *n\ =\ allocate(node\_type::LeafSize());}}
\DoxyCodeLine{01692\ \textcolor{stringliteral}{\ \ \ \ n-\/>init\_leaf(position,\ kNodeSlots,\ parent);}}
\DoxyCodeLine{01693\ \textcolor{stringliteral}{\ \ \ \ return\ n;}}
\DoxyCodeLine{01694\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01695\ \textcolor{stringliteral}{\ \ node\_type\ *new\_leaf\_root\_node(field\_type\ max\_count)\ \{}}
\DoxyCodeLine{01696\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *n\ =\ allocate(node\_type::LeafSize(max\_count));}}
\DoxyCodeLine{01697\ \textcolor{stringliteral}{\ \ \ \ n-\/>init\_leaf(/*position=*/0,\ max\_count,\ /*parent=*/n);}}
\DoxyCodeLine{01698\ \textcolor{stringliteral}{\ \ \ \ return\ n;}}
\DoxyCodeLine{01699\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01700\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01701\ \textcolor{stringliteral}{\ \ //\ Deletion\ helper\ routines.}}
\DoxyCodeLine{01702\ \textcolor{stringliteral}{\ \ iterator\ rebalance\_after\_delete(iterator\ iter);}}
\DoxyCodeLine{01703\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01704\ \textcolor{stringliteral}{\ \ //\ Rebalances\ or\ splits\ the\ node\ iter\ points\ to.}}
\DoxyCodeLine{01705\ \textcolor{stringliteral}{\ \ void\ rebalance\_or\_split(iterator\ *iter);}}
\DoxyCodeLine{01706\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01707\ \textcolor{stringliteral}{\ \ //\ Merges\ the\ values\ of\ left,\ right\ and\ the\ delimiting\ key\ on\ their\ parent}}
\DoxyCodeLine{01708\ \textcolor{stringliteral}{\ \ //\ onto\ left,\ removing\ the\ delimiting\ key\ and\ deleting\ right.}}
\DoxyCodeLine{01709\ \textcolor{stringliteral}{\ \ void\ merge\_nodes(node\_type\ *left,\ node\_type\ *right);}}
\DoxyCodeLine{01710\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01711\ \textcolor{stringliteral}{\ \ //\ Tries\ to\ merge\ node\ with\ its\ left\ or\ right\ sibling,\ and\ failing\ that,}}
\DoxyCodeLine{01712\ \textcolor{stringliteral}{\ \ //\ rebalance\ with\ its\ left\ or\ right\ sibling.\ Returns\ true\ if\ a\ merge}}
\DoxyCodeLine{01713\ \textcolor{stringliteral}{\ \ //\ occurred,\ at\ which\ point\ it\ is\ no\ longer\ valid\ to\ access\ node.\ Returns}}
\DoxyCodeLine{01714\ \textcolor{stringliteral}{\ \ //\ false\ if\ no\ merging\ took\ place.}}
\DoxyCodeLine{01715\ \textcolor{stringliteral}{\ \ bool\ try\_merge\_or\_rebalance(iterator\ *iter);}}
\DoxyCodeLine{01716\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01717\ \textcolor{stringliteral}{\ \ //\ Tries\ to\ shrink\ the\ height\ of\ the\ tree\ by\ 1.}}
\DoxyCodeLine{01718\ \textcolor{stringliteral}{\ \ void\ try\_shrink();}}
\DoxyCodeLine{01719\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01720\ \textcolor{stringliteral}{\ \ iterator\ internal\_end(iterator\ iter)\ \{}}
\DoxyCodeLine{01721\ \textcolor{stringliteral}{\ \ \ \ return\ iter.node\_\ !=\ nullptr\ ?\ iter\ :\ end();}}
\DoxyCodeLine{01722\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01723\ \textcolor{stringliteral}{\ \ const\_iterator\ internal\_end(const\_iterator\ iter)\ const\ \{}}
\DoxyCodeLine{01724\ \textcolor{stringliteral}{\ \ \ \ return\ iter.node\_\ !=\ nullptr\ ?\ iter\ :\ end();}}
\DoxyCodeLine{01725\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01726\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01727\ \textcolor{stringliteral}{\ \ //\ Emplaces\ a\ value\ into\ the\ btree\ immediately\ before\ iter.\ Requires\ that}}
\DoxyCodeLine{01728\ \textcolor{stringliteral}{\ \ //\ key(v)\ <=\ iter.key()\ and\ (-\/-\/iter).key()\ <=\ key(v).}}
\DoxyCodeLine{01729\ \textcolor{stringliteral}{\ \ template\ <typename...\ Args>}}
\DoxyCodeLine{01730\ \textcolor{stringliteral}{\ \ iterator\ internal\_emplace(iterator\ iter,\ Args\ \&\&...args);}}
\DoxyCodeLine{01731\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01732\ \textcolor{stringliteral}{\ \ //\ Returns\ an\ iterator\ pointing\ to\ the\ first\ value\ >=\ the\ value\ "{}}iter\textcolor{stringliteral}{"{}\ is}}
\DoxyCodeLine{01733\ \textcolor{stringliteral}{\ \ //\ pointing\ at.\ Note\ that\ "{}}iter\textcolor{stringliteral}{"{}\ might\ be\ pointing\ to\ an\ invalid\ location\ such}}
\DoxyCodeLine{01734\ \textcolor{stringliteral}{\ \ //\ as\ iter.position\_\ ==\ iter.node\_-\/>finish().\ This\ routine\ simply\ moves\ iter}}
\DoxyCodeLine{01735\ \textcolor{stringliteral}{\ \ //\ up\ in\ the\ tree\ to\ a\ valid\ location.\ Requires:\ iter.node\_\ is\ non-\/null.}}
\DoxyCodeLine{01736\ \textcolor{stringliteral}{\ \ template\ <typename\ IterType>}}
\DoxyCodeLine{01737\ \textcolor{stringliteral}{\ \ static\ IterType\ internal\_last(IterType\ iter);}}
\DoxyCodeLine{01738\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01739\ \textcolor{stringliteral}{\ \ //\ Returns\ an\ iterator\ pointing\ to\ the\ leaf\ position\ at\ which\ key\ would}}
\DoxyCodeLine{01740\ \textcolor{stringliteral}{\ \ //\ reside\ in\ the\ tree,\ unless\ there\ is\ an\ exact\ match\ -\/\ in\ which\ case,\ the}}
\DoxyCodeLine{01741\ \textcolor{stringliteral}{\ \ //\ result\ may\ not\ be\ on\ a\ leaf.\ When\ there's\ a\ three-\/way\ comparator,\ we\ can}}
\DoxyCodeLine{01742\ \textcolor{stringliteral}{\ \ //\ return\ whether\ there\ was\ an\ exact\ match.\ This\ allows\ the\ caller\ to\ avoid\ a}}
\DoxyCodeLine{01743\ \textcolor{stringliteral}{\ \ //\ subsequent\ comparison\ to\ determine\ if\ an\ exact\ match\ was\ made,\ which\ is}}
\DoxyCodeLine{01744\ \textcolor{stringliteral}{\ \ //\ important\ for\ keys\ with\ expensive\ comparison,\ such\ as\ strings.}}
\DoxyCodeLine{01745\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01746\ \textcolor{stringliteral}{\ \ SearchResult<iterator,\ is\_key\_compare\_to::value>\ internal\_locate(}}
\DoxyCodeLine{01747\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&key)\ const;}}
\DoxyCodeLine{01748\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01749\ \textcolor{stringliteral}{\ \ //\ Internal\ routine\ which\ implements\ lower\_bound().}}
\DoxyCodeLine{01750\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01751\ \textcolor{stringliteral}{\ \ SearchResult<iterator,\ is\_key\_compare\_to::value>\ internal\_lower\_bound(}}
\DoxyCodeLine{01752\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ K\ \&key)\ const;}}
\DoxyCodeLine{01753\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01754\ \textcolor{stringliteral}{\ \ //\ Internal\ routine\ which\ implements\ upper\_bound().}}
\DoxyCodeLine{01755\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01756\ \textcolor{stringliteral}{\ \ iterator\ internal\_upper\_bound(const\ K\ \&key)\ const;}}
\DoxyCodeLine{01757\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01758\ \textcolor{stringliteral}{\ \ //\ Internal\ routine\ which\ implements\ find().}}
\DoxyCodeLine{01759\ \textcolor{stringliteral}{\ \ template\ <typename\ K>}}
\DoxyCodeLine{01760\ \textcolor{stringliteral}{\ \ iterator\ internal\_find(const\ K\ \&key)\ const;}}
\DoxyCodeLine{01761\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01762\ \textcolor{stringliteral}{\ \ //\ Verifies\ the\ tree\ structure\ of\ node.}}
\DoxyCodeLine{01763\ \textcolor{stringliteral}{\ \ size\_type\ internal\_verify(const\ node\_type\ *node,\ const\ key\_type\ *lo,}}
\DoxyCodeLine{01764\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ key\_type\ *hi)\ const;}}
\DoxyCodeLine{01765\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01766\ \textcolor{stringliteral}{\ \ node\_stats\ internal\_stats(const\ node\_type\ *node)\ const\ \{}}
\DoxyCodeLine{01767\ \textcolor{stringliteral}{\ \ \ \ //\ The\ root\ can\ be\ a\ static\ empty\ node.}}
\DoxyCodeLine{01768\ \textcolor{stringliteral}{\ \ \ \ if\ (node\ ==\ nullptr\ ||\ (node\ ==\ root()\ \&\&\ empty()))\ \{}}
\DoxyCodeLine{01769\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ node\_stats(0,\ 0);}}
\DoxyCodeLine{01770\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01771\ \textcolor{stringliteral}{\ \ \ \ if\ (node-\/>is\_leaf())\ \{}}
\DoxyCodeLine{01772\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ node\_stats(1,\ 0);}}
\DoxyCodeLine{01773\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01774\ \textcolor{stringliteral}{\ \ \ \ node\_stats\ res(0,\ 1);}}
\DoxyCodeLine{01775\ \textcolor{stringliteral}{\ \ \ \ for\ (int\ i\ =\ node-\/>start();\ i\ <=\ node-\/>finish();\ ++i)\ \{}}
\DoxyCodeLine{01776\ \textcolor{stringliteral}{\ \ \ \ \ \ res\ +=\ internal\_stats(node-\/>child(i));}}
\DoxyCodeLine{01777\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{01778\ \textcolor{stringliteral}{\ \ \ \ return\ res;}}
\DoxyCodeLine{01779\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{01780\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01781\ \textcolor{stringliteral}{\ \ node\_type\ *root\_;}}
\DoxyCodeLine{01782\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01783\ \textcolor{stringliteral}{\ \ //\ A\ pointer\ to\ the\ rightmost\ node.\ Note\ that\ the\ leftmost\ node\ is\ stored\ as}}
\DoxyCodeLine{01784\ \textcolor{stringliteral}{\ \ //\ the\ root's\ parent.\ We\ use\ compressed\ tuple\ in\ order\ to\ save\ space\ because}}
\DoxyCodeLine{01785\ \textcolor{stringliteral}{\ \ //\ key\_compare\ and\ allocator\_type\ are\ usually\ empty.}}
\DoxyCodeLine{01786\ \textcolor{stringliteral}{\ \ absl::container\_internal::CompressedTuple<key\_compare,\ allocator\_type,}}
\DoxyCodeLine{01787\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node\_type\ *>}}
\DoxyCodeLine{01788\ \textcolor{stringliteral}{\ \ \ \ \ \ rightmost\_;}}
\DoxyCodeLine{01789\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01790\ \textcolor{stringliteral}{\ \ //\ Number\ of\ values.}}
\DoxyCodeLine{01791\ \textcolor{stringliteral}{\ \ size\_type\ size\_;}}
\DoxyCodeLine{01792\ \textcolor{stringliteral}{\};}}
\DoxyCodeLine{01793\ \textcolor{stringliteral}{}}
\DoxyCodeLine{01795\ //\ btree\_node\ methods}
\DoxyCodeLine{01796\ template\ <typename\ P>}
\DoxyCodeLine{01797\ template\ <typename...\ Args>}
\DoxyCodeLine{01798\ inline\ void\ btree\_node<P>::emplace\_value(const\ field\_type\ i,}
\DoxyCodeLine{01799\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc,}
\DoxyCodeLine{01800\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Args\ \&\&...args)\ \{}
\DoxyCodeLine{01801\ \ \ assert(i\ >=\ start());}
\DoxyCodeLine{01802\ \ \ assert(i\ <=\ finish());}
\DoxyCodeLine{01803\ \ \ //\ Shift\ old\ values\ to\ create\ space\ for\ new\ value\ and\ then\ construct\ it\ in}
\DoxyCodeLine{01804\ \ \ //\ place.}
\DoxyCodeLine{01805\ \ \ if\ (i\ <\ finish())\ \{}
\DoxyCodeLine{01806\ \ \ \ \ transfer\_n\_backward(finish()\ -\/\ i,\ /*dest\_i=*/i\ +\ 1,\ /*src\_i=*/i,\ this,}
\DoxyCodeLine{01807\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ alloc);}
\DoxyCodeLine{01808\ \ \ \}}
\DoxyCodeLine{01809\ \ \ value\_init(static\_cast<field\_type>(i),\ alloc,\ std::forward<Args>(args)...);}
\DoxyCodeLine{01810\ \ \ set\_finish(finish()\ +\ 1);}
\DoxyCodeLine{01811\ }
\DoxyCodeLine{01812\ \ \ if\ (is\_internal()\ \&\&\ finish()\ >\ i\ +\ 1)\ \{}
\DoxyCodeLine{01813\ \ \ \ \ for\ (field\_type\ j\ =\ finish();\ j\ >\ i\ +\ 1;\ -\/-\/j)\ \{}
\DoxyCodeLine{01814\ \ \ \ \ \ \ set\_child(j,\ child(j\ -\/\ 1));}
\DoxyCodeLine{01815\ \ \ \ \ \}}
\DoxyCodeLine{01816\ \ \ \ \ clear\_child(i\ +\ 1);}
\DoxyCodeLine{01817\ \ \ \}}
\DoxyCodeLine{01818\ \}}
\DoxyCodeLine{01819\ }
\DoxyCodeLine{01820\ template\ <typename\ P>}
\DoxyCodeLine{01821\ inline\ void\ btree\_node<P>::remove\_values(const\ field\_type\ i,}
\DoxyCodeLine{01822\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ const\ field\_type\ to\_erase,}
\DoxyCodeLine{01823\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{01824\ \ \ //\ Transfer\ values\ after\ the\ removed\ range\ into\ their\ new\ places.}
\DoxyCodeLine{01825\ \ \ value\_destroy\_n(i,\ to\_erase,\ alloc);}
\DoxyCodeLine{01826\ \ \ const\ field\_type\ orig\_finish\ =\ finish();}
\DoxyCodeLine{01827\ \ \ const\ field\_type\ src\_i\ =\ i\ +\ to\_erase;}
\DoxyCodeLine{01828\ \ \ transfer\_n(orig\_finish\ -\/\ src\_i,\ i,\ src\_i,\ this,\ alloc);}
\DoxyCodeLine{01829\ }
\DoxyCodeLine{01830\ \ \ if\ (is\_internal())\ \{}
\DoxyCodeLine{01831\ \ \ \ \ //\ Delete\ all\ children\ between\ begin\ and\ end.}
\DoxyCodeLine{01832\ \ \ \ \ for\ (field\_type\ j\ =\ 0;\ j\ <\ to\_erase;\ ++j)\ \{}
\DoxyCodeLine{01833\ \ \ \ \ \ \ clear\_and\_delete(child(i\ +\ j\ +\ 1),\ alloc);}
\DoxyCodeLine{01834\ \ \ \ \ \}}
\DoxyCodeLine{01835\ \ \ \ \ //\ Rotate\ children\ after\ end\ into\ new\ positions.}
\DoxyCodeLine{01836\ \ \ \ \ for\ (field\_type\ j\ =\ i\ +\ to\_erase\ +\ 1;\ j\ <=\ orig\_finish;\ ++j)\ \{}
\DoxyCodeLine{01837\ \ \ \ \ \ \ set\_child(j\ -\/\ to\_erase,\ child(j));}
\DoxyCodeLine{01838\ \ \ \ \ \ \ clear\_child(j);}
\DoxyCodeLine{01839\ \ \ \ \ \}}
\DoxyCodeLine{01840\ \ \ \}}
\DoxyCodeLine{01841\ \ \ set\_finish(orig\_finish\ -\/\ to\_erase);}
\DoxyCodeLine{01842\ \}}
\DoxyCodeLine{01843\ }
\DoxyCodeLine{01844\ template\ <typename\ P>}
\DoxyCodeLine{01845\ void\ btree\_node<P>::rebalance\_right\_to\_left(field\_type\ to\_move,}
\DoxyCodeLine{01846\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_node\ *right,}
\DoxyCodeLine{01847\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{01848\ \ \ assert(parent()\ ==\ right-\/>parent());}
\DoxyCodeLine{01849\ \ \ assert(position()\ +\ 1\ ==\ right-\/>position());}
\DoxyCodeLine{01850\ \ \ assert(right-\/>count()\ >=\ count());}
\DoxyCodeLine{01851\ \ \ assert(to\_move\ >=\ 1);}
\DoxyCodeLine{01852\ \ \ assert(to\_move\ <=\ right-\/>count());}
\DoxyCodeLine{01853\ }
\DoxyCodeLine{01854\ \ \ //\ 1)\ Move\ the\ delimiting\ value\ in\ the\ parent\ to\ the\ left\ node.}
\DoxyCodeLine{01855\ \ \ transfer(finish(),\ position(),\ parent(),\ alloc);}
\DoxyCodeLine{01856\ }
\DoxyCodeLine{01857\ \ \ //\ 2)\ Move\ the\ (to\_move\ -\/\ 1)\ values\ from\ the\ right\ node\ to\ the\ left\ node.}
\DoxyCodeLine{01858\ \ \ transfer\_n(to\_move\ -\/\ 1,\ finish()\ +\ 1,\ right-\/>start(),\ right,\ alloc);}
\DoxyCodeLine{01859\ }
\DoxyCodeLine{01860\ \ \ //\ 3)\ Move\ the\ new\ delimiting\ value\ to\ the\ parent\ from\ the\ right\ node.}
\DoxyCodeLine{01861\ \ \ parent()-\/>transfer(position(),\ right-\/>start()\ +\ to\_move\ -\/\ 1,\ right,\ alloc);}
\DoxyCodeLine{01862\ }
\DoxyCodeLine{01863\ \ \ //\ 4)\ Shift\ the\ values\ in\ the\ right\ node\ to\ their\ correct\ positions.}
\DoxyCodeLine{01864\ \ \ right-\/>transfer\_n(right-\/>count()\ -\/\ to\_move,\ right-\/>start(),}
\DoxyCodeLine{01865\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ right-\/>start()\ +\ to\_move,\ right,\ alloc);}
\DoxyCodeLine{01866\ }
\DoxyCodeLine{01867\ \ \ if\ (is\_internal())\ \{}
\DoxyCodeLine{01868\ \ \ \ \ //\ Move\ the\ child\ pointers\ from\ the\ right\ to\ the\ left\ node.}
\DoxyCodeLine{01869\ \ \ \ \ for\ (field\_type\ i\ =\ 0;\ i\ <\ to\_move;\ ++i)\ \{}
\DoxyCodeLine{01870\ \ \ \ \ \ \ init\_child(finish()\ +\ i\ +\ 1,\ right-\/>child(i));}
\DoxyCodeLine{01871\ \ \ \ \ \}}
\DoxyCodeLine{01872\ \ \ \ \ for\ (field\_type\ i\ =\ right-\/>start();\ i\ <=\ right-\/>finish()\ -\/\ to\_move;\ ++i)\ \{}
\DoxyCodeLine{01873\ \ \ \ \ \ \ assert(i\ +\ to\_move\ <=\ right-\/>max\_count());}
\DoxyCodeLine{01874\ \ \ \ \ \ \ right-\/>init\_child(i,\ right-\/>child(i\ +\ to\_move));}
\DoxyCodeLine{01875\ \ \ \ \ \ \ right-\/>clear\_child(i\ +\ to\_move);}
\DoxyCodeLine{01876\ \ \ \ \ \}}
\DoxyCodeLine{01877\ \ \ \}}
\DoxyCodeLine{01878\ }
\DoxyCodeLine{01879\ \ \ //\ Fixup\ \`{}finish`\ on\ the\ left\ and\ right\ nodes.}
\DoxyCodeLine{01880\ \ \ set\_finish(finish()\ +\ to\_move);}
\DoxyCodeLine{01881\ \ \ right-\/>set\_finish(right-\/>finish()\ -\/\ to\_move);}
\DoxyCodeLine{01882\ \}}
\DoxyCodeLine{01883\ }
\DoxyCodeLine{01884\ template\ <typename\ P>}
\DoxyCodeLine{01885\ void\ btree\_node<P>::rebalance\_left\_to\_right(field\_type\ to\_move,}
\DoxyCodeLine{01886\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ btree\_node\ *right,}
\DoxyCodeLine{01887\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{01888\ \ \ assert(parent()\ ==\ right-\/>parent());}
\DoxyCodeLine{01889\ \ \ assert(position()\ +\ 1\ ==\ right-\/>position());}
\DoxyCodeLine{01890\ \ \ assert(count()\ >=\ right-\/>count());}
\DoxyCodeLine{01891\ \ \ assert(to\_move\ >=\ 1);}
\DoxyCodeLine{01892\ \ \ assert(to\_move\ <=\ count());}
\DoxyCodeLine{01893\ }
\DoxyCodeLine{01894\ \ \ //\ Values\ in\ the\ right\ node\ are\ shifted\ to\ the\ right\ to\ make\ room\ for\ the}
\DoxyCodeLine{01895\ \ \ //\ new\ to\_move\ values.\ Then,\ the\ delimiting\ value\ in\ the\ parent\ and\ the}
\DoxyCodeLine{01896\ \ \ //\ other\ (to\_move\ -\/\ 1)\ values\ in\ the\ left\ node\ are\ moved\ into\ the\ right\ node.}
\DoxyCodeLine{01897\ \ \ //\ Lastly,\ a\ new\ delimiting\ value\ is\ moved\ from\ the\ left\ node\ into\ the}
\DoxyCodeLine{01898\ \ \ //\ parent,\ and\ the\ remaining\ empty\ left\ node\ entries\ are\ destroyed.}
\DoxyCodeLine{01899\ }
\DoxyCodeLine{01900\ \ \ //\ 1)\ Shift\ existing\ values\ in\ the\ right\ node\ to\ their\ correct\ positions.}
\DoxyCodeLine{01901\ \ \ right-\/>transfer\_n\_backward(right-\/>count(),\ right-\/>start()\ +\ to\_move,}
\DoxyCodeLine{01902\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ right-\/>start(),\ right,\ alloc);}
\DoxyCodeLine{01903\ }
\DoxyCodeLine{01904\ \ \ //\ 2)\ Move\ the\ delimiting\ value\ in\ the\ parent\ to\ the\ right\ node.}
\DoxyCodeLine{01905\ \ \ right-\/>transfer(right-\/>start()\ +\ to\_move\ -\/\ 1,\ position(),\ parent(),\ alloc);}
\DoxyCodeLine{01906\ }
\DoxyCodeLine{01907\ \ \ //\ 3)\ Move\ the\ (to\_move\ -\/\ 1)\ values\ from\ the\ left\ node\ to\ the\ right\ node.}
\DoxyCodeLine{01908\ \ \ right-\/>transfer\_n(to\_move\ -\/\ 1,\ right-\/>start(),\ finish()\ -\/\ (to\_move\ -\/\ 1),\ this,}
\DoxyCodeLine{01909\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ alloc);}
\DoxyCodeLine{01910\ }
\DoxyCodeLine{01911\ \ \ //\ 4)\ Move\ the\ new\ delimiting\ value\ to\ the\ parent\ from\ the\ left\ node.}
\DoxyCodeLine{01912\ \ \ parent()-\/>transfer(position(),\ finish()\ -\/\ to\_move,\ this,\ alloc);}
\DoxyCodeLine{01913\ }
\DoxyCodeLine{01914\ \ \ if\ (is\_internal())\ \{}
\DoxyCodeLine{01915\ \ \ \ \ //\ Move\ the\ child\ pointers\ from\ the\ left\ to\ the\ right\ node.}
\DoxyCodeLine{01916\ \ \ \ \ for\ (field\_type\ i\ =\ right-\/>finish()\ +\ 1;\ i\ >\ right-\/>start();\ -\/-\/i)\ \{}
\DoxyCodeLine{01917\ \ \ \ \ \ \ right-\/>init\_child(i\ -\/\ 1\ +\ to\_move,\ right-\/>child(i\ -\/\ 1));}
\DoxyCodeLine{01918\ \ \ \ \ \ \ right-\/>clear\_child(i\ -\/\ 1);}
\DoxyCodeLine{01919\ \ \ \ \ \}}
\DoxyCodeLine{01920\ \ \ \ \ for\ (field\_type\ i\ =\ 1;\ i\ <=\ to\_move;\ ++i)\ \{}
\DoxyCodeLine{01921\ \ \ \ \ \ \ right-\/>init\_child(i\ -\/\ 1,\ child(finish()\ -\/\ to\_move\ +\ i));}
\DoxyCodeLine{01922\ \ \ \ \ \ \ clear\_child(finish()\ -\/\ to\_move\ +\ i);}
\DoxyCodeLine{01923\ \ \ \ \ \}}
\DoxyCodeLine{01924\ \ \ \}}
\DoxyCodeLine{01925\ }
\DoxyCodeLine{01926\ \ \ //\ Fixup\ the\ counts\ on\ the\ left\ and\ right\ nodes.}
\DoxyCodeLine{01927\ \ \ set\_finish(finish()\ -\/\ to\_move);}
\DoxyCodeLine{01928\ \ \ right-\/>set\_finish(right-\/>finish()\ +\ to\_move);}
\DoxyCodeLine{01929\ \}}
\DoxyCodeLine{01930\ }
\DoxyCodeLine{01931\ template\ <typename\ P>}
\DoxyCodeLine{01932\ void\ btree\_node<P>::split(const\ int\ insert\_position,\ btree\_node\ *dest,}
\DoxyCodeLine{01933\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{01934\ \ \ assert(dest-\/>count()\ ==\ 0);}
\DoxyCodeLine{01935\ \ \ assert(max\_count()\ ==\ kNodeSlots);}
\DoxyCodeLine{01936\ \ \ assert(position()\ +\ 1\ ==\ dest-\/>position());}
\DoxyCodeLine{01937\ \ \ assert(parent()\ ==\ dest-\/>parent());}
\DoxyCodeLine{01938\ }
\DoxyCodeLine{01939\ \ \ //\ We\ bias\ the\ split\ based\ on\ the\ position\ being\ inserted.\ If\ we're}
\DoxyCodeLine{01940\ \ \ //\ inserting\ at\ the\ beginning\ of\ the\ left\ node\ then\ bias\ the\ split\ to\ put}
\DoxyCodeLine{01941\ \ \ //\ more\ values\ on\ the\ right\ node.\ If\ we're\ inserting\ at\ the\ end\ of\ the}
\DoxyCodeLine{01942\ \ \ //\ right\ node\ then\ bias\ the\ split\ to\ put\ more\ values\ on\ the\ left\ node.}
\DoxyCodeLine{01943\ \ \ if\ (insert\_position\ ==\ start())\ \{}
\DoxyCodeLine{01944\ \ \ \ \ dest-\/>set\_finish(dest-\/>start()\ +\ finish()\ -\/\ 1);}
\DoxyCodeLine{01945\ \ \ \}\ else\ if\ (insert\_position\ ==\ kNodeSlots)\ \{}
\DoxyCodeLine{01946\ \ \ \ \ dest-\/>set\_finish(dest-\/>start());}
\DoxyCodeLine{01947\ \ \ \}\ else\ \{}
\DoxyCodeLine{01948\ \ \ \ \ dest-\/>set\_finish(dest-\/>start()\ +\ count()\ /\ 2);}
\DoxyCodeLine{01949\ \ \ \}}
\DoxyCodeLine{01950\ \ \ set\_finish(finish()\ -\/\ dest-\/>count());}
\DoxyCodeLine{01951\ \ \ assert(count()\ >=\ 1);}
\DoxyCodeLine{01952\ }
\DoxyCodeLine{01953\ \ \ //\ Move\ values\ from\ the\ left\ sibling\ to\ the\ right\ sibling.}
\DoxyCodeLine{01954\ \ \ dest-\/>transfer\_n(dest-\/>count(),\ dest-\/>start(),\ finish(),\ this,\ alloc);}
\DoxyCodeLine{01955\ }
\DoxyCodeLine{01956\ \ \ //\ The\ split\ key\ is\ the\ largest\ value\ in\ the\ left\ sibling.}
\DoxyCodeLine{01957\ \ \ -\/-\/mutable\_finish();}
\DoxyCodeLine{01958\ \ \ parent()-\/>emplace\_value(position(),\ alloc,\ finish\_slot());}
\DoxyCodeLine{01959\ \ \ value\_destroy(finish(),\ alloc);}
\DoxyCodeLine{01960\ \ \ parent()-\/>set\_child\_noupdate\_position(position()\ +\ 1,\ dest);}
\DoxyCodeLine{01961\ }
\DoxyCodeLine{01962\ \ \ if\ (is\_internal())\ \{}
\DoxyCodeLine{01963\ \ \ \ \ for\ (field\_type\ i\ =\ dest-\/>start(),\ j\ =\ finish()\ +\ 1;\ i\ <=\ dest-\/>finish();}
\DoxyCodeLine{01964\ \ \ \ \ \ \ \ \ \ ++i,\ ++j)\ \{}
\DoxyCodeLine{01965\ \ \ \ \ \ \ assert(child(j)\ !=\ nullptr);}
\DoxyCodeLine{01966\ \ \ \ \ \ \ dest-\/>init\_child(i,\ child(j));}
\DoxyCodeLine{01967\ \ \ \ \ \ \ clear\_child(j);}
\DoxyCodeLine{01968\ \ \ \ \ \}}
\DoxyCodeLine{01969\ \ \ \}}
\DoxyCodeLine{01970\ \}}
\DoxyCodeLine{01971\ }
\DoxyCodeLine{01972\ template\ <typename\ P>}
\DoxyCodeLine{01973\ void\ btree\_node<P>::merge(btree\_node\ *src,\ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{01974\ \ \ assert(parent()\ ==\ src-\/>parent());}
\DoxyCodeLine{01975\ \ \ assert(position()\ +\ 1\ ==\ src-\/>position());}
\DoxyCodeLine{01976\ }
\DoxyCodeLine{01977\ \ \ //\ Move\ the\ delimiting\ value\ to\ the\ left\ node.}
\DoxyCodeLine{01978\ \ \ value\_init(finish(),\ alloc,\ parent()-\/>slot(position()));}
\DoxyCodeLine{01979\ }
\DoxyCodeLine{01980\ \ \ //\ Move\ the\ values\ from\ the\ right\ to\ the\ left\ node.}
\DoxyCodeLine{01981\ \ \ transfer\_n(src-\/>count(),\ finish()\ +\ 1,\ src-\/>start(),\ src,\ alloc);}
\DoxyCodeLine{01982\ }
\DoxyCodeLine{01983\ \ \ if\ (is\_internal())\ \{}
\DoxyCodeLine{01984\ \ \ \ \ //\ Move\ the\ child\ pointers\ from\ the\ right\ to\ the\ left\ node.}
\DoxyCodeLine{01985\ \ \ \ \ for\ (field\_type\ i\ =\ src-\/>start(),\ j\ =\ finish()\ +\ 1;\ i\ <=\ src-\/>finish();}
\DoxyCodeLine{01986\ \ \ \ \ \ \ \ \ \ ++i,\ ++j)\ \{}
\DoxyCodeLine{01987\ \ \ \ \ \ \ init\_child(j,\ src-\/>child(i));}
\DoxyCodeLine{01988\ \ \ \ \ \ \ src-\/>clear\_child(i);}
\DoxyCodeLine{01989\ \ \ \ \ \}}
\DoxyCodeLine{01990\ \ \ \}}
\DoxyCodeLine{01991\ }
\DoxyCodeLine{01992\ \ \ //\ Fixup\ \`{}finish`\ on\ the\ src\ and\ dest\ nodes.}
\DoxyCodeLine{01993\ \ \ set\_finish(start()\ +\ 1\ +\ count()\ +\ src-\/>count());}
\DoxyCodeLine{01994\ \ \ src-\/>set\_finish(src-\/>start());}
\DoxyCodeLine{01995\ }
\DoxyCodeLine{01996\ \ \ //\ Remove\ the\ value\ on\ the\ parent\ node\ and\ delete\ the\ src\ node.}
\DoxyCodeLine{01997\ \ \ parent()-\/>remove\_values(position(),\ /*to\_erase=*/1,\ alloc);}
\DoxyCodeLine{01998\ \}}
\DoxyCodeLine{01999\ }
\DoxyCodeLine{02000\ template\ <typename\ P>}
\DoxyCodeLine{02001\ void\ btree\_node<P>::clear\_and\_delete(btree\_node\ *node,\ allocator\_type\ *alloc)\ \{}
\DoxyCodeLine{02002\ \ \ if\ (node-\/>is\_leaf())\ \{}
\DoxyCodeLine{02003\ \ \ \ \ node-\/>value\_destroy\_n(node-\/>start(),\ node-\/>count(),\ alloc);}
\DoxyCodeLine{02004\ \ \ \ \ deallocate(LeafSize(node-\/>max\_count()),\ node,\ alloc);}
\DoxyCodeLine{02005\ \ \ \ \ return;}
\DoxyCodeLine{02006\ \ \ \}}
\DoxyCodeLine{02007\ \ \ if\ (node-\/>count()\ ==\ 0)\ \{}
\DoxyCodeLine{02008\ \ \ \ \ deallocate(InternalSize(),\ node,\ alloc);}
\DoxyCodeLine{02009\ \ \ \ \ return;}
\DoxyCodeLine{02010\ \ \ \}}
\DoxyCodeLine{02011\ }
\DoxyCodeLine{02012\ \ \ //\ The\ parent\ of\ the\ root\ of\ the\ subtree\ we\ are\ deleting.}
\DoxyCodeLine{02013\ \ \ btree\_node\ *delete\_root\_parent\ =\ node-\/>parent();}
\DoxyCodeLine{02014\ }
\DoxyCodeLine{02015\ \ \ //\ Navigate\ to\ the\ leftmost\ leaf\ under\ node,\ and\ then\ delete\ upwards.}
\DoxyCodeLine{02016\ \ \ while\ (node-\/>is\_internal())\ node\ =\ node-\/>start\_child();}
\DoxyCodeLine{02017\ \#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}
\DoxyCodeLine{02018\ \ \ //\ When\ generations\ are\ enabled,\ we\ delete\ the\ leftmost\ leaf\ last\ in\ case\ it's}
\DoxyCodeLine{02019\ \ \ //\ the\ parent\ of\ the\ root\ and\ we\ need\ to\ check\ whether\ it's\ a\ leaf\ before\ we}
\DoxyCodeLine{02020\ \ \ //\ can\ update\ the\ root's\ generation.}
\DoxyCodeLine{02021\ \ \ //\ TODO(ezb):\ if\ we\ change\ btree\_node::is\_root\ to\ check\ a\ bool\ inside\ the\ node}
\DoxyCodeLine{02022\ \ \ //\ instead\ of\ checking\ whether\ the\ parent\ is\ a\ leaf,\ we\ can\ remove\ this\ logic.}
\DoxyCodeLine{02023\ \ \ btree\_node\ *leftmost\_leaf\ =\ node;}
\DoxyCodeLine{02024\ \#endif}
\DoxyCodeLine{02025\ \ \ //\ Use\ \`{}size\_type`\ because\ \`{}pos`\ needs\ to\ be\ able\ to\ hold\ \`{}kNodeSlots+1`,}
\DoxyCodeLine{02026\ \ \ //\ which\ isn't\ guaranteed\ to\ be\ a\ valid\ \`{}field\_type`.}
\DoxyCodeLine{02027\ \ \ size\_type\ pos\ =\ node-\/>position();}
\DoxyCodeLine{02028\ \ \ btree\_node\ *parent\ =\ node-\/>parent();}
\DoxyCodeLine{02029\ \ \ for\ (;;)\ \{}
\DoxyCodeLine{02030\ \ \ \ \ //\ In\ each\ iteration\ of\ the\ next\ loop,\ we\ delete\ one\ leaf\ node\ and\ go\ right.}
\DoxyCodeLine{02031\ \ \ \ \ assert(pos\ <=\ parent-\/>finish());}
\DoxyCodeLine{02032\ \ \ \ \ do\ \{}
\DoxyCodeLine{02033\ \ \ \ \ \ \ node\ =\ parent-\/>child(static\_cast<field\_type>(pos));}
\DoxyCodeLine{02034\ \ \ \ \ \ \ if\ (node-\/>is\_internal())\ \{}
\DoxyCodeLine{02035\ \ \ \ \ \ \ \ \ //\ Navigate\ to\ the\ leftmost\ leaf\ under\ node.}
\DoxyCodeLine{02036\ \ \ \ \ \ \ \ \ while\ (node-\/>is\_internal())\ node\ =\ node-\/>start\_child();}
\DoxyCodeLine{02037\ \ \ \ \ \ \ \ \ pos\ =\ node-\/>position();}
\DoxyCodeLine{02038\ \ \ \ \ \ \ \ \ parent\ =\ node-\/>parent();}
\DoxyCodeLine{02039\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02040\ \ \ \ \ \ \ node-\/>value\_destroy\_n(node-\/>start(),\ node-\/>count(),\ alloc);}
\DoxyCodeLine{02041\ \#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}
\DoxyCodeLine{02042\ \ \ \ \ \ \ if\ (leftmost\_leaf\ !=\ node)}
\DoxyCodeLine{02043\ \#endif}
\DoxyCodeLine{02044\ \ \ \ \ \ \ \ \ deallocate(LeafSize(node-\/>max\_count()),\ node,\ alloc);}
\DoxyCodeLine{02045\ \ \ \ \ \ \ ++pos;}
\DoxyCodeLine{02046\ \ \ \ \ \}\ while\ (pos\ <=\ parent-\/>finish());}
\DoxyCodeLine{02047\ }
\DoxyCodeLine{02048\ \ \ \ \ //\ Once\ we've\ deleted\ all\ children\ of\ parent,\ delete\ parent\ and\ go\ up/right.}
\DoxyCodeLine{02049\ \ \ \ \ assert(pos\ >\ parent-\/>finish());}
\DoxyCodeLine{02050\ \ \ \ \ do\ \{}
\DoxyCodeLine{02051\ \ \ \ \ \ \ node\ =\ parent;}
\DoxyCodeLine{02052\ \ \ \ \ \ \ pos\ =\ node-\/>position();}
\DoxyCodeLine{02053\ \ \ \ \ \ \ parent\ =\ node-\/>parent();}
\DoxyCodeLine{02054\ \ \ \ \ \ \ node-\/>value\_destroy\_n(node-\/>start(),\ node-\/>count(),\ alloc);}
\DoxyCodeLine{02055\ \ \ \ \ \ \ deallocate(InternalSize(),\ node,\ alloc);}
\DoxyCodeLine{02056\ \ \ \ \ \ \ if\ (parent\ ==\ delete\_root\_parent)\ \{}
\DoxyCodeLine{02057\ \#ifdef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}
\DoxyCodeLine{02058\ \ \ \ \ \ \ \ \ deallocate(LeafSize(leftmost\_leaf-\/>max\_count()),\ leftmost\_leaf,\ alloc);}
\DoxyCodeLine{02059\ \#endif}
\DoxyCodeLine{02060\ \ \ \ \ \ \ \ \ return;}
\DoxyCodeLine{02061\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02062\ \ \ \ \ \ \ ++pos;}
\DoxyCodeLine{02063\ \ \ \ \ \}\ while\ (pos\ >\ parent-\/>finish());}
\DoxyCodeLine{02064\ \ \ \}}
\DoxyCodeLine{02065\ \}}
\DoxyCodeLine{02066\ }
\DoxyCodeLine{02068\ //\ btree\_iterator\ methods}
\DoxyCodeLine{02069\ }
\DoxyCodeLine{02070\ //\ Note:\ the\ implementation\ here\ is\ based\ on\ btree\_node::clear\_and\_delete.}
\DoxyCodeLine{02071\ template\ <typename\ N,\ typename\ R,\ typename\ P>}
\DoxyCodeLine{02072\ auto\ btree\_iterator<N,\ R,\ P>::distance\_slow(const\_iterator\ other)\ const}
\DoxyCodeLine{02073\ \ \ \ \ -\/>\ difference\_type\ \{}
\DoxyCodeLine{02074\ \ \ const\_iterator\ begin\ =\ other;}
\DoxyCodeLine{02075\ \ \ const\_iterator\ end\ =\ *this;}
\DoxyCodeLine{02076\ \ \ assert(begin.node\_\ !=\ end.node\_\ ||\ !begin.node\_-\/>is\_leaf()\ ||}
\DoxyCodeLine{02077\ \ \ \ \ \ \ \ \ \ begin.position\_\ !=\ end.position\_);}
\DoxyCodeLine{02078\ }
\DoxyCodeLine{02079\ \ \ const\ node\_type\ *node\ =\ begin.node\_;}
\DoxyCodeLine{02080\ \ \ //\ We\ need\ to\ compensate\ for\ double\ counting\ if\ begin.node\_\ is\ a\ leaf\ node.}
\DoxyCodeLine{02081\ \ \ difference\_type\ count\ =\ node-\/>is\_leaf()\ ?\ -\/begin.position\_\ :\ 0;}
\DoxyCodeLine{02082\ }
\DoxyCodeLine{02083\ \ \ //\ First\ navigate\ to\ the\ leftmost\ leaf\ node\ past\ begin.}
\DoxyCodeLine{02084\ \ \ if\ (node-\/>is\_internal())\ \{}
\DoxyCodeLine{02085\ \ \ \ \ ++count;}
\DoxyCodeLine{02086\ \ \ \ \ node\ =\ node-\/>child(begin.position\_\ +\ 1);}
\DoxyCodeLine{02087\ \ \ \}}
\DoxyCodeLine{02088\ \ \ while\ (node-\/>is\_internal())\ node\ =\ node-\/>start\_child();}
\DoxyCodeLine{02089\ }
\DoxyCodeLine{02090\ \ \ //\ Use\ \`{}size\_type`\ because\ \`{}pos`\ needs\ to\ be\ able\ to\ hold\ \`{}kNodeSlots+1`,}
\DoxyCodeLine{02091\ \ \ //\ which\ isn't\ guaranteed\ to\ be\ a\ valid\ \`{}field\_type`.}
\DoxyCodeLine{02092\ \ \ size\_type\ pos\ =\ node-\/>position();}
\DoxyCodeLine{02093\ \ \ const\ node\_type\ *parent\ =\ node-\/>parent();}
\DoxyCodeLine{02094\ \ \ for\ (;;)\ \{}
\DoxyCodeLine{02095\ \ \ \ \ //\ In\ each\ iteration\ of\ the\ next\ loop,\ we\ count\ one\ leaf\ node\ and\ go\ right.}
\DoxyCodeLine{02096\ \ \ \ \ assert(pos\ <=\ parent-\/>finish());}
\DoxyCodeLine{02097\ \ \ \ \ do\ \{}
\DoxyCodeLine{02098\ \ \ \ \ \ \ node\ =\ parent-\/>child(static\_cast<field\_type>(pos));}
\DoxyCodeLine{02099\ \ \ \ \ \ \ if\ (node-\/>is\_internal())\ \{}
\DoxyCodeLine{02100\ \ \ \ \ \ \ \ \ //\ Navigate\ to\ the\ leftmost\ leaf\ under\ node.}
\DoxyCodeLine{02101\ \ \ \ \ \ \ \ \ while\ (node-\/>is\_internal())\ node\ =\ node-\/>start\_child();}
\DoxyCodeLine{02102\ \ \ \ \ \ \ \ \ pos\ =\ node-\/>position();}
\DoxyCodeLine{02103\ \ \ \ \ \ \ \ \ parent\ =\ node-\/>parent();}
\DoxyCodeLine{02104\ \ \ \ \ \ \ \}}
\DoxyCodeLine{02105\ \ \ \ \ \ \ if\ (node\ ==\ end.node\_)\ return\ count\ +\ end.position\_;}
\DoxyCodeLine{02106\ \ \ \ \ \ \ if\ (parent\ ==\ end.node\_\ \&\&\ pos\ ==\ static\_cast<size\_type>(end.position\_))}
\DoxyCodeLine{02107\ \ \ \ \ \ \ \ \ return\ count\ +\ node-\/>count();}
\DoxyCodeLine{02108\ \ \ \ \ \ \ //\ +1\ is\ for\ the\ next\ internal\ node\ value.}
\DoxyCodeLine{02109\ \ \ \ \ \ \ count\ +=\ node-\/>count()\ +\ 1;}
\DoxyCodeLine{02110\ \ \ \ \ \ \ ++pos;}
\DoxyCodeLine{02111\ \ \ \ \ \}\ while\ (pos\ <=\ parent-\/>finish());}
\DoxyCodeLine{02112\ }
\DoxyCodeLine{02113\ \ \ \ \ //\ Once\ we've\ counted\ all\ children\ of\ parent,\ go\ up/right.}
\DoxyCodeLine{02114\ \ \ \ \ assert(pos\ >\ parent-\/>finish());}
\DoxyCodeLine{02115\ \ \ \ \ do\ \{}
\DoxyCodeLine{02116\ \ \ \ \ \ \ node\ =\ parent;}
\DoxyCodeLine{02117\ \ \ \ \ \ \ pos\ =\ node-\/>position();}
\DoxyCodeLine{02118\ \ \ \ \ \ \ parent\ =\ node-\/>parent();}
\DoxyCodeLine{02119\ \ \ \ \ \ \ //\ -\/1\ because\ we\ counted\ the\ value\ at\ end\ and\ shouldn't.}
\DoxyCodeLine{02120\ \ \ \ \ \ \ if\ (parent\ ==\ end.node\_\ \&\&\ pos\ ==\ static\_cast<size\_type>(end.position\_))}
\DoxyCodeLine{02121\ \ \ \ \ \ \ \ \ return\ count\ -\/\ 1;}
\DoxyCodeLine{02122\ \ \ \ \ \ \ ++pos;}
\DoxyCodeLine{02123\ \ \ \ \ \}\ while\ (pos\ >\ parent-\/>finish());}
\DoxyCodeLine{02124\ \ \ \}}
\DoxyCodeLine{02125\ \}}
\DoxyCodeLine{02126\ }
\DoxyCodeLine{02127\ template\ <typename\ N,\ typename\ R,\ typename\ P>}
\DoxyCodeLine{02128\ void\ btree\_iterator<N,\ R,\ P>::increment\_slow()\ \{}
\DoxyCodeLine{02129\ \ \ if\ (node\_-\/>is\_leaf())\ \{}
\DoxyCodeLine{02130\ \ \ \ \ assert(position\_\ >=\ node\_-\/>finish());}
\DoxyCodeLine{02131\ \ \ \ \ btree\_iterator\ save(*this);}
\DoxyCodeLine{02132\ \ \ \ \ while\ (position\_\ ==\ node\_-\/>finish()\ \&\&\ !node\_-\/>is\_root())\ \{}
\DoxyCodeLine{02133\ \ \ \ \ \ \ assert(node\_-\/>parent()-\/>child(node\_-\/>position())\ ==\ node\_);}
\DoxyCodeLine{02134\ \ \ \ \ \ \ position\_\ =\ node\_-\/>position();}
\DoxyCodeLine{02135\ \ \ \ \ \ \ node\_\ =\ node\_-\/>parent();}
\DoxyCodeLine{02136\ \ \ \ \ \}}
\DoxyCodeLine{02137\ \ \ \ \ //\ TODO(ezb):\ assert\ we\ aren't\ incrementing\ end()\ instead\ of\ handling.}
\DoxyCodeLine{02138\ \ \ \ \ if\ (position\_\ ==\ node\_-\/>finish())\ \{}
\DoxyCodeLine{02139\ \ \ \ \ \ \ *this\ =\ save;}
\DoxyCodeLine{02140\ \ \ \ \ \}}
\DoxyCodeLine{02141\ \ \ \}\ else\ \{}
\DoxyCodeLine{02142\ \ \ \ \ assert(position\_\ <\ node\_-\/>finish());}
\DoxyCodeLine{02143\ \ \ \ \ node\_\ =\ node\_-\/>child(static\_cast<field\_type>(position\_\ +\ 1));}
\DoxyCodeLine{02144\ \ \ \ \ while\ (node\_-\/>is\_internal())\ \{}
\DoxyCodeLine{02145\ \ \ \ \ \ \ node\_\ =\ node\_-\/>start\_child();}
\DoxyCodeLine{02146\ \ \ \ \ \}}
\DoxyCodeLine{02147\ \ \ \ \ position\_\ =\ node\_-\/>start();}
\DoxyCodeLine{02148\ \ \ \}}
\DoxyCodeLine{02149\ \}}
\DoxyCodeLine{02150\ }
\DoxyCodeLine{02151\ template\ <typename\ N,\ typename\ R,\ typename\ P>}
\DoxyCodeLine{02152\ void\ btree\_iterator<N,\ R,\ P>::decrement\_slow()\ \{}
\DoxyCodeLine{02153\ \ \ if\ (node\_-\/>is\_leaf())\ \{}
\DoxyCodeLine{02154\ \ \ \ \ assert(position\_\ <=\ -\/1);}
\DoxyCodeLine{02155\ \ \ \ \ btree\_iterator\ save(*this);}
\DoxyCodeLine{02156\ \ \ \ \ while\ (position\_\ <\ node\_-\/>start()\ \&\&\ !node\_-\/>is\_root())\ \{}
\DoxyCodeLine{02157\ \ \ \ \ \ \ assert(node\_-\/>parent()-\/>child(node\_-\/>position())\ ==\ node\_);}
\DoxyCodeLine{02158\ \ \ \ \ \ \ position\_\ =\ node\_-\/>position()\ -\/\ 1;}
\DoxyCodeLine{02159\ \ \ \ \ \ \ node\_\ =\ node\_-\/>parent();}
\DoxyCodeLine{02160\ \ \ \ \ \}}
\DoxyCodeLine{02161\ \ \ \ \ //\ TODO(ezb):\ assert\ we\ aren't\ decrementing\ begin()\ instead\ of\ handling.}
\DoxyCodeLine{02162\ \ \ \ \ if\ (position\_\ <\ node\_-\/>start())\ \{}
\DoxyCodeLine{02163\ \ \ \ \ \ \ *this\ =\ save;}
\DoxyCodeLine{02164\ \ \ \ \ \}}
\DoxyCodeLine{02165\ \ \ \}\ else\ \{}
\DoxyCodeLine{02166\ \ \ \ \ assert(position\_\ >=\ node\_-\/>start());}
\DoxyCodeLine{02167\ \ \ \ \ node\_\ =\ node\_-\/>child(static\_cast<field\_type>(position\_));}
\DoxyCodeLine{02168\ \ \ \ \ while\ (node\_-\/>is\_internal())\ \{}
\DoxyCodeLine{02169\ \ \ \ \ \ \ node\_\ =\ node\_-\/>child(node\_-\/>finish());}
\DoxyCodeLine{02170\ \ \ \ \ \}}
\DoxyCodeLine{02171\ \ \ \ \ position\_\ =\ node\_-\/>finish()\ -\/\ 1;}
\DoxyCodeLine{02172\ \ \ \}}
\DoxyCodeLine{02173\ \}}
\DoxyCodeLine{02174\ }
\DoxyCodeLine{02176\ //\ btree\ methods}
\DoxyCodeLine{02177\ template\ <typename\ P>}
\DoxyCodeLine{02178\ template\ <typename\ Btree>}
\DoxyCodeLine{02179\ void\ btree<P>::copy\_or\_move\_values\_in\_order(Btree\ \&other)\ \{}
\DoxyCodeLine{02180\ \ \ static\_assert(std::is\_same<btree,\ Btree>::value\ ||}
\DoxyCodeLine{02181\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::is\_same<const\ btree,\ Btree>::value,}
\DoxyCodeLine{02182\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}Btree\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1key__compare__adapter_aff07e2a19d9c094051b0b7e96900e863}{type}}\ must\ be\ same\ or\ \textcolor{keyword}{const}.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02183\ \textcolor{stringliteral}{\ \ assert(empty());}}
\DoxyCodeLine{02184\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02185\ \textcolor{stringliteral}{\ \ //\ We\ can\ avoid\ key\ comparisons\ because\ we\ know\ the\ order\ of\ the}}
\DoxyCodeLine{02186\ \textcolor{stringliteral}{\ \ //\ values\ is\ the\ same\ order\ we'll\ store\ them\ in.}}
\DoxyCodeLine{02187\ \textcolor{stringliteral}{\ \ auto\ iter\ =\ other.begin();}}
\DoxyCodeLine{02188\ \textcolor{stringliteral}{\ \ if\ (iter\ ==\ other.end())\ return;}}
\DoxyCodeLine{02189\ \textcolor{stringliteral}{\ \ insert\_multi(iter.slot());}}
\DoxyCodeLine{02190\ \textcolor{stringliteral}{\ \ ++iter;}}
\DoxyCodeLine{02191\ \textcolor{stringliteral}{\ \ for\ (;\ iter\ !=\ other.end();\ ++iter)\ \{}}
\DoxyCodeLine{02192\ \textcolor{stringliteral}{\ \ \ \ //\ If\ the\ btree\ is\ not\ empty,\ we\ can\ just\ insert\ the\ new\ value\ at\ the\ end}}
\DoxyCodeLine{02193\ \textcolor{stringliteral}{\ \ \ \ //\ of\ the\ tree.}}
\DoxyCodeLine{02194\ \textcolor{stringliteral}{\ \ \ \ internal\_emplace(end(),\ iter.slot());}}
\DoxyCodeLine{02195\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02196\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02197\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02198\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02199\ \textcolor{stringliteral}{constexpr\ bool\ btree<P>::static\_assert\_validation()\ \{}}
\DoxyCodeLine{02200\ \textcolor{stringliteral}{\ \ static\_assert(std::is\_nothrow\_copy\_constructible<key\_compare>::value,}}
\DoxyCodeLine{02201\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}Key\ comparison\ must\ be\ nothrow\ copy\ constructible\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02202\ \textcolor{stringliteral}{\ \ static\_assert(std::is\_nothrow\_copy\_constructible<allocator\_type>::value,}}
\DoxyCodeLine{02203\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}Allocator\ must\ be\ nothrow\ copy\ constructible\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02204\ \textcolor{stringliteral}{\ \ static\_assert(std::is\_trivially\_copyable<iterator>::value,}}
\DoxyCodeLine{02205\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}\mbox{\hyperlink{classabsl_1_1container__internal_1_1btree_a66ceb63c9ad29e4d63a167934b2afa82}{iterator}}\ not\ trivially\ copyable.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02206\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02207\ \textcolor{stringliteral}{\ \ //\ Note:\ We\ assert\ that\ kTargetValues,\ which\ is\ computed\ from}}
\DoxyCodeLine{02208\ \textcolor{stringliteral}{\ \ //\ Params::kTargetNodeSize,\ must\ fit\ the\ node\_type::field\_type.}}
\DoxyCodeLine{02209\ \textcolor{stringliteral}{\ \ static\_assert(}}
\DoxyCodeLine{02210\ \textcolor{stringliteral}{\ \ \ \ \ \ kNodeSlots\ <\ (1\ <<\ (8\ *\ sizeof(typename\ node\_type::field\_type))),}}
\DoxyCodeLine{02211\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}target\ node\ \mbox{\hyperlink{abseil-cpp_2absl_2base_2internal_2low__level__alloc_8cc_aad9b71a31372d5c0ab9c23163efe9544}{size}}\ too\ large\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02212\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02213\ \textcolor{stringliteral}{\ \ //\ Verify\ that\ key\_compare\ returns\ an\ absl::\{weak,strong\}\_ordering\ or\ bool.}}
\DoxyCodeLine{02214\ \textcolor{stringliteral}{\ \ static\_assert(}}
\DoxyCodeLine{02215\ \textcolor{stringliteral}{\ \ \ \ \ \ compare\_has\_valid\_result\_type<key\_compare,\ key\_type>(),}}
\DoxyCodeLine{02216\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}}\ comparison\ function\ must\ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{namespaceabsl}{absl}}::\{weak,strong\}\_ordering\ or\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{02217\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}\textcolor{keywordtype}{bool}.\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02218\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02219\ \textcolor{stringliteral}{\ \ //\ Test\ the\ assumption\ made\ in\ setting\ kNodeSlotSpace.}}
\DoxyCodeLine{02220\ \textcolor{stringliteral}{\ \ static\_assert(node\_type::MinimumOverhead()\ >=\ sizeof(void\ *)\ +\ 4,}}
\DoxyCodeLine{02221\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ "{}}node\ space\ assumption\ incorrect\textcolor{stringliteral}{"{});}}
\DoxyCodeLine{02222\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02223\ \textcolor{stringliteral}{\ \ return\ true;}}
\DoxyCodeLine{02224\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02225\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02226\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02227\ \textcolor{stringliteral}{template\ <typename\ K>}}
\DoxyCodeLine{02228\ \textcolor{stringliteral}{auto\ btree<P>::lower\_bound\_equal(const\ K\ \&key)\ const}}
\DoxyCodeLine{02229\ \textcolor{stringliteral}{\ \ \ \ -\/>\ std::pair<iterator,\ bool>\ \{}}
\DoxyCodeLine{02230\ \textcolor{stringliteral}{\ \ const\ SearchResult<iterator,\ is\_key\_compare\_to::value>\ res\ =}}
\DoxyCodeLine{02231\ \textcolor{stringliteral}{\ \ \ \ \ \ internal\_lower\_bound(key);}}
\DoxyCodeLine{02232\ \textcolor{stringliteral}{\ \ const\ iterator\ lower\ =\ iterator(internal\_end(res.value));}}
\DoxyCodeLine{02233\ \textcolor{stringliteral}{\ \ const\ bool\ equal\ =\ res.HasMatch()}}
\DoxyCodeLine{02234\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ ?\ res.IsEq()}}
\DoxyCodeLine{02235\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ :\ lower\ !=\ end()\ \&\&\ !compare\_keys(key,\ lower.key());}}
\DoxyCodeLine{02236\ \textcolor{stringliteral}{\ \ return\ \{lower,\ equal\};}}
\DoxyCodeLine{02237\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02238\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02239\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02240\ \textcolor{stringliteral}{template\ <typename\ K>}}
\DoxyCodeLine{02241\ \textcolor{stringliteral}{auto\ btree<P>::equal\_range(const\ K\ \&key)\ -\/>\ std::pair<iterator,\ iterator>\ \{}}
\DoxyCodeLine{02242\ \textcolor{stringliteral}{\ \ const\ std::pair<iterator,\ bool>\ lower\_and\_equal\ =\ lower\_bound\_equal(key);}}
\DoxyCodeLine{02243\ \textcolor{stringliteral}{\ \ const\ iterator\ lower\ =\ lower\_and\_equal.first;}}
\DoxyCodeLine{02244\ \textcolor{stringliteral}{\ \ if\ (!lower\_and\_equal.second)\ \{}}
\DoxyCodeLine{02245\ \textcolor{stringliteral}{\ \ \ \ return\ \{lower,\ lower\};}}
\DoxyCodeLine{02246\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02247\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02248\ \textcolor{stringliteral}{\ \ const\ iterator\ next\ =\ std::next(lower);}}
\DoxyCodeLine{02249\ \textcolor{stringliteral}{\ \ if\ (!params\_type::template\ can\_have\_multiple\_equivalent\_keys<K>())\ \{}}
\DoxyCodeLine{02250\ \textcolor{stringliteral}{\ \ \ \ //\ The\ next\ iterator\ after\ lower\ must\ point\ to\ a\ key\ greater\ than\ \`{}key`.}}
\DoxyCodeLine{02251\ \textcolor{stringliteral}{\ \ \ \ //\ Note:\ if\ this\ assert\ fails,\ then\ it\ may\ indicate\ that\ the\ comparator\ does}}
\DoxyCodeLine{02252\ \textcolor{stringliteral}{\ \ \ \ //\ not\ meet\ the\ equivalence\ requirements\ for\ Compare}}
\DoxyCodeLine{02253\ \textcolor{stringliteral}{\ \ \ \ //\ (see\ https://en.cppreference.com/w/cpp/named\_req/Compare).}}
\DoxyCodeLine{02254\ \textcolor{stringliteral}{\ \ \ \ assert(next\ ==\ end()\ ||\ compare\_keys(key,\ next.key()));}}
\DoxyCodeLine{02255\ \textcolor{stringliteral}{\ \ \ \ return\ \{lower,\ next\};}}
\DoxyCodeLine{02256\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02257\ \textcolor{stringliteral}{\ \ //\ Try\ once\ more\ to\ avoid\ the\ call\ to\ upper\_bound()\ if\ there's\ only\ one}}
\DoxyCodeLine{02258\ \textcolor{stringliteral}{\ \ //\ equivalent\ key.\ This\ should\ prevent\ all\ calls\ to\ upper\_bound()\ in\ cases\ of}}
\DoxyCodeLine{02259\ \textcolor{stringliteral}{\ \ //\ unique-\/containers\ with\ heterogeneous\ comparators\ in\ which\ all\ comparison}}
\DoxyCodeLine{02260\ \textcolor{stringliteral}{\ \ //\ operators\ have\ the\ same\ equivalence\ classes.}}
\DoxyCodeLine{02261\ \textcolor{stringliteral}{\ \ if\ (next\ ==\ end()\ ||\ compare\_keys(key,\ next.key()))\ return\ \{lower,\ next\};}}
\DoxyCodeLine{02262\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02263\ \textcolor{stringliteral}{\ \ //\ In\ this\ case,\ we\ need\ to\ call\ upper\_bound()\ to\ avoid\ worst\ case\ O(N)}}
\DoxyCodeLine{02264\ \textcolor{stringliteral}{\ \ //\ behavior\ if\ we\ were\ to\ iterate\ over\ equal\ keys.}}
\DoxyCodeLine{02265\ \textcolor{stringliteral}{\ \ return\ \{lower,\ upper\_bound(key)\};}}
\DoxyCodeLine{02266\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02267\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02268\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02269\ \textcolor{stringliteral}{template\ <typename\ K,\ typename...\ Args>}}
\DoxyCodeLine{02270\ \textcolor{stringliteral}{auto\ btree<P>::insert\_unique(const\ K\ \&key,\ Args\ \&\&...args)}}
\DoxyCodeLine{02271\ \textcolor{stringliteral}{\ \ \ \ -\/>\ std::pair<iterator,\ bool>\ \{}}
\DoxyCodeLine{02272\ \textcolor{stringliteral}{\ \ if\ (empty())\ \{}}
\DoxyCodeLine{02273\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ mutable\_rightmost()\ =\ new\_leaf\_root\_node(1);}}
\DoxyCodeLine{02274\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02275\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02276\ \textcolor{stringliteral}{\ \ SearchResult<iterator,\ is\_key\_compare\_to::value>\ res\ =\ internal\_locate(key);}}
\DoxyCodeLine{02277\ \textcolor{stringliteral}{\ \ iterator\ iter\ =\ res.value;}}
\DoxyCodeLine{02278\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02279\ \textcolor{stringliteral}{\ \ if\ (res.HasMatch())\ \{}}
\DoxyCodeLine{02280\ \textcolor{stringliteral}{\ \ \ \ if\ (res.IsEq())\ \{}}
\DoxyCodeLine{02281\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ The\ key\ already\ exists\ in\ the\ tree,\ do\ nothing.}}
\DoxyCodeLine{02282\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ \{iter,\ false\};}}
\DoxyCodeLine{02283\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02284\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02285\ \textcolor{stringliteral}{\ \ \ \ iterator\ last\ =\ internal\_last(iter);}}
\DoxyCodeLine{02286\ \textcolor{stringliteral}{\ \ \ \ if\ (last.node\_\ \&\&\ !compare\_keys(key,\ last.key()))\ \{}}
\DoxyCodeLine{02287\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ The\ key\ already\ exists\ in\ the\ tree,\ do\ nothing.}}
\DoxyCodeLine{02288\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ \{last,\ false\};}}
\DoxyCodeLine{02289\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02290\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02291\ \textcolor{stringliteral}{\ \ return\ \{internal\_emplace(iter,\ std::forward<Args>(args)...),\ true\};}}
\DoxyCodeLine{02292\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02293\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02294\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02295\ \textcolor{stringliteral}{template\ <typename\ K,\ typename...\ Args>}}
\DoxyCodeLine{02296\ \textcolor{stringliteral}{inline\ auto\ btree<P>::insert\_hint\_unique(iterator\ position,\ const\ K\ \&key,}}
\DoxyCodeLine{02297\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ Args\ \&\&...args)}}
\DoxyCodeLine{02298\ \textcolor{stringliteral}{\ \ \ \ -\/>\ std::pair<iterator,\ bool>\ \{}}
\DoxyCodeLine{02299\ \textcolor{stringliteral}{\ \ if\ (!empty())\ \{}}
\DoxyCodeLine{02300\ \textcolor{stringliteral}{\ \ \ \ if\ (position\ ==\ end()\ ||\ compare\_keys(key,\ position.key()))\ \{}}
\DoxyCodeLine{02301\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (position\ ==\ begin()\ ||\ compare\_keys(std::prev(position).key(),\ key))\ \{}}
\DoxyCodeLine{02302\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ prev.key()\ <\ key\ <\ position.key()}}
\DoxyCodeLine{02303\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ \{internal\_emplace(position,\ std::forward<Args>(args)...),\ true\};}}
\DoxyCodeLine{02304\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02305\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ if\ (compare\_keys(position.key(),\ key))\ \{}}
\DoxyCodeLine{02306\ \textcolor{stringliteral}{\ \ \ \ \ \ ++position;}}
\DoxyCodeLine{02307\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (position\ ==\ end()\ ||\ compare\_keys(key,\ position.key()))\ \{}}
\DoxyCodeLine{02308\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ \{original\ \`{}position`\}.key()\ <\ key\ <\ \{current\ \`{}position`\}.key()}}
\DoxyCodeLine{02309\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ \{internal\_emplace(position,\ std::forward<Args>(args)...),\ true\};}}
\DoxyCodeLine{02310\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02311\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02312\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ position.key()\ ==\ key}}
\DoxyCodeLine{02313\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ \{position,\ false\};}}
\DoxyCodeLine{02314\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02315\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02316\ \textcolor{stringliteral}{\ \ return\ insert\_unique(key,\ std::forward<Args>(args)...);}}
\DoxyCodeLine{02317\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02318\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02319\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02320\ \textcolor{stringliteral}{template\ <typename\ InputIterator,\ typename>}}
\DoxyCodeLine{02321\ \textcolor{stringliteral}{void\ btree<P>::insert\_iterator\_unique(InputIterator\ b,\ InputIterator\ e,\ int)\ \{}}
\DoxyCodeLine{02322\ \textcolor{stringliteral}{\ \ for\ (;\ b\ !=\ e;\ ++b)\ \{}}
\DoxyCodeLine{02323\ \textcolor{stringliteral}{\ \ \ \ insert\_hint\_unique(end(),\ params\_type::key(*b),\ *b);}}
\DoxyCodeLine{02324\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02325\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02326\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02327\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02328\ \textcolor{stringliteral}{template\ <typename\ InputIterator>}}
\DoxyCodeLine{02329\ \textcolor{stringliteral}{void\ btree<P>::insert\_iterator\_unique(InputIterator\ b,\ InputIterator\ e,\ char)\ \{}}
\DoxyCodeLine{02330\ \textcolor{stringliteral}{\ \ for\ (;\ b\ !=\ e;\ ++b)\ \{}}
\DoxyCodeLine{02331\ \textcolor{stringliteral}{\ \ \ \ //\ Use\ a\ node\ handle\ to\ manage\ a\ temp\ slot.}}
\DoxyCodeLine{02332\ \textcolor{stringliteral}{\ \ \ \ auto\ node\_handle\ =}}
\DoxyCodeLine{02333\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ CommonAccess::Construct<node\_handle\_type>(get\_allocator(),\ *b);}}
\DoxyCodeLine{02334\ \textcolor{stringliteral}{\ \ \ \ slot\_type\ *slot\ =\ CommonAccess::GetSlot(node\_handle);}}
\DoxyCodeLine{02335\ \textcolor{stringliteral}{\ \ \ \ insert\_hint\_unique(end(),\ params\_type::key(slot),\ slot);}}
\DoxyCodeLine{02336\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02337\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02338\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02339\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02340\ \textcolor{stringliteral}{template\ <typename\ ValueType>}}
\DoxyCodeLine{02341\ \textcolor{stringliteral}{auto\ btree<P>::insert\_multi(const\ key\_type\ \&key,\ ValueType\ \&\&v)\ -\/>\ iterator\ \{}}
\DoxyCodeLine{02342\ \textcolor{stringliteral}{\ \ if\ (empty())\ \{}}
\DoxyCodeLine{02343\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ mutable\_rightmost()\ =\ new\_leaf\_root\_node(1);}}
\DoxyCodeLine{02344\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02345\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02346\ \textcolor{stringliteral}{\ \ iterator\ iter\ =\ internal\_upper\_bound(key);}}
\DoxyCodeLine{02347\ \textcolor{stringliteral}{\ \ if\ (iter.node\_\ ==\ nullptr)\ \{}}
\DoxyCodeLine{02348\ \textcolor{stringliteral}{\ \ \ \ iter\ =\ end();}}
\DoxyCodeLine{02349\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02350\ \textcolor{stringliteral}{\ \ return\ internal\_emplace(iter,\ std::forward<ValueType>(v));}}
\DoxyCodeLine{02351\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02352\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02353\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02354\ \textcolor{stringliteral}{template\ <typename\ ValueType>}}
\DoxyCodeLine{02355\ \textcolor{stringliteral}{auto\ btree<P>::insert\_hint\_multi(iterator\ position,\ ValueType\ \&\&v)\ -\/>\ iterator\ \{}}
\DoxyCodeLine{02356\ \textcolor{stringliteral}{\ \ if\ (!empty())\ \{}}
\DoxyCodeLine{02357\ \textcolor{stringliteral}{\ \ \ \ const\ key\_type\ \&key\ =\ params\_type::key(v);}}
\DoxyCodeLine{02358\ \textcolor{stringliteral}{\ \ \ \ if\ (position\ ==\ end()\ ||\ !compare\_keys(position.key(),\ key))\ \{}}
\DoxyCodeLine{02359\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (position\ ==\ begin()\ ||}}
\DoxyCodeLine{02360\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ !compare\_keys(key,\ std::prev(position).key()))\ \{}}
\DoxyCodeLine{02361\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ prev.key()\ <=\ key\ <=\ position.key()}}
\DoxyCodeLine{02362\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ internal\_emplace(position,\ std::forward<ValueType>(v));}}
\DoxyCodeLine{02363\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02364\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02365\ \textcolor{stringliteral}{\ \ \ \ \ \ ++position;}}
\DoxyCodeLine{02366\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (position\ ==\ end()\ ||\ !compare\_keys(position.key(),\ key))\ \{}}
\DoxyCodeLine{02367\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ \{original\ \`{}position`\}.key()\ <\ key\ <\ \{current\ \`{}position`\}.key()}}
\DoxyCodeLine{02368\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ internal\_emplace(position,\ std::forward<ValueType>(v));}}
\DoxyCodeLine{02369\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02370\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02371\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02372\ \textcolor{stringliteral}{\ \ return\ insert\_multi(std::forward<ValueType>(v));}}
\DoxyCodeLine{02373\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02374\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02375\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02376\ \textcolor{stringliteral}{template\ <typename\ InputIterator>}}
\DoxyCodeLine{02377\ \textcolor{stringliteral}{void\ btree<P>::insert\_iterator\_multi(InputIterator\ b,\ InputIterator\ e)\ \{}}
\DoxyCodeLine{02378\ \textcolor{stringliteral}{\ \ for\ (;\ b\ !=\ e;\ ++b)\ \{}}
\DoxyCodeLine{02379\ \textcolor{stringliteral}{\ \ \ \ insert\_hint\_multi(end(),\ *b);}}
\DoxyCodeLine{02380\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02381\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02382\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02383\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02384\ \textcolor{stringliteral}{auto\ btree<P>::operator=(const\ btree\ \&other)\ -\/>\ btree\ \&\ \{}}
\DoxyCodeLine{02385\ \textcolor{stringliteral}{\ \ if\ (this\ !=\ \&other)\ \{}}
\DoxyCodeLine{02386\ \textcolor{stringliteral}{\ \ \ \ clear();}}
\DoxyCodeLine{02387\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02388\ \textcolor{stringliteral}{\ \ \ \ *mutable\_key\_comp()\ =\ other.key\_comp();}}
\DoxyCodeLine{02389\ \textcolor{stringliteral}{\ \ \ \ if\ (absl::allocator\_traits<}}
\DoxyCodeLine{02390\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ allocator\_type>::propagate\_on\_container\_copy\_assignment::value)\ \{}}
\DoxyCodeLine{02391\ \textcolor{stringliteral}{\ \ \ \ \ \ *mutable\_allocator()\ =\ other.allocator();}}
\DoxyCodeLine{02392\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02393\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02394\ \textcolor{stringliteral}{\ \ \ \ copy\_or\_move\_values\_in\_order(other);}}
\DoxyCodeLine{02395\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02396\ \textcolor{stringliteral}{\ \ return\ *this;}}
\DoxyCodeLine{02397\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02398\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02399\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02400\ \textcolor{stringliteral}{auto\ btree<P>::operator=(btree\ \&\&other)\ noexcept\ -\/>\ btree\ \&\ \{}}
\DoxyCodeLine{02401\ \textcolor{stringliteral}{\ \ if\ (this\ !=\ \&other)\ \{}}
\DoxyCodeLine{02402\ \textcolor{stringliteral}{\ \ \ \ clear();}}
\DoxyCodeLine{02403\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02404\ \textcolor{stringliteral}{\ \ \ \ using\ std::swap;}}
\DoxyCodeLine{02405\ \textcolor{stringliteral}{\ \ \ \ if\ (absl::allocator\_traits<}}
\DoxyCodeLine{02406\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ allocator\_type>::propagate\_on\_container\_move\_assignment::value)\ \{}}
\DoxyCodeLine{02407\ \textcolor{stringliteral}{\ \ \ \ \ \ swap(root\_,\ other.root\_);}}
\DoxyCodeLine{02408\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Note:\ \`{}rightmost\_`\ also\ contains\ the\ allocator\ and\ the\ key\ comparator.}}
\DoxyCodeLine{02409\ \textcolor{stringliteral}{\ \ \ \ \ \ swap(rightmost\_,\ other.rightmost\_);}}
\DoxyCodeLine{02410\ \textcolor{stringliteral}{\ \ \ \ \ \ swap(size\_,\ other.size\_);}}
\DoxyCodeLine{02411\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02412\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (allocator()\ ==\ other.allocator())\ \{}}
\DoxyCodeLine{02413\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ swap(mutable\_root(),\ other.mutable\_root());}}
\DoxyCodeLine{02414\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ swap(*mutable\_key\_comp(),\ *other.mutable\_key\_comp());}}
\DoxyCodeLine{02415\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ swap(mutable\_rightmost(),\ other.mutable\_rightmost());}}
\DoxyCodeLine{02416\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ swap(size\_,\ other.size\_);}}
\DoxyCodeLine{02417\ \textcolor{stringliteral}{\ \ \ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02418\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ We\ aren't\ allowed\ to\ propagate\ the\ allocator\ and\ the\ allocator\ is}}
\DoxyCodeLine{02419\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ different\ so\ we\ can't\ take\ over\ its\ memory.\ We\ must\ move\ each\ element}}
\DoxyCodeLine{02420\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ individually.\ We\ need\ both\ \`{}other`\ and\ \`{}this`\ to\ have\ \`{}other`s\ key}}
\DoxyCodeLine{02421\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ comparator\ while\ moving\ the\ values\ so\ we\ can't\ swap\ the\ key}}
\DoxyCodeLine{02422\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ comparators.}}
\DoxyCodeLine{02423\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ *mutable\_key\_comp()\ =\ other.key\_comp();}}
\DoxyCodeLine{02424\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ copy\_or\_move\_values\_in\_order(other);}}
\DoxyCodeLine{02425\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02426\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02427\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02428\ \textcolor{stringliteral}{\ \ return\ *this;}}
\DoxyCodeLine{02429\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02430\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02431\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02432\ \textcolor{stringliteral}{auto\ btree<P>::erase(iterator\ iter)\ -\/>\ iterator\ \{}}
\DoxyCodeLine{02433\ \textcolor{stringliteral}{\ \ iter.node\_-\/>value\_destroy(static\_cast<field\_type>(iter.position\_),}}
\DoxyCodeLine{02434\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ mutable\_allocator());}}
\DoxyCodeLine{02435\ \textcolor{stringliteral}{\ \ iter.update\_generation();}}
\DoxyCodeLine{02436\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02437\ \textcolor{stringliteral}{\ \ const\ bool\ internal\_delete\ =\ iter.node\_-\/>is\_internal();}}
\DoxyCodeLine{02438\ \textcolor{stringliteral}{\ \ if\ (internal\_delete)\ \{}}
\DoxyCodeLine{02439\ \textcolor{stringliteral}{\ \ \ \ //\ Deletion\ of\ a\ value\ on\ an\ internal\ node.\ First,\ transfer\ the\ largest}}
\DoxyCodeLine{02440\ \textcolor{stringliteral}{\ \ \ \ //\ value\ from\ our\ left\ child\ here,\ then\ erase/rebalance\ from\ that\ position.}}
\DoxyCodeLine{02441\ \textcolor{stringliteral}{\ \ \ \ //\ We\ can\ get\ to\ the\ largest\ value\ from\ our\ left\ child\ by\ decrementing\ iter.}}
\DoxyCodeLine{02442\ \textcolor{stringliteral}{\ \ \ \ iterator\ internal\_iter(iter);}}
\DoxyCodeLine{02443\ \textcolor{stringliteral}{\ \ \ \ -\/-\/iter;}}
\DoxyCodeLine{02444\ \textcolor{stringliteral}{\ \ \ \ assert(iter.node\_-\/>is\_leaf());}}
\DoxyCodeLine{02445\ \textcolor{stringliteral}{\ \ \ \ internal\_iter.node\_-\/>transfer(}}
\DoxyCodeLine{02446\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ static\_cast<size\_type>(internal\_iter.position\_),}}
\DoxyCodeLine{02447\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ static\_cast<size\_type>(iter.position\_),\ iter.node\_,}}
\DoxyCodeLine{02448\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ mutable\_allocator());}}
\DoxyCodeLine{02449\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02450\ \textcolor{stringliteral}{\ \ \ \ //\ Shift\ values\ after\ erased\ position\ in\ leaf.\ In\ the\ internal\ case,\ we}}
\DoxyCodeLine{02451\ \textcolor{stringliteral}{\ \ \ \ //\ don't\ need\ to\ do\ this\ because\ the\ leaf\ position\ is\ the\ end\ of\ the\ node.}}
\DoxyCodeLine{02452\ \textcolor{stringliteral}{\ \ \ \ const\ field\_type\ transfer\_from\ =}}
\DoxyCodeLine{02453\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ static\_cast<field\_type>(iter.position\_\ +\ 1);}}
\DoxyCodeLine{02454\ \textcolor{stringliteral}{\ \ \ \ const\ field\_type\ num\_to\_transfer\ =\ iter.node\_-\/>finish()\ -\/\ transfer\_from;}}
\DoxyCodeLine{02455\ \textcolor{stringliteral}{\ \ \ \ iter.node\_-\/>transfer\_n(num\_to\_transfer,}}
\DoxyCodeLine{02456\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<size\_type>(iter.position\_),}}
\DoxyCodeLine{02457\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ transfer\_from,\ iter.node\_,\ mutable\_allocator());}}
\DoxyCodeLine{02458\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02459\ \textcolor{stringliteral}{\ \ //\ Update\ node\ finish\ and\ container\ size.}}
\DoxyCodeLine{02460\ \textcolor{stringliteral}{\ \ iter.node\_-\/>set\_finish(iter.node\_-\/>finish()\ -\/\ 1);}}
\DoxyCodeLine{02461\ \textcolor{stringliteral}{\ \ -\/-\/size\_;}}
\DoxyCodeLine{02462\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02463\ \textcolor{stringliteral}{\ \ //\ We\ want\ to\ return\ the\ next\ value\ after\ the\ one\ we\ just\ erased.\ If\ we}}
\DoxyCodeLine{02464\ \textcolor{stringliteral}{\ \ //\ erased\ from\ an\ internal\ node\ (internal\_delete\ ==\ true),\ then\ the\ next}}
\DoxyCodeLine{02465\ \textcolor{stringliteral}{\ \ //\ value\ is\ ++(++iter).\ If\ we\ erased\ from\ a\ leaf\ node\ (internal\_delete\ ==}}
\DoxyCodeLine{02466\ \textcolor{stringliteral}{\ \ //\ false)\ then\ the\ next\ value\ is\ ++iter.\ Note\ that\ ++iter\ may\ point\ to\ an}}
\DoxyCodeLine{02467\ \textcolor{stringliteral}{\ \ //\ internal\ node\ and\ the\ value\ in\ the\ internal\ node\ may\ move\ to\ a\ leaf\ node}}
\DoxyCodeLine{02468\ \textcolor{stringliteral}{\ \ //\ (iter.node\_)\ when\ rebalancing\ is\ performed\ at\ the\ leaf\ level.}}
\DoxyCodeLine{02469\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02470\ \textcolor{stringliteral}{\ \ iterator\ res\ =\ rebalance\_after\_delete(iter);}}
\DoxyCodeLine{02471\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02472\ \textcolor{stringliteral}{\ \ //\ If\ we\ erased\ from\ an\ internal\ node,\ advance\ the\ iterator.}}
\DoxyCodeLine{02473\ \textcolor{stringliteral}{\ \ if\ (internal\_delete)\ \{}}
\DoxyCodeLine{02474\ \textcolor{stringliteral}{\ \ \ \ ++res;}}
\DoxyCodeLine{02475\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02476\ \textcolor{stringliteral}{\ \ return\ res;}}
\DoxyCodeLine{02477\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02478\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02479\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02480\ \textcolor{stringliteral}{auto\ btree<P>::rebalance\_after\_delete(iterator\ iter)\ -\/>\ iterator\ \{}}
\DoxyCodeLine{02481\ \textcolor{stringliteral}{\ \ //\ Merge/rebalance\ as\ we\ walk\ back\ up\ the\ tree.}}
\DoxyCodeLine{02482\ \textcolor{stringliteral}{\ \ iterator\ res(iter);}}
\DoxyCodeLine{02483\ \textcolor{stringliteral}{\ \ bool\ first\_iteration\ =\ true;}}
\DoxyCodeLine{02484\ \textcolor{stringliteral}{\ \ for\ (;;)\ \{}}
\DoxyCodeLine{02485\ \textcolor{stringliteral}{\ \ \ \ if\ (iter.node\_\ ==\ root())\ \{}}
\DoxyCodeLine{02486\ \textcolor{stringliteral}{\ \ \ \ \ \ try\_shrink();}}
\DoxyCodeLine{02487\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (empty())\ \{}}
\DoxyCodeLine{02488\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ return\ end();}}
\DoxyCodeLine{02489\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02490\ \textcolor{stringliteral}{\ \ \ \ \ \ break;}}
\DoxyCodeLine{02491\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02492\ \textcolor{stringliteral}{\ \ \ \ if\ (iter.node\_-\/>count()\ >=\ kMinNodeValues)\ \{}}
\DoxyCodeLine{02493\ \textcolor{stringliteral}{\ \ \ \ \ \ break;}}
\DoxyCodeLine{02494\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02495\ \textcolor{stringliteral}{\ \ \ \ bool\ merged\ =\ try\_merge\_or\_rebalance(\&iter);}}
\DoxyCodeLine{02496\ \textcolor{stringliteral}{\ \ \ \ //\ On\ the\ first\ iteration,\ we\ should\ update\ \`{}res`\ with\ \`{}iter`\ because\ \`{}res`}}
\DoxyCodeLine{02497\ \textcolor{stringliteral}{\ \ \ \ //\ may\ have\ been\ invalidated.}}
\DoxyCodeLine{02498\ \textcolor{stringliteral}{\ \ \ \ if\ (first\_iteration)\ \{}}
\DoxyCodeLine{02499\ \textcolor{stringliteral}{\ \ \ \ \ \ res\ =\ iter;}}
\DoxyCodeLine{02500\ \textcolor{stringliteral}{\ \ \ \ \ \ first\_iteration\ =\ false;}}
\DoxyCodeLine{02501\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02502\ \textcolor{stringliteral}{\ \ \ \ if\ (!merged)\ \{}}
\DoxyCodeLine{02503\ \textcolor{stringliteral}{\ \ \ \ \ \ break;}}
\DoxyCodeLine{02504\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02505\ \textcolor{stringliteral}{\ \ \ \ iter.position\_\ =\ iter.node\_-\/>position();}}
\DoxyCodeLine{02506\ \textcolor{stringliteral}{\ \ \ \ iter.node\_\ =\ iter.node\_-\/>parent();}}
\DoxyCodeLine{02507\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02508\ \textcolor{stringliteral}{\ \ res.update\_generation();}}
\DoxyCodeLine{02509\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02510\ \textcolor{stringliteral}{\ \ //\ Adjust\ our\ return\ value.\ If\ we're\ pointing\ at\ the\ end\ of\ a\ node,\ advance}}
\DoxyCodeLine{02511\ \textcolor{stringliteral}{\ \ //\ the\ iterator.}}
\DoxyCodeLine{02512\ \textcolor{stringliteral}{\ \ if\ (res.position\_\ ==\ res.node\_-\/>finish())\ \{}}
\DoxyCodeLine{02513\ \textcolor{stringliteral}{\ \ \ \ res.position\_\ =\ res.node\_-\/>finish()\ -\/\ 1;}}
\DoxyCodeLine{02514\ \textcolor{stringliteral}{\ \ \ \ ++res;}}
\DoxyCodeLine{02515\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02516\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02517\ \textcolor{stringliteral}{\ \ return\ res;}}
\DoxyCodeLine{02518\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02519\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02520\ \textcolor{stringliteral}{//\ Note:\ we\ tried\ implementing\ this\ more\ efficiently\ by\ erasing\ all\ of\ the}}
\DoxyCodeLine{02521\ \textcolor{stringliteral}{//\ elements\ in\ [begin,\ end)\ at\ once\ and\ then\ doing\ rebalancing\ once\ at\ the\ end}}
\DoxyCodeLine{02522\ \textcolor{stringliteral}{//\ (rather\ than\ interleaving\ deletion\ and\ rebalancing),\ but\ that\ adds\ a\ lot\ of}}
\DoxyCodeLine{02523\ \textcolor{stringliteral}{//\ complexity,\ which\ seems\ to\ outweigh\ the\ performance\ win.}}
\DoxyCodeLine{02524\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02525\ \textcolor{stringliteral}{auto\ btree<P>::erase\_range(iterator\ begin,\ iterator\ end)}}
\DoxyCodeLine{02526\ \textcolor{stringliteral}{\ \ \ \ -\/>\ std::pair<size\_type,\ iterator>\ \{}}
\DoxyCodeLine{02527\ \textcolor{stringliteral}{\ \ size\_type\ count\ =\ static\_cast<size\_type>(end\ -\/\ begin);}}
\DoxyCodeLine{02528\ \textcolor{stringliteral}{\ \ assert(count\ >=\ 0);}}
\DoxyCodeLine{02529\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02530\ \textcolor{stringliteral}{\ \ if\ (count\ ==\ 0)\ \{}}
\DoxyCodeLine{02531\ \textcolor{stringliteral}{\ \ \ \ return\ \{0,\ begin\};}}
\DoxyCodeLine{02532\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02533\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02534\ \textcolor{stringliteral}{\ \ if\ (static\_cast<size\_type>(count)\ ==\ size\_)\ \{}}
\DoxyCodeLine{02535\ \textcolor{stringliteral}{\ \ \ \ clear();}}
\DoxyCodeLine{02536\ \textcolor{stringliteral}{\ \ \ \ return\ \{count,\ this-\/>end()\};}}
\DoxyCodeLine{02537\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02538\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02539\ \textcolor{stringliteral}{\ \ if\ (begin.node\_\ ==\ end.node\_)\ \{}}
\DoxyCodeLine{02540\ \textcolor{stringliteral}{\ \ \ \ assert(end.position\_\ >\ begin.position\_);}}
\DoxyCodeLine{02541\ \textcolor{stringliteral}{\ \ \ \ begin.node\_-\/>remove\_values(}}
\DoxyCodeLine{02542\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ static\_cast<field\_type>(begin.position\_),}}
\DoxyCodeLine{02543\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ static\_cast<field\_type>(end.position\_\ -\/\ begin.position\_),}}
\DoxyCodeLine{02544\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ mutable\_allocator());}}
\DoxyCodeLine{02545\ \textcolor{stringliteral}{\ \ \ \ size\_\ -\/=\ count;}}
\DoxyCodeLine{02546\ \textcolor{stringliteral}{\ \ \ \ return\ \{count,\ rebalance\_after\_delete(begin)\};}}
\DoxyCodeLine{02547\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02548\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02549\ \textcolor{stringliteral}{\ \ const\ size\_type\ target\_size\ =\ size\_\ -\/\ count;}}
\DoxyCodeLine{02550\ \textcolor{stringliteral}{\ \ while\ (size\_\ >\ target\_size)\ \{}}
\DoxyCodeLine{02551\ \textcolor{stringliteral}{\ \ \ \ if\ (begin.node\_-\/>is\_leaf())\ \{}}
\DoxyCodeLine{02552\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ size\_type\ remaining\_to\_erase\ =\ size\_\ -\/\ target\_size;}}
\DoxyCodeLine{02553\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ size\_type\ remaining\_in\_node\ =}}
\DoxyCodeLine{02554\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ static\_cast<size\_type>(begin.node\_-\/>finish()\ -\/\ begin.position\_);}}
\DoxyCodeLine{02555\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ field\_type\ to\_erase\ =\ static\_cast<field\_type>(}}
\DoxyCodeLine{02556\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ (std::min)(remaining\_to\_erase,\ remaining\_in\_node));}}
\DoxyCodeLine{02557\ \textcolor{stringliteral}{\ \ \ \ \ \ begin.node\_-\/>remove\_values(static\_cast<field\_type>(begin.position\_),}}
\DoxyCodeLine{02558\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ to\_erase,\ mutable\_allocator());}}
\DoxyCodeLine{02559\ \textcolor{stringliteral}{\ \ \ \ \ \ size\_\ -\/=\ to\_erase;}}
\DoxyCodeLine{02560\ \textcolor{stringliteral}{\ \ \ \ \ \ begin\ =\ rebalance\_after\_delete(begin);}}
\DoxyCodeLine{02561\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02562\ \textcolor{stringliteral}{\ \ \ \ \ \ begin\ =\ erase(begin);}}
\DoxyCodeLine{02563\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02564\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02565\ \textcolor{stringliteral}{\ \ begin.update\_generation();}}
\DoxyCodeLine{02566\ \textcolor{stringliteral}{\ \ return\ \{count,\ begin\};}}
\DoxyCodeLine{02567\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02568\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02569\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02570\ \textcolor{stringliteral}{void\ btree<P>::clear()\ \{}}
\DoxyCodeLine{02571\ \textcolor{stringliteral}{\ \ if\ (!empty())\ \{}}
\DoxyCodeLine{02572\ \textcolor{stringliteral}{\ \ \ \ node\_type::clear\_and\_delete(root(),\ mutable\_allocator());}}
\DoxyCodeLine{02573\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02574\ \textcolor{stringliteral}{\ \ mutable\_root()\ =\ mutable\_rightmost()\ =\ EmptyNode();}}
\DoxyCodeLine{02575\ \textcolor{stringliteral}{\ \ size\_\ =\ 0;}}
\DoxyCodeLine{02576\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02577\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02578\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02579\ \textcolor{stringliteral}{void\ btree<P>::swap(btree\ \&other)\ \{}}
\DoxyCodeLine{02580\ \textcolor{stringliteral}{\ \ using\ std::swap;}}
\DoxyCodeLine{02581\ \textcolor{stringliteral}{\ \ if\ (absl::allocator\_traits<}}
\DoxyCodeLine{02582\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ allocator\_type>::propagate\_on\_container\_swap::value)\ \{}}
\DoxyCodeLine{02583\ \textcolor{stringliteral}{\ \ \ \ //\ Note:\ \`{}rightmost\_`\ also\ contains\ the\ allocator\ and\ the\ key\ comparator.}}
\DoxyCodeLine{02584\ \textcolor{stringliteral}{\ \ \ \ swap(rightmost\_,\ other.rightmost\_);}}
\DoxyCodeLine{02585\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02586\ \textcolor{stringliteral}{\ \ \ \ //\ It's\ undefined\ behavior\ if\ the\ allocators\ are\ unequal\ here.}}
\DoxyCodeLine{02587\ \textcolor{stringliteral}{\ \ \ \ assert(allocator()\ ==\ other.allocator());}}
\DoxyCodeLine{02588\ \textcolor{stringliteral}{\ \ \ \ swap(mutable\_rightmost(),\ other.mutable\_rightmost());}}
\DoxyCodeLine{02589\ \textcolor{stringliteral}{\ \ \ \ swap(*mutable\_key\_comp(),\ *other.mutable\_key\_comp());}}
\DoxyCodeLine{02590\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02591\ \textcolor{stringliteral}{\ \ swap(mutable\_root(),\ other.mutable\_root());}}
\DoxyCodeLine{02592\ \textcolor{stringliteral}{\ \ swap(size\_,\ other.size\_);}}
\DoxyCodeLine{02593\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02594\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02595\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02596\ \textcolor{stringliteral}{void\ btree<P>::verify()\ const\ \{}}
\DoxyCodeLine{02597\ \textcolor{stringliteral}{\ \ assert(root()\ !=\ nullptr);}}
\DoxyCodeLine{02598\ \textcolor{stringliteral}{\ \ assert(leftmost()\ !=\ nullptr);}}
\DoxyCodeLine{02599\ \textcolor{stringliteral}{\ \ assert(rightmost()\ !=\ nullptr);}}
\DoxyCodeLine{02600\ \textcolor{stringliteral}{\ \ assert(empty()\ ||\ size()\ ==\ internal\_verify(root(),\ nullptr,\ nullptr));}}
\DoxyCodeLine{02601\ \textcolor{stringliteral}{\ \ assert(leftmost()\ ==\ (++const\_iterator(root(),\ -\/1)).node\_);}}
\DoxyCodeLine{02602\ \textcolor{stringliteral}{\ \ assert(rightmost()\ ==\ (-\/-\/const\_iterator(root(),\ root()-\/>finish())).node\_);}}
\DoxyCodeLine{02603\ \textcolor{stringliteral}{\ \ assert(leftmost()-\/>is\_leaf());}}
\DoxyCodeLine{02604\ \textcolor{stringliteral}{\ \ assert(rightmost()-\/>is\_leaf());}}
\DoxyCodeLine{02605\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02606\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02607\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02608\ \textcolor{stringliteral}{void\ btree<P>::rebalance\_or\_split(iterator\ *iter)\ \{}}
\DoxyCodeLine{02609\ \textcolor{stringliteral}{\ \ node\_type\ *\&node\ =\ iter-\/>node\_;}}
\DoxyCodeLine{02610\ \textcolor{stringliteral}{\ \ int\ \&insert\_position\ =\ iter-\/>position\_;}}
\DoxyCodeLine{02611\ \textcolor{stringliteral}{\ \ assert(node-\/>count()\ ==\ node-\/>max\_count());}}
\DoxyCodeLine{02612\ \textcolor{stringliteral}{\ \ assert(kNodeSlots\ ==\ node-\/>max\_count());}}
\DoxyCodeLine{02613\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02614\ \textcolor{stringliteral}{\ \ //\ First\ try\ to\ make\ room\ on\ the\ node\ by\ rebalancing.}}
\DoxyCodeLine{02615\ \textcolor{stringliteral}{\ \ node\_type\ *parent\ =\ node-\/>parent();}}
\DoxyCodeLine{02616\ \textcolor{stringliteral}{\ \ if\ (node\ !=\ root())\ \{}}
\DoxyCodeLine{02617\ \textcolor{stringliteral}{\ \ \ \ if\ (node-\/>position()\ >\ parent-\/>start())\ \{}}
\DoxyCodeLine{02618\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Try\ rebalancing\ with\ our\ left\ sibling.}}
\DoxyCodeLine{02619\ \textcolor{stringliteral}{\ \ \ \ \ \ node\_type\ *left\ =\ parent-\/>child(node-\/>position()\ -\/\ 1);}}
\DoxyCodeLine{02620\ \textcolor{stringliteral}{\ \ \ \ \ \ assert(left-\/>max\_count()\ ==\ kNodeSlots);}}
\DoxyCodeLine{02621\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (left-\/>count()\ <\ kNodeSlots)\ \{}}
\DoxyCodeLine{02622\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ We\ bias\ rebalancing\ based\ on\ the\ position\ being\ inserted.\ If\ we're}}
\DoxyCodeLine{02623\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ inserting\ at\ the\ end\ of\ the\ right\ node\ then\ we\ bias\ rebalancing\ to}}
\DoxyCodeLine{02624\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ fill\ up\ the\ left\ node.}}
\DoxyCodeLine{02625\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ field\_type\ to\_move\ =}}
\DoxyCodeLine{02626\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ (kNodeSlots\ -\/\ left-\/>count())\ /}}
\DoxyCodeLine{02627\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ (1\ +\ (static\_cast<field\_type>(insert\_position)\ <\ kNodeSlots));}}
\DoxyCodeLine{02628\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ to\_move\ =\ (std::max)(field\_type\{1\},\ to\_move);}}
\DoxyCodeLine{02629\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02630\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ if\ (static\_cast<field\_type>(insert\_position)\ -\/\ to\_move\ >=}}
\DoxyCodeLine{02631\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node-\/>start()\ ||}}
\DoxyCodeLine{02632\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ left-\/>count()\ +\ to\_move\ <\ kNodeSlots)\ \{}}
\DoxyCodeLine{02633\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ left-\/>rebalance\_right\_to\_left(to\_move,\ node,\ mutable\_allocator());}}
\DoxyCodeLine{02634\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02635\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ assert(node-\/>max\_count()\ -\/\ node-\/>count()\ ==\ to\_move);}}
\DoxyCodeLine{02636\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ insert\_position\ =\ static\_cast<int>(}}
\DoxyCodeLine{02637\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ static\_cast<field\_type>(insert\_position)\ -\/\ to\_move);}}
\DoxyCodeLine{02638\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ if\ (insert\_position\ <\ node-\/>start())\ \{}}
\DoxyCodeLine{02639\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ insert\_position\ =\ insert\_position\ +\ left-\/>count()\ +\ 1;}}
\DoxyCodeLine{02640\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ node\ =\ left;}}
\DoxyCodeLine{02641\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{02642\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02643\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ assert(node-\/>count()\ <\ node-\/>max\_count());}}
\DoxyCodeLine{02644\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ return;}}
\DoxyCodeLine{02645\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{02646\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02647\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02648\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02649\ \textcolor{stringliteral}{\ \ \ \ if\ (node-\/>position()\ <\ parent-\/>finish())\ \{}}
\DoxyCodeLine{02650\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Try\ rebalancing\ with\ our\ right\ sibling.}}
\DoxyCodeLine{02651\ \textcolor{stringliteral}{\ \ \ \ \ \ node\_type\ *right\ =\ parent-\/>child(node-\/>position()\ +\ 1);}}
\DoxyCodeLine{02652\ \textcolor{stringliteral}{\ \ \ \ \ \ assert(right-\/>max\_count()\ ==\ kNodeSlots);}}
\DoxyCodeLine{02653\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (right-\/>count()\ <\ kNodeSlots)\ \{}}
\DoxyCodeLine{02654\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ We\ bias\ rebalancing\ based\ on\ the\ position\ being\ inserted.\ If\ we're}}
\DoxyCodeLine{02655\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ inserting\ at\ the\ beginning\ of\ the\ left\ node\ then\ we\ bias\ rebalancing}}
\DoxyCodeLine{02656\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ //\ to\ fill\ up\ the\ right\ node.}}
\DoxyCodeLine{02657\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ field\_type\ to\_move\ =\ (kNodeSlots\ -\/\ right-\/>count())\ /}}
\DoxyCodeLine{02658\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ (1\ +\ (insert\_position\ >\ node-\/>start()));}}
\DoxyCodeLine{02659\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ to\_move\ =\ (std::max)(field\_type\{1\},\ to\_move);}}
\DoxyCodeLine{02660\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02661\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ if\ (static\_cast<field\_type>(insert\_position)\ <=}}
\DoxyCodeLine{02662\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node-\/>finish()\ -\/\ to\_move\ ||}}
\DoxyCodeLine{02663\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ right-\/>count()\ +\ to\_move\ <\ kNodeSlots)\ \{}}
\DoxyCodeLine{02664\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ node-\/>rebalance\_left\_to\_right(to\_move,\ right,\ mutable\_allocator());}}
\DoxyCodeLine{02665\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02666\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ if\ (insert\_position\ >\ node-\/>finish())\ \{}}
\DoxyCodeLine{02667\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ insert\_position\ =\ insert\_position\ -\/\ node-\/>count()\ -\/\ 1;}}
\DoxyCodeLine{02668\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ node\ =\ right;}}
\DoxyCodeLine{02669\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{02670\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02671\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ assert(node-\/>count()\ <\ node-\/>max\_count());}}
\DoxyCodeLine{02672\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ return;}}
\DoxyCodeLine{02673\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \}}}
\DoxyCodeLine{02674\ \textcolor{stringliteral}{\ \ \ \ \ \ \}}}
\DoxyCodeLine{02675\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02676\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02677\ \textcolor{stringliteral}{\ \ \ \ //\ Rebalancing\ failed,\ make\ sure\ there\ is\ room\ on\ the\ parent\ node\ for\ a\ new}}
\DoxyCodeLine{02678\ \textcolor{stringliteral}{\ \ \ \ //\ value.}}
\DoxyCodeLine{02679\ \textcolor{stringliteral}{\ \ \ \ assert(parent-\/>max\_count()\ ==\ kNodeSlots);}}
\DoxyCodeLine{02680\ \textcolor{stringliteral}{\ \ \ \ if\ (parent-\/>count()\ ==\ kNodeSlots)\ \{}}
\DoxyCodeLine{02681\ \textcolor{stringliteral}{\ \ \ \ \ \ iterator\ parent\_iter(parent,\ node-\/>position());}}
\DoxyCodeLine{02682\ \textcolor{stringliteral}{\ \ \ \ \ \ rebalance\_or\_split(\&parent\_iter);}}
\DoxyCodeLine{02683\ \textcolor{stringliteral}{\ \ \ \ \ \ parent\ =\ node-\/>parent();}}
\DoxyCodeLine{02684\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02685\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02686\ \textcolor{stringliteral}{\ \ \ \ //\ Rebalancing\ not\ possible\ because\ this\ is\ the\ root\ node.}}
\DoxyCodeLine{02687\ \textcolor{stringliteral}{\ \ \ \ //\ Create\ a\ new\ root\ node\ and\ set\ the\ current\ root\ node\ as\ the\ child\ of\ the}}
\DoxyCodeLine{02688\ \textcolor{stringliteral}{\ \ \ \ //\ new\ root.}}
\DoxyCodeLine{02689\ \textcolor{stringliteral}{\ \ \ \ parent\ =\ new\_internal\_node(/*position=*/0,\ parent);}}
\DoxyCodeLine{02690\ \textcolor{stringliteral}{\ \ \ \ parent-\/>set\_generation(root()-\/>generation());}}
\DoxyCodeLine{02691\ \textcolor{stringliteral}{\ \ \ \ parent-\/>init\_child(parent-\/>start(),\ node);}}
\DoxyCodeLine{02692\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ parent;}}
\DoxyCodeLine{02693\ \textcolor{stringliteral}{\ \ \ \ //\ If\ the\ former\ root\ was\ a\ leaf\ node,\ then\ it's\ now\ the\ rightmost\ node.}}
\DoxyCodeLine{02694\ \textcolor{stringliteral}{\ \ \ \ assert(parent-\/>start\_child()-\/>is\_internal()\ ||}}
\DoxyCodeLine{02695\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ parent-\/>start\_child()\ ==\ rightmost());}}
\DoxyCodeLine{02696\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02697\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02698\ \textcolor{stringliteral}{\ \ //\ Split\ the\ node.}}
\DoxyCodeLine{02699\ \textcolor{stringliteral}{\ \ node\_type\ *split\_node;}}
\DoxyCodeLine{02700\ \textcolor{stringliteral}{\ \ if\ (node-\/>is\_leaf())\ \{}}
\DoxyCodeLine{02701\ \textcolor{stringliteral}{\ \ \ \ split\_node\ =\ new\_leaf\_node(node-\/>position()\ +\ 1,\ parent);}}
\DoxyCodeLine{02702\ \textcolor{stringliteral}{\ \ \ \ node-\/>split(insert\_position,\ split\_node,\ mutable\_allocator());}}
\DoxyCodeLine{02703\ \textcolor{stringliteral}{\ \ \ \ if\ (rightmost()\ ==\ node)\ mutable\_rightmost()\ =\ split\_node;}}
\DoxyCodeLine{02704\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02705\ \textcolor{stringliteral}{\ \ \ \ split\_node\ =\ new\_internal\_node(node-\/>position()\ +\ 1,\ parent);}}
\DoxyCodeLine{02706\ \textcolor{stringliteral}{\ \ \ \ node-\/>split(insert\_position,\ split\_node,\ mutable\_allocator());}}
\DoxyCodeLine{02707\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02708\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02709\ \textcolor{stringliteral}{\ \ if\ (insert\_position\ >\ node-\/>finish())\ \{}}
\DoxyCodeLine{02710\ \textcolor{stringliteral}{\ \ \ \ insert\_position\ =\ insert\_position\ -\/\ node-\/>count()\ -\/\ 1;}}
\DoxyCodeLine{02711\ \textcolor{stringliteral}{\ \ \ \ node\ =\ split\_node;}}
\DoxyCodeLine{02712\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02713\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02714\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02715\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02716\ \textcolor{stringliteral}{void\ btree<P>::merge\_nodes(node\_type\ *left,\ node\_type\ *right)\ \{}}
\DoxyCodeLine{02717\ \textcolor{stringliteral}{\ \ left-\/>merge(right,\ mutable\_allocator());}}
\DoxyCodeLine{02718\ \textcolor{stringliteral}{\ \ if\ (rightmost()\ ==\ right)\ mutable\_rightmost()\ =\ left;}}
\DoxyCodeLine{02719\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02720\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02721\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02722\ \textcolor{stringliteral}{bool\ btree<P>::try\_merge\_or\_rebalance(iterator\ *iter)\ \{}}
\DoxyCodeLine{02723\ \textcolor{stringliteral}{\ \ node\_type\ *parent\ =\ iter-\/>node\_-\/>parent();}}
\DoxyCodeLine{02724\ \textcolor{stringliteral}{\ \ if\ (iter-\/>node\_-\/>position()\ >\ parent-\/>start())\ \{}}
\DoxyCodeLine{02725\ \textcolor{stringliteral}{\ \ \ \ //\ Try\ merging\ with\ our\ left\ sibling.}}
\DoxyCodeLine{02726\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *left\ =\ parent-\/>child(iter-\/>node\_-\/>position()\ -\/\ 1);}}
\DoxyCodeLine{02727\ \textcolor{stringliteral}{\ \ \ \ assert(left-\/>max\_count()\ ==\ kNodeSlots);}}
\DoxyCodeLine{02728\ \textcolor{stringliteral}{\ \ \ \ if\ (1U\ +\ left-\/>count()\ +\ iter-\/>node\_-\/>count()\ <=\ kNodeSlots)\ \{}}
\DoxyCodeLine{02729\ \textcolor{stringliteral}{\ \ \ \ \ \ iter-\/>position\_\ +=\ 1\ +\ left-\/>count();}}
\DoxyCodeLine{02730\ \textcolor{stringliteral}{\ \ \ \ \ \ merge\_nodes(left,\ iter-\/>node\_);}}
\DoxyCodeLine{02731\ \textcolor{stringliteral}{\ \ \ \ \ \ iter-\/>node\_\ =\ left;}}
\DoxyCodeLine{02732\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ true;}}
\DoxyCodeLine{02733\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02734\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02735\ \textcolor{stringliteral}{\ \ if\ (iter-\/>node\_-\/>position()\ <\ parent-\/>finish())\ \{}}
\DoxyCodeLine{02736\ \textcolor{stringliteral}{\ \ \ \ //\ Try\ merging\ with\ our\ right\ sibling.}}
\DoxyCodeLine{02737\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *right\ =\ parent-\/>child(iter-\/>node\_-\/>position()\ +\ 1);}}
\DoxyCodeLine{02738\ \textcolor{stringliteral}{\ \ \ \ assert(right-\/>max\_count()\ ==\ kNodeSlots);}}
\DoxyCodeLine{02739\ \textcolor{stringliteral}{\ \ \ \ if\ (1U\ +\ iter-\/>node\_-\/>count()\ +\ right-\/>count()\ <=\ kNodeSlots)\ \{}}
\DoxyCodeLine{02740\ \textcolor{stringliteral}{\ \ \ \ \ \ merge\_nodes(iter-\/>node\_,\ right);}}
\DoxyCodeLine{02741\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ true;}}
\DoxyCodeLine{02742\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02743\ \textcolor{stringliteral}{\ \ \ \ //\ Try\ rebalancing\ with\ our\ right\ sibling.\ We\ don't\ perform\ rebalancing\ if}}
\DoxyCodeLine{02744\ \textcolor{stringliteral}{\ \ \ \ //\ we\ deleted\ the\ first\ element\ from\ iter-\/>node\_\ and\ the\ node\ is\ not}}
\DoxyCodeLine{02745\ \textcolor{stringliteral}{\ \ \ \ //\ empty.\ This\ is\ a\ small\ optimization\ for\ the\ common\ pattern\ of\ deleting}}
\DoxyCodeLine{02746\ \textcolor{stringliteral}{\ \ \ \ //\ from\ the\ front\ of\ the\ tree.}}
\DoxyCodeLine{02747\ \textcolor{stringliteral}{\ \ \ \ if\ (right-\/>count()\ >\ kMinNodeValues\ \&\&}}
\DoxyCodeLine{02748\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ (iter-\/>node\_-\/>count()\ ==\ 0\ ||\ iter-\/>position\_\ >\ iter-\/>node\_-\/>start()))\ \{}}
\DoxyCodeLine{02749\ \textcolor{stringliteral}{\ \ \ \ \ \ field\_type\ to\_move\ =\ (right-\/>count()\ -\/\ iter-\/>node\_-\/>count())\ /\ 2;}}
\DoxyCodeLine{02750\ \textcolor{stringliteral}{\ \ \ \ \ \ to\_move\ =}}
\DoxyCodeLine{02751\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ (std::min)(to\_move,\ static\_cast<field\_type>(right-\/>count()\ -\/\ 1));}}
\DoxyCodeLine{02752\ \textcolor{stringliteral}{\ \ \ \ \ \ iter-\/>node\_-\/>rebalance\_right\_to\_left(to\_move,\ right,\ mutable\_allocator());}}
\DoxyCodeLine{02753\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ false;}}
\DoxyCodeLine{02754\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02755\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02756\ \textcolor{stringliteral}{\ \ if\ (iter-\/>node\_-\/>position()\ >\ parent-\/>start())\ \{}}
\DoxyCodeLine{02757\ \textcolor{stringliteral}{\ \ \ \ //\ Try\ rebalancing\ with\ our\ left\ sibling.\ We\ don't\ perform\ rebalancing\ if}}
\DoxyCodeLine{02758\ \textcolor{stringliteral}{\ \ \ \ //\ we\ deleted\ the\ last\ element\ from\ iter-\/>node\_\ and\ the\ node\ is\ not}}
\DoxyCodeLine{02759\ \textcolor{stringliteral}{\ \ \ \ //\ empty.\ This\ is\ a\ small\ optimization\ for\ the\ common\ pattern\ of\ deleting}}
\DoxyCodeLine{02760\ \textcolor{stringliteral}{\ \ \ \ //\ from\ the\ back\ of\ the\ tree.}}
\DoxyCodeLine{02761\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *left\ =\ parent-\/>child(iter-\/>node\_-\/>position()\ -\/\ 1);}}
\DoxyCodeLine{02762\ \textcolor{stringliteral}{\ \ \ \ if\ (left-\/>count()\ >\ kMinNodeValues\ \&\&}}
\DoxyCodeLine{02763\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ (iter-\/>node\_-\/>count()\ ==\ 0\ ||}}
\DoxyCodeLine{02764\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ iter-\/>position\_\ <\ iter-\/>node\_-\/>finish()))\ \{}}
\DoxyCodeLine{02765\ \textcolor{stringliteral}{\ \ \ \ \ \ field\_type\ to\_move\ =\ (left-\/>count()\ -\/\ iter-\/>node\_-\/>count())\ /\ 2;}}
\DoxyCodeLine{02766\ \textcolor{stringliteral}{\ \ \ \ \ \ to\_move\ =\ (std::min)(to\_move,\ static\_cast<field\_type>(left-\/>count()\ -\/\ 1));}}
\DoxyCodeLine{02767\ \textcolor{stringliteral}{\ \ \ \ \ \ left-\/>rebalance\_left\_to\_right(to\_move,\ iter-\/>node\_,\ mutable\_allocator());}}
\DoxyCodeLine{02768\ \textcolor{stringliteral}{\ \ \ \ \ \ iter-\/>position\_\ +=\ to\_move;}}
\DoxyCodeLine{02769\ \textcolor{stringliteral}{\ \ \ \ \ \ return\ false;}}
\DoxyCodeLine{02770\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02771\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02772\ \textcolor{stringliteral}{\ \ return\ false;}}
\DoxyCodeLine{02773\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02774\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02775\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02776\ \textcolor{stringliteral}{void\ btree<P>::try\_shrink()\ \{}}
\DoxyCodeLine{02777\ \textcolor{stringliteral}{\ \ node\_type\ *orig\_root\ =\ root();}}
\DoxyCodeLine{02778\ \textcolor{stringliteral}{\ \ if\ (orig\_root-\/>count()\ >\ 0)\ \{}}
\DoxyCodeLine{02779\ \textcolor{stringliteral}{\ \ \ \ return;}}
\DoxyCodeLine{02780\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02781\ \textcolor{stringliteral}{\ \ //\ Deleted\ the\ last\ item\ on\ the\ root\ node,\ shrink\ the\ height\ of\ the\ tree.}}
\DoxyCodeLine{02782\ \textcolor{stringliteral}{\ \ if\ (orig\_root-\/>is\_leaf())\ \{}}
\DoxyCodeLine{02783\ \textcolor{stringliteral}{\ \ \ \ assert(size()\ ==\ 0);}}
\DoxyCodeLine{02784\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ mutable\_rightmost()\ =\ EmptyNode();}}
\DoxyCodeLine{02785\ \textcolor{stringliteral}{\ \ \}\ else\ \{}}
\DoxyCodeLine{02786\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *child\ =\ orig\_root-\/>start\_child();}}
\DoxyCodeLine{02787\ \textcolor{stringliteral}{\ \ \ \ child-\/>make\_root();}}
\DoxyCodeLine{02788\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ child;}}
\DoxyCodeLine{02789\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02790\ \textcolor{stringliteral}{\ \ node\_type::clear\_and\_delete(orig\_root,\ mutable\_allocator());}}
\DoxyCodeLine{02791\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02792\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02793\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02794\ \textcolor{stringliteral}{template\ <typename\ IterType>}}
\DoxyCodeLine{02795\ \textcolor{stringliteral}{inline\ IterType\ btree<P>::internal\_last(IterType\ iter)\ \{}}
\DoxyCodeLine{02796\ \textcolor{stringliteral}{\ \ assert(iter.node\_\ !=\ nullptr);}}
\DoxyCodeLine{02797\ \textcolor{stringliteral}{\ \ while\ (iter.position\_\ ==\ iter.node\_-\/>finish())\ \{}}
\DoxyCodeLine{02798\ \textcolor{stringliteral}{\ \ \ \ iter.position\_\ =\ iter.node\_-\/>position();}}
\DoxyCodeLine{02799\ \textcolor{stringliteral}{\ \ \ \ iter.node\_\ =\ iter.node\_-\/>parent();}}
\DoxyCodeLine{02800\ \textcolor{stringliteral}{\ \ \ \ if\ (iter.node\_-\/>is\_leaf())\ \{}}
\DoxyCodeLine{02801\ \textcolor{stringliteral}{\ \ \ \ \ \ iter.node\_\ =\ nullptr;}}
\DoxyCodeLine{02802\ \textcolor{stringliteral}{\ \ \ \ \ \ break;}}
\DoxyCodeLine{02803\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02804\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02805\ \textcolor{stringliteral}{\ \ iter.update\_generation();}}
\DoxyCodeLine{02806\ \textcolor{stringliteral}{\ \ return\ iter;}}
\DoxyCodeLine{02807\ \textcolor{stringliteral}{\}}}
\DoxyCodeLine{02808\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02809\ \textcolor{stringliteral}{template\ <typename\ P>}}
\DoxyCodeLine{02810\ \textcolor{stringliteral}{template\ <typename...\ Args>}}
\DoxyCodeLine{02811\ \textcolor{stringliteral}{inline\ auto\ btree<P>::internal\_emplace(iterator\ iter,\ Args\ \&\&...args)}}
\DoxyCodeLine{02812\ \textcolor{stringliteral}{\ \ \ \ -\/>\ iterator\ \{}}
\DoxyCodeLine{02813\ \textcolor{stringliteral}{\ \ if\ (iter.node\_-\/>is\_internal())\ \{}}
\DoxyCodeLine{02814\ \textcolor{stringliteral}{\ \ \ \ //\ We\ can't\ insert\ on\ an\ internal\ node.\ Instead,\ we'll\ insert\ after\ the}}
\DoxyCodeLine{02815\ \textcolor{stringliteral}{\ \ \ \ //\ previous\ value\ which\ is\ guaranteed\ to\ be\ on\ a\ leaf\ node.}}
\DoxyCodeLine{02816\ \textcolor{stringliteral}{\ \ \ \ -\/-\/iter;}}
\DoxyCodeLine{02817\ \textcolor{stringliteral}{\ \ \ \ ++iter.position\_;}}
\DoxyCodeLine{02818\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02819\ \textcolor{stringliteral}{\ \ const\ field\_type\ max\_count\ =\ iter.node\_-\/>max\_count();}}
\DoxyCodeLine{02820\ \textcolor{stringliteral}{\ \ allocator\_type\ *alloc\ =\ mutable\_allocator();}}
\DoxyCodeLine{02821\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02822\ \textcolor{stringliteral}{\ \ const\ auto\ transfer\_and\_delete\ =\ [\&](node\_type\ *old\_node,}}
\DoxyCodeLine{02823\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ node\_type\ *new\_node)\ \{}}
\DoxyCodeLine{02824\ \textcolor{stringliteral}{\ \ \ \ new\_node-\/>transfer\_n(old\_node-\/>count(),\ new\_node-\/>start(),}}
\DoxyCodeLine{02825\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ old\_node-\/>start(),\ old\_node,\ alloc);}}
\DoxyCodeLine{02826\ \textcolor{stringliteral}{\ \ \ \ new\_node-\/>set\_finish(old\_node-\/>finish());}}
\DoxyCodeLine{02827\ \textcolor{stringliteral}{\ \ \ \ old\_node-\/>set\_finish(old\_node-\/>start());}}
\DoxyCodeLine{02828\ \textcolor{stringliteral}{\ \ \ \ new\_node-\/>set\_generation(old\_node-\/>generation());}}
\DoxyCodeLine{02829\ \textcolor{stringliteral}{\ \ \ \ node\_type::clear\_and\_delete(old\_node,\ alloc);}}
\DoxyCodeLine{02830\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{02831\ \textcolor{stringliteral}{\ \ const\ auto\ replace\_leaf\_root\_node\ =\ [\&](field\_type\ new\_node\_size)\ \{}}
\DoxyCodeLine{02832\ \textcolor{stringliteral}{\ \ \ \ assert(iter.node\_\ ==\ root());}}
\DoxyCodeLine{02833\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *old\_root\ =\ iter.node\_;}}
\DoxyCodeLine{02834\ \textcolor{stringliteral}{\ \ \ \ node\_type\ *new\_root\ =\ iter.node\_\ =\ new\_leaf\_root\_node(new\_node\_size);}}
\DoxyCodeLine{02835\ \textcolor{stringliteral}{\ \ \ \ transfer\_and\_delete(old\_root,\ new\_root);}}
\DoxyCodeLine{02836\ \textcolor{stringliteral}{\ \ \ \ mutable\_root()\ =\ mutable\_rightmost()\ =\ new\_root;}}
\DoxyCodeLine{02837\ \textcolor{stringliteral}{\ \ \};}}
\DoxyCodeLine{02838\ \textcolor{stringliteral}{}}
\DoxyCodeLine{02839\ \textcolor{stringliteral}{\ \ bool\ replaced\_node\ =\ false;}}
\DoxyCodeLine{02840\ \textcolor{stringliteral}{\ \ if\ (iter.node\_-\/>count()\ ==\ max\_count)\ \{}}
\DoxyCodeLine{02841\ \textcolor{stringliteral}{\ \ \ \ //\ Make\ room\ in\ the\ leaf\ for\ the\ new\ item.}}
\DoxyCodeLine{02842\ \textcolor{stringliteral}{\ \ \ \ if\ (max\_count\ <\ kNodeSlots)\ \{}}
\DoxyCodeLine{02843\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ Insertion\ into\ the\ root\ where\ the\ root\ is\ smaller\ than\ the\ full\ node}}
\DoxyCodeLine{02844\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ size.\ Simply\ grow\ the\ size\ of\ the\ root\ node.}}
\DoxyCodeLine{02845\ \textcolor{stringliteral}{\ \ \ \ \ \ replace\_leaf\_root\_node(static\_cast<field\_type>(}}
\DoxyCodeLine{02846\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ (std::min)(static\_cast<int>(kNodeSlots),\ 2\ *\ max\_count)));}}
\DoxyCodeLine{02847\ \textcolor{stringliteral}{\ \ \ \ \ \ replaced\_node\ =\ true;}}
\DoxyCodeLine{02848\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02849\ \textcolor{stringliteral}{\ \ \ \ \ \ rebalance\_or\_split(\&iter);}}
\DoxyCodeLine{02850\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02851\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02852\ \textcolor{stringliteral}{\ \ (void)replaced\_node;}}
\DoxyCodeLine{02853\ \textcolor{stringliteral}{\#if\ defined(ABSL\_HAVE\_ADDRESS\_SANITIZER)\ ||\ \(\backslash\)}}
\DoxyCodeLine{02854\ \textcolor{stringliteral}{\ \ \ \ defined(ABSL\_HAVE\_HWADDRESS\_SANITIZER)}}
\DoxyCodeLine{02855\ \textcolor{stringliteral}{\ \ if\ (!replaced\_node)\ \{}}
\DoxyCodeLine{02856\ \textcolor{stringliteral}{\ \ \ \ assert(iter.node\_-\/>is\_leaf());}}
\DoxyCodeLine{02857\ \textcolor{stringliteral}{\ \ \ \ if\ (iter.node\_-\/>is\_root())\ \{}}
\DoxyCodeLine{02858\ \textcolor{stringliteral}{\ \ \ \ \ \ replace\_leaf\_root\_node(max\_count);}}
\DoxyCodeLine{02859\ \textcolor{stringliteral}{\ \ \ \ \}\ else\ \{}}
\DoxyCodeLine{02860\ \textcolor{stringliteral}{\ \ \ \ \ \ node\_type\ *old\_node\ =\ iter.node\_;}}
\DoxyCodeLine{02861\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ bool\ was\_rightmost\ =\ rightmost()\ ==\ old\_node;}}
\DoxyCodeLine{02862\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ bool\ was\_leftmost\ =\ leftmost()\ ==\ old\_node;}}
\DoxyCodeLine{02863\ \textcolor{stringliteral}{\ \ \ \ \ \ node\_type\ *parent\ =\ old\_node-\/>parent();}}
\DoxyCodeLine{02864\ \textcolor{stringliteral}{\ \ \ \ \ \ const\ field\_type\ position\ =\ old\_node-\/>position();}}
\DoxyCodeLine{02865\ \textcolor{stringliteral}{\ \ \ \ \ \ node\_type\ *new\_node\ =\ iter.node\_\ =\ new\_leaf\_node(position,\ parent);}}
\DoxyCodeLine{02866\ \textcolor{stringliteral}{\ \ \ \ \ \ parent-\/>set\_child\_noupdate\_position(position,\ new\_node);}}
\DoxyCodeLine{02867\ \textcolor{stringliteral}{\ \ \ \ \ \ transfer\_and\_delete(old\_node,\ new\_node);}}
\DoxyCodeLine{02868\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (was\_rightmost)\ mutable\_rightmost()\ =\ new\_node;}}
\DoxyCodeLine{02869\ \textcolor{stringliteral}{\ \ \ \ \ \ //\ The\ leftmost\ node\ is\ stored\ as\ the\ parent\ of\ the\ root\ node.}}
\DoxyCodeLine{02870\ \textcolor{stringliteral}{\ \ \ \ \ \ if\ (was\_leftmost)\ root()-\/>set\_parent(new\_node);}}
\DoxyCodeLine{02871\ \textcolor{stringliteral}{\ \ \ \ \}}}
\DoxyCodeLine{02872\ \textcolor{stringliteral}{\ \ \}}}
\DoxyCodeLine{02873\ \textcolor{stringliteral}{\#endif}}
\DoxyCodeLine{02874\ \textcolor{stringliteral}{\ \ iter.node\_-\/>emplace\_value(static\_cast<field\_type>(iter.position\_),\ alloc,}}
\DoxyCodeLine{02875\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ std::forward<Args>(args)...);}}
\DoxyCodeLine{02876\ \textcolor{stringliteral}{\ \ assert(}}
\DoxyCodeLine{02877\ \textcolor{stringliteral}{\ \ \ \ \ \ iter.node\_-\/>is\_ordered\_correctly(static\_cast<field\_type>(iter.position\_),}}
\DoxyCodeLine{02878\ \textcolor{stringliteral}{\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ original\_key\_compare(key\_comp()))\ \&\&}}
\DoxyCodeLine{02879\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}If\ \textcolor{keyword}{this}\ assert\ fails,\ then\ either\ (1)\ the\ comparator\ may\ violate\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{02880\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}transitivity,\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}.e.\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca0cc175b9c0f1b6a831c399e269772661}{a}},\mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2layout__test_8cc_ad66453096871179e6c6effe0df4b483b}{b}})\ \&\&\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}(\mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2layout__test_8cc_ad66453096871179e6c6effe0df4b483b}{b}},\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}})\ -\/>\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1checked__compare__base_a30fbd695f7f208bc07d04a0332ee656f}{comp}}(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca0cc175b9c0f1b6a831c399e269772661}{a}},\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca4a8a08f09d37b73795649038408b5f33}{c}})\ (see\ \textcolor{stringliteral}{"{}}}
\DoxyCodeLine{02881\ \textcolor{stringliteral}{\ \ \ \ \ \ "{}}https:\textcolor{comment}{//en.cppreference.com/w/cpp/named\_req/Compare),\ or\ (2)\ a\ "{}}}
\DoxyCodeLine{02882\ \ \ \ \ \ \ \textcolor{stringliteral}{"{}key\ may\ have\ been\ mutated\ after\ it\ was\ inserted\ into\ the\ tree."{}});}
\DoxyCodeLine{02883\ \ \ ++size\_;}
\DoxyCodeLine{02884\ \ \ iter.update\_generation();}
\DoxyCodeLine{02885\ \ \ \textcolor{keywordflow}{return}\ iter;}
\DoxyCodeLine{02886\ \}}
\DoxyCodeLine{02887\ }
\DoxyCodeLine{02888\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ P>}
\DoxyCodeLine{02889\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ K>}
\DoxyCodeLine{02890\ \textcolor{keyword}{inline}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{classabsl_1_1container__internal_1_1btree}{btree<P>::internal\_locate}}(\textcolor{keyword}{const}\ K\ \&\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}})\ \textcolor{keyword}{const}}
\DoxyCodeLine{02891\ \ \ \ \ -\/>\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1SearchResult}{SearchResult<iterator,\ is\_key\_compare\_to::value>}}\ \{}
\DoxyCodeLine{02892\ \ \ iterator\ iter(\textcolor{keyword}{const\_cast<}node\_type\ *\textcolor{keyword}{>}(root()));}
\DoxyCodeLine{02893\ \ \ \textcolor{keywordflow}{for}\ (;;)\ \{}
\DoxyCodeLine{02894\ \ \ \ \ \mbox{\hyperlink{structabsl_1_1container__internal_1_1SearchResult}{SearchResult<size\_type,\ is\_key\_compare\_to::value>}}\ res\ =}
\DoxyCodeLine{02895\ \ \ \ \ \ \ \ \ iter.node\_-\/>lower\_bound(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}},\ key\_comp());}
\DoxyCodeLine{02896\ \ \ \ \ iter.position\_\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(res.\mbox{\hyperlink{structabsl_1_1container__internal_1_1SearchResult_ae07fce6061bf369ba4ae080871efaca6}{value}});}
\DoxyCodeLine{02897\ \ \ \ \ \textcolor{keywordflow}{if}\ (res.\mbox{\hyperlink{structabsl_1_1container__internal_1_1SearchResult_ab93bfec62f4c058a1765a6da746d8931}{IsEq}}())\ \{}
\DoxyCodeLine{02898\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ \{iter,\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_af1e15c6a8cc6740050435f4a6719acbca3d02bee6105201371a5a6c70cfdf1719}{MatchKind::kEq}}\};}
\DoxyCodeLine{02899\ \ \ \ \ \}}
\DoxyCodeLine{02900\ \ \ \ \ \textcolor{comment}{//\ Note:\ in\ the\ non-\/key-\/compare-\/to\ case,\ we\ don't\ need\ to\ walk\ all\ the\ way}}
\DoxyCodeLine{02901\ \ \ \ \ \textcolor{comment}{//\ down\ the\ tree\ if\ the\ keys\ are\ equal,\ but\ determining\ equality\ would}}
\DoxyCodeLine{02902\ \ \ \ \ \textcolor{comment}{//\ require\ doing\ an\ extra\ comparison\ on\ each\ node\ on\ the\ way\ down,\ and\ we}}
\DoxyCodeLine{02903\ \ \ \ \ \textcolor{comment}{//\ will\ need\ to\ go\ all\ the\ way\ to\ the\ leaf\ node\ in\ the\ expected\ case.}}
\DoxyCodeLine{02904\ \ \ \ \ \textcolor{keywordflow}{if}\ (iter.node\_-\/>is\_leaf())\ \{}
\DoxyCodeLine{02905\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02906\ \ \ \ \ \}}
\DoxyCodeLine{02907\ \ \ \ \ iter.node\_\ =\ iter.node\_-\/>child(\textcolor{keyword}{static\_cast<}field\_type\textcolor{keyword}{>}(iter.position\_));}
\DoxyCodeLine{02908\ \ \ \}}
\DoxyCodeLine{02909\ \ \ \textcolor{comment}{//\ Note:\ in\ the\ non-\/key-\/compare-\/to\ case,\ the\ key\ may\ actually\ be\ equivalent}}
\DoxyCodeLine{02910\ \ \ \textcolor{comment}{//\ here\ (and\ the\ MatchKind::kNe\ is\ ignored).}}
\DoxyCodeLine{02911\ \ \ \textcolor{keywordflow}{return}\ \{iter,\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_af1e15c6a8cc6740050435f4a6719acbcaef8ce0f91aa41552185976d00d11bd2b}{MatchKind::kNe}}\};}
\DoxyCodeLine{02912\ \}}
\DoxyCodeLine{02913\ }
\DoxyCodeLine{02914\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ P>}
\DoxyCodeLine{02915\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ K>}
\DoxyCodeLine{02916\ \textcolor{keyword}{auto}\ btree<P>::internal\_lower\_bound(\textcolor{keyword}{const}\ K\ \&\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}})\ \textcolor{keyword}{const}}
\DoxyCodeLine{02917\ \ \ \ \ -\/>\ SearchResult<iterator,\ is\_key\_compare\_to::value>\ \{}
\DoxyCodeLine{02918\ \ \ \textcolor{keywordflow}{if}\ (!params\_type::template\ can\_have\_multiple\_equivalent\_keys<K>())\ \{}
\DoxyCodeLine{02919\ \ \ \ \ SearchResult<iterator,\ is\_key\_compare\_to::value>\ ret\ =\ internal\_locate(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}});}
\DoxyCodeLine{02920\ \ \ \ \ ret.value\ =\ internal\_last(ret.value);}
\DoxyCodeLine{02921\ \ \ \ \ \textcolor{keywordflow}{return}\ ret;}
\DoxyCodeLine{02922\ \ \ \}}
\DoxyCodeLine{02923\ \ \ iterator\ iter(\textcolor{keyword}{const\_cast<}node\_type\ *\textcolor{keyword}{>}(root()));}
\DoxyCodeLine{02924\ \ \ SearchResult<size\_type,\ is\_key\_compare\_to::value>\ res;}
\DoxyCodeLine{02925\ \ \ \textcolor{keywordtype}{bool}\ seen\_eq\ =\ \textcolor{keyword}{false};}
\DoxyCodeLine{02926\ \ \ \textcolor{keywordflow}{for}\ (;;)\ \{}
\DoxyCodeLine{02927\ \ \ \ \ res\ =\ iter.node\_-\/>lower\_bound(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}},\ key\_comp());}
\DoxyCodeLine{02928\ \ \ \ \ iter.position\_\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(res.value);}
\DoxyCodeLine{02929\ \ \ \ \ \textcolor{keywordflow}{if}\ (iter.node\_-\/>is\_leaf())\ \{}
\DoxyCodeLine{02930\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02931\ \ \ \ \ \}}
\DoxyCodeLine{02932\ \ \ \ \ seen\_eq\ =\ seen\_eq\ ||\ res.IsEq();}
\DoxyCodeLine{02933\ \ \ \ \ iter.node\_\ =\ iter.node\_-\/>child(\textcolor{keyword}{static\_cast<}field\_type\textcolor{keyword}{>}(iter.position\_));}
\DoxyCodeLine{02934\ \ \ \}}
\DoxyCodeLine{02935\ \ \ \textcolor{keywordflow}{if}\ (res.IsEq())\ \textcolor{keywordflow}{return}\ \{iter,\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_af1e15c6a8cc6740050435f4a6719acbca3d02bee6105201371a5a6c70cfdf1719}{MatchKind::kEq}}\};}
\DoxyCodeLine{02936\ \ \ \textcolor{keywordflow}{return}\ \{internal\_last(iter),\ seen\_eq\ ?\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_af1e15c6a8cc6740050435f4a6719acbca3d02bee6105201371a5a6c70cfdf1719}{MatchKind::kEq}}\ :\ \mbox{\hyperlink{namespaceabsl_1_1container__internal_af1e15c6a8cc6740050435f4a6719acbcaef8ce0f91aa41552185976d00d11bd2b}{MatchKind::kNe}}\};}
\DoxyCodeLine{02937\ \}}
\DoxyCodeLine{02938\ }
\DoxyCodeLine{02939\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ P>}
\DoxyCodeLine{02940\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ K>}
\DoxyCodeLine{02941\ \textcolor{keyword}{auto}\ btree<P>::internal\_upper\_bound(\textcolor{keyword}{const}\ K\ \&\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}})\ \textcolor{keyword}{const}\ -\/>\ iterator\ \{}
\DoxyCodeLine{02942\ \ \ iterator\ iter(\textcolor{keyword}{const\_cast<}node\_type\ *\textcolor{keyword}{>}(root()));}
\DoxyCodeLine{02943\ \ \ \textcolor{keywordflow}{for}\ (;;)\ \{}
\DoxyCodeLine{02944\ \ \ \ \ iter.position\_\ =\ \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(iter.node\_-\/>upper\_bound(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}},\ key\_comp()));}
\DoxyCodeLine{02945\ \ \ \ \ \textcolor{keywordflow}{if}\ (iter.node\_-\/>is\_leaf())\ \{}
\DoxyCodeLine{02946\ \ \ \ \ \ \ \textcolor{keywordflow}{break};}
\DoxyCodeLine{02947\ \ \ \ \ \}}
\DoxyCodeLine{02948\ \ \ \ \ iter.node\_\ =\ iter.node\_-\/>child(\textcolor{keyword}{static\_cast<}field\_type\textcolor{keyword}{>}(iter.position\_));}
\DoxyCodeLine{02949\ \ \ \}}
\DoxyCodeLine{02950\ \ \ \textcolor{keywordflow}{return}\ internal\_last(iter);}
\DoxyCodeLine{02951\ \}}
\DoxyCodeLine{02952\ }
\DoxyCodeLine{02953\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ P>}
\DoxyCodeLine{02954\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ K>}
\DoxyCodeLine{02955\ \textcolor{keyword}{auto}\ btree<P>::internal\_find(\textcolor{keyword}{const}\ K\ \&\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}})\ \textcolor{keyword}{const}\ -\/>\ iterator\ \{}
\DoxyCodeLine{02956\ \ \ SearchResult<iterator,\ is\_key\_compare\_to::value>\ res\ =\ internal\_locate(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}});}
\DoxyCodeLine{02957\ \ \ \textcolor{keywordflow}{if}\ (res.HasMatch())\ \{}
\DoxyCodeLine{02958\ \ \ \ \ \textcolor{keywordflow}{if}\ (res.IsEq())\ \{}
\DoxyCodeLine{02959\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ res.value;}
\DoxyCodeLine{02960\ \ \ \ \ \}}
\DoxyCodeLine{02961\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{02962\ \ \ \ \ \textcolor{keyword}{const}\ iterator\ iter\ =\ internal\_last(res.value);}
\DoxyCodeLine{02963\ \ \ \ \ \textcolor{keywordflow}{if}\ (iter.node\_\ !=\ \textcolor{keyword}{nullptr}\ \&\&\ !compare\_keys(\mbox{\hyperlink{abseil-cpp_2absl_2container_2btree__test_8cc_a35af0be900467fedbb610bd6ea65ed78}{key}},\ iter.key()))\ \{}
\DoxyCodeLine{02964\ \ \ \ \ \ \ \textcolor{keywordflow}{return}\ iter;}
\DoxyCodeLine{02965\ \ \ \ \ \}}
\DoxyCodeLine{02966\ \ \ \}}
\DoxyCodeLine{02967\ \ \ \textcolor{keywordflow}{return}\ \{\textcolor{keyword}{nullptr},\ 0\};}
\DoxyCodeLine{02968\ \}}
\DoxyCodeLine{02969\ }
\DoxyCodeLine{02970\ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ P>}
\DoxyCodeLine{02971\ \textcolor{keyword}{typename}\ \mbox{\hyperlink{classabsl_1_1container__internal_1_1btree_ad17e8714699b58a1a9c4b5ee6c27cec7}{btree<P>::size\_type}}\ btree<P>::internal\_verify(}
\DoxyCodeLine{02972\ \ \ \ \ \textcolor{keyword}{const}\ node\_type\ *node,\ \textcolor{keyword}{const}\ key\_type\ *lo,\ \textcolor{keyword}{const}\ key\_type\ *hi)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{02973\ \ \ assert(node-\/>count()\ >\ 0);}
\DoxyCodeLine{02974\ \ \ assert(node-\/>count()\ <=\ node-\/>max\_count());}
\DoxyCodeLine{02975\ \ \ \textcolor{keywordflow}{if}\ (lo)\ \{}
\DoxyCodeLine{02976\ \ \ \ \ assert(!compare\_keys(node-\/>key(node-\/>start()),\ *lo));}
\DoxyCodeLine{02977\ \ \ \}}
\DoxyCodeLine{02978\ \ \ \textcolor{keywordflow}{if}\ (hi)\ \{}
\DoxyCodeLine{02979\ \ \ \ \ assert(!compare\_keys(*hi,\ node-\/>key(node-\/>finish()\ -\/\ 1)));}
\DoxyCodeLine{02980\ \ \ \}}
\DoxyCodeLine{02981\ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keywordtype}{int}\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ =\ node-\/>start()\ +\ 1;\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i\ <\ node-\/>}}finish();\ ++\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}})\ \{}
\DoxyCodeLine{02982\ \ \ \ \ assert(!compare\_keys(node-\/>key(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}),\ node-\/>key(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ -\/\ 1)));}
\DoxyCodeLine{02983\ \ \ \}}
\DoxyCodeLine{02984\ \ \ size\_type\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2raw__hash__set__test_8cc_ad43c3812e6d13e0518d9f8b8f463ffcf}{count}}\ =\ node-\/>count();}
\DoxyCodeLine{02985\ \ \ \textcolor{keywordflow}{if}\ (node-\/>is\_internal())\ \{}
\DoxyCodeLine{02986\ \ \ \ \ \textcolor{keywordflow}{for}\ (field\_type\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ =\ node-\/>start();\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i\ <=\ node-\/>}}finish();\ ++\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}})\ \{}
\DoxyCodeLine{02987\ \ \ \ \ \ \ assert(node-\/>child(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}})\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{02988\ \ \ \ \ \ \ assert(node-\/>child(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}})-\/>parent()\ ==\ node);}
\DoxyCodeLine{02989\ \ \ \ \ \ \ assert(node-\/>child(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}})-\/>position()\ ==\ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}});}
\DoxyCodeLine{02990\ \ \ \ \ \ \ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2raw__hash__set__test_8cc_ad43c3812e6d13e0518d9f8b8f463ffcf}{count}}\ +=\ internal\_verify(node-\/>child(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}),}
\DoxyCodeLine{02991\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ ==\ node-\/>start()\ ?\ lo\ :\ \&node-\/>key(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ -\/\ 1),}
\DoxyCodeLine{02992\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}\ ==\ node-\/>finish()\ ?\ hi\ :\ \&node-\/>key(\mbox{\hyperlink{namespaceabsl_a828e0f13fb3947cdf6406b7a4feec8aca865c0c0b4ab0e063e5caa3387c1a8741}{i}}));}
\DoxyCodeLine{02993\ \ \ \ \ \}}
\DoxyCodeLine{02994\ \ \ \}}
\DoxyCodeLine{02995\ \ \ \textcolor{keywordflow}{return}\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2raw__hash__set__test_8cc_ad43c3812e6d13e0518d9f8b8f463ffcf}{count}};}
\DoxyCodeLine{02996\ \}}
\DoxyCodeLine{02997\ }
\DoxyCodeLine{02998\ \textcolor{keyword}{struct\ }\mbox{\hyperlink{structabsl_1_1container__internal_1_1btree__access}{btree\_access}}\ \{}
\DoxyCodeLine{02999\ \ \ \textcolor{keyword}{template}\ <\textcolor{keyword}{typename}\ BtreeContainer,\ \textcolor{keyword}{typename}\ Pred>}
\DoxyCodeLine{03000\ \ \ \textcolor{keyword}{static}\ \textcolor{keyword}{auto}\ \mbox{\hyperlink{structabsl_1_1container__internal_1_1btree__access_a8e16146a3f2ab2ba43ddd4e3c973a2b0}{erase\_if}}(BtreeContainer\ \&container,\ Pred\ pred)\ -\/>}
\DoxyCodeLine{03001\ \ \ \ \ \ \ \textcolor{keyword}{typename}\ BtreeContainer::size\_type\ \{}
\DoxyCodeLine{03002\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ initial\_size\ =\ container.size();}
\DoxyCodeLine{03003\ \ \ \ \ \textcolor{keyword}{auto}\ \&tree\ =\ container.tree\_;}
\DoxyCodeLine{03004\ \ \ \ \ \textcolor{keyword}{auto}\ *\mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2common__policy__traits__test_8cc_a58bc91864ce9643c9ce65eeebdf8d5f1}{alloc}}\ =\ tree.mutable\_allocator();}
\DoxyCodeLine{03005\ \ \ \ \ \textcolor{keywordflow}{for}\ (\textcolor{keyword}{auto}\ it\ =\ container.begin();\ it\ !=\ container.end();)\ \{}
\DoxyCodeLine{03006\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (!pred(*it))\ \{}
\DoxyCodeLine{03007\ \ \ \ \ \ \ \ \ ++it;}
\DoxyCodeLine{03008\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{03009\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03010\ \ \ \ \ \ \ \textcolor{keyword}{auto}\ *node\ =\ it.node\_;}
\DoxyCodeLine{03011\ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (node-\/>is\_internal())\ \{}
\DoxyCodeLine{03012\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Handle\ internal\ nodes\ normally.}}
\DoxyCodeLine{03013\ \ \ \ \ \ \ \ \ it\ =\ container.erase(it);}
\DoxyCodeLine{03014\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{continue};}
\DoxyCodeLine{03015\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03016\ \ \ \ \ \ \ \textcolor{comment}{//\ If\ this\ is\ a\ leaf\ node,\ then\ we\ do\ all\ the\ erases\ from\ this\ node}}
\DoxyCodeLine{03017\ \ \ \ \ \ \ \textcolor{comment}{//\ at\ once\ before\ doing\ rebalancing.}}
\DoxyCodeLine{03018\ }
\DoxyCodeLine{03019\ \ \ \ \ \ \ \textcolor{comment}{//\ The\ current\ position\ to\ transfer\ slots\ to.}}
\DoxyCodeLine{03020\ \ \ \ \ \ \ \textcolor{keywordtype}{int}\ to\_pos\ =\ it.position\_;}
\DoxyCodeLine{03021\ \ \ \ \ \ \ node-\/>value\_destroy(it.position\_,\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2common__policy__traits__test_8cc_a58bc91864ce9643c9ce65eeebdf8d5f1}{alloc}});}
\DoxyCodeLine{03022\ \ \ \ \ \ \ \textcolor{keywordflow}{while}\ (++it.position\_\ <\ node-\/>finish())\ \{}
\DoxyCodeLine{03023\ \ \ \ \ \ \ \ \ it.update\_generation();}
\DoxyCodeLine{03024\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ (pred(*it))\ \{}
\DoxyCodeLine{03025\ \ \ \ \ \ \ \ \ \ \ node-\/>value\_destroy(it.position\_,\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2common__policy__traits__test_8cc_a58bc91864ce9643c9ce65eeebdf8d5f1}{alloc}});}
\DoxyCodeLine{03026\ \ \ \ \ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{03027\ \ \ \ \ \ \ \ \ \ \ node-\/>transfer(node-\/>slot(to\_pos++),\ node-\/>slot(it.position\_),\ \mbox{\hyperlink{abseil-cpp_2absl_2container_2internal_2common__policy__traits__test_8cc_a58bc91864ce9643c9ce65eeebdf8d5f1}{alloc}});}
\DoxyCodeLine{03028\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{03029\ \ \ \ \ \ \ \}}
\DoxyCodeLine{03030\ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keywordtype}{int}\ num\_deleted\ =\ node-\/>finish()\ -\/\ to\_pos;}
\DoxyCodeLine{03031\ \ \ \ \ \ \ tree.size\_\ -\/=\ num\_deleted;}
\DoxyCodeLine{03032\ \ \ \ \ \ \ node-\/>set\_finish(to\_pos);}
\DoxyCodeLine{03033\ \ \ \ \ \ \ it.position\_\ =\ to\_pos;}
\DoxyCodeLine{03034\ \ \ \ \ \ \ it\ =\ tree.rebalance\_after\_delete(it);}
\DoxyCodeLine{03035\ \ \ \ \ \}}
\DoxyCodeLine{03036\ \ \ \ \ \textcolor{keywordflow}{return}\ initial\_size\ -\/\ container.size();}
\DoxyCodeLine{03037\ \ \ \}}
\DoxyCodeLine{03038\ \};}
\DoxyCodeLine{03039\ }
\DoxyCodeLine{03040\ \textcolor{preprocessor}{\#undef\ ABSL\_BTREE\_ENABLE\_GENERATIONS}}
\DoxyCodeLine{03041\ }
\DoxyCodeLine{03042\ \}\ \ \textcolor{comment}{//\ namespace\ container\_internal}}
\DoxyCodeLine{03043\ \mbox{\hyperlink{abseil-cpp_2absl_2base_2config_8h_a49c6cd9be2b7205d48557c9fa90ec5a6}{ABSL\_NAMESPACE\_END}}}
\DoxyCodeLine{03044\ \}\ \ \textcolor{comment}{//\ namespace\ absl}}
\DoxyCodeLine{03045\ }
\DoxyCodeLine{03046\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ ABSL\_CONTAINER\_INTERNAL\_BTREE\_H\_}}

\end{DoxyCode}
